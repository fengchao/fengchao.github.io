<!-- build time:Thu Nov 24 2016 17:46:17 GMT+0800 (CST) --><!doctype html><html class="theme-next mist use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="baidu-site-verification" content="6c70qR5DN9"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/atom.xml" title="Chaospace" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta property="og:type" content="website"><meta property="og:title" content="Chaospace"><meta property="og:url" content="http://fengchao.github.io/page/2/index.html"><meta property="og:site_name" content="Chaospace"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Chaospace"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"博主"}}</script><link rel="canonical" href="http://fengchao.github.io/page/2/"><title>Chaospace</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans,en,default"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e6e028efa4e1db3bb40b47f735c82723";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Chaospace</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Reshape the world by engineering chaos</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div><span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/06/28/The-Innovators-Dilemma/" itemprop="url">创新者的窘境</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-06-28T10:31:57+08:00" content="2016-06-28">2016-06-28 </time></span><span class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/商业/" itemprop="url" rel="index"><span itemprop="name">商业</span> </a></span></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/06/28/The-Innovators-Dilemma/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/06/28/The-Innovators-Dilemma/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>具有领先优势的大公司，在面对突破性的技术创新时，失去了竞争优势，被后起者超越。《创新者的窘境》这本书希望找到问题原因</p><h2 id="原因总结"><a href="#原因总结" class="headerlink" title="原因总结"></a>原因总结</h2><ol><li>资源分配的重心是满足当前用户，所以创新产品得不到足够的重视。</li><li>公司规模和市场规模不匹配。新技术的市场规模开始时都比较小，大公司会忽略这个小市场。</li><li>新的市场可能是不存在的，所以很难去分析。不但是未知的，而且是不可知的。</li><li>害怕失败，不愿意离开安全区。</li></ol><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>创建与世隔绝的科研基地，封闭开发。</li><li>将突破性技术商业化的责任交给一个足够小的机构。</li><li>在未知市场试错，发现新的机会。避免传统的绩效考核方式。</li><li>创业公司、孵化器。</li></ol></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/06/23/Tech-Type-and-solution/" itemprop="url">技术类型和典型缺陷</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-06-23T17:56:13+08:00" content="2016-06-23">2016-06-23 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/06/23/Tech-Type-and-solution/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/06/23/Tech-Type-and-solution/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>不同的技术类型，有不同的缺陷，需要重点关注和加强：</p><p><img src="/images/Tech_person_type.jpg" alt="Type"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/06/14/Google-win-Oracle/" itemprop="url">甲骨文告谷歌 - 输了</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-06-14T14:34:38+08:00" content="2016-06-14">2016-06-14 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/06/14/Google-win-Oracle/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/Google-win-Oracle/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Java-开源十年"><a href="#Java-开源十年" class="headerlink" title="Java 开源十年"></a>Java 开源十年</h3><p>十年前 <a href="http://fengchao.github.io/2006/11/16/Sun-Opens-Java/">Sun 开源 Java</a> 的时候，普天同庆。一个新的世界展现在 Java 眼前，一个开源的 Java 吸引力更多开发者和公司的贡献。十年间，</p><p>谷歌做了 Android，用 Java 作为软件开发语言。Android 凭借开源属性，和苹果展开激烈竞争，成为世界第一手机操作系统。</p><h3 id="专利流氓搅局"><a href="#专利流氓搅局" class="headerlink" title="专利流氓搅局"></a>专利流氓搅局</h3><p>甲骨文收购了 Sun，但是花了很多年时间，依然搞不清楚怎么通过开源软件盈利，看到 Android 这么风生水起，显然眼红的不行。于是拿起专利大棒，状告谷歌侵权并索赔 90 亿美元。</p><p>甲骨文自己在 Java 开发上鲜有作为，却暗指谷歌 Android 的成功完全是 Java 带来的，说的好像自己也能搞出来一个 Android 似的，在专利流氓的道路上越走越远。</p><p>旧金山联邦法庭陪审团今日已做出裁决，认定谷歌 Android 并未侵犯 Oracle 所有的 Java 版权。Google 表示，陪审团的认定代表了 Android 生态体系、Java 开发社区以及依靠开放免费编程语言开发创新消费者产品的软件开发者的胜利。松下一口气的不只有 Google，也包括成千上万的软件开发者。</p><h3 id="阴霾笼罩-Java"><a href="#阴霾笼罩-Java" class="headerlink" title="阴霾笼罩 Java"></a>阴霾笼罩 Java</h3><p>虽然官司赢了，但是 Java 的开源道路已经蒙上了厚厚的阴霾。很多公司再做创新性开发的时候，一定会考虑避免再拿 Java 作为核心组件。毕竟不是每个公司都能像谷歌一样请到最好的律师，能够和甲骨文巨头搞法律对战。</p><p>微软一直想做，但是没有做成的事情，甲骨文做到了。</p><p>软件版权，已经成为创新的障碍；软件版权，应该消亡。</p><p><img src="/images/conways_law.png" alt="Sun 开源 Java"></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/06/13/Tmux/" itemprop="url">Tmux 快速指南</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-06-13T11:17:28+08:00" content="2016-06-13">2016-06-13 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/06/13/Tmux/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/06/13/Tmux/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>启动</td><td>tmux</td></tr><tr><td>帮助</td><td>^b ?</td></tr></tbody></table><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>新建会话</td><td>tmux new-session -s play</td></tr><tr><td>重命名会话</td><td>tmux rename-session tutorial</td></tr><tr><td>查看会话</td><td>tmux ls</td></tr><tr><td>加入会话</td><td>tmux attach -t ‘’session’’</td></tr><tr><td>脱离会话</td><td>^b d</td></tr></tbody></table><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>创建窗口</td><td>^b c</td></tr><tr><td>关闭窗口</td><td>^d</td></tr><tr><td>下个窗口</td><td>^b n</td></tr><tr><td>上个窗口</td><td>^b p</td></tr><tr><td>最后窗口</td><td>^b l</td></tr><tr><td>选择窗口</td><td>^b w</td></tr><tr><td>查找窗口</td><td>^b f</td></tr></tbody></table><h2 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>水平分割</td><td>^b %</td></tr><tr><td>垂直分割</td><td>^b “</td></tr><tr><td>切换</td><td>^b o</td></tr><tr><td>放大</td><td>^b z</td></tr></tbody></table></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/06/12/Open-source-funnel/" itemprop="url">开源漏斗模型</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-06-12T16:08:03+08:00" content="2016-06-12">2016-06-12 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/06/12/Open-source-funnel/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/06/12/Open-source-funnel/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/images/Funnel.png" alt="Funnel" title="Funnel"></p><h2 id="销售漏斗"><a href="#销售漏斗" class="headerlink" title="销售漏斗"></a>销售漏斗</h2><p>销售中有一个经典的漏斗模型，一个用户需要一系列步骤才会真正购买。在每一个步骤上，都会有用户止步不前，所以最终购买的用户仅仅是潜在用户的很小一部分。</p><ol><li>潜在客户</li><li>了解产品</li><li>浏览网页</li><li>产生购买欲望</li><li>点击购物车</li><li>网银付款</li><li>快递收货</li><li>实际使用</li></ol><h2 id="开发漏斗"><a href="#开发漏斗" class="headerlink" title="开发漏斗"></a>开发漏斗</h2><p>同样，在开源开发中也有类似的漏斗模型存在:</p><ol><li>使用产品</li><li>参与社区讨论</li><li>首次参与贡献</li><li>长期开发者</li><li>核心开发者</li></ol><p>同样的，每一步都会有开发者止步不前，只有极少数人会成为核心开发者。所以为了提高最终的成功可能，获得更多的开发者，一个开源产品也需要进行运营工作。</p><h2 id="运营开源产品"><a href="#运营开源产品" class="headerlink" title="运营开源产品"></a>运营开源产品</h2><h3 id="用户社区"><a href="#用户社区" class="headerlink" title="用户社区"></a>用户社区</h3><p>互联网经济中，所有公司都已经大大提高了对用户社区的重视程度。对开源产品来说，更是如此。很多开源项目都有非常活跃的论坛、IRC、邮件列表等等，老用户帮助新用户。</p><h3 id="首次贡献"><a href="#首次贡献" class="headerlink" title="首次贡献"></a>首次贡献</h3><p>大部分用户开源软件的首次贡献，都是在使用的过程中遇到 Bug。为了解决自己遇到的问题，就去查看代码，找到问题原因，并提交补丁。</p><p>和封闭系统相比，开源系统大大降低了活跃用户参与贡献的难度。尤其是 <a href="https://github.com/" target="_blank" rel="external">Github</a> 的 pull request 机制，更是简化了 patch 提交和合并流程。为了让更多的用户进行首次贡献，一个开源项目最好提供一份快速启动手册，一个专门的页面介绍如何进行贡献。</p><h3 id="长期贡献"><a href="#长期贡献" class="headerlink" title="长期贡献"></a>长期贡献</h3><p>首次贡献变为长期贡献，是一个很艰难的过程。除了解决自己的问题，还是需要额外的动力。对于开源软件来说，商业社会惯用的钱已经起不了作用了。</p><p>不为钱，则为利。需要给这些开发者足够的荣誉，比如贡献者列表等等。激发人对内心自我实现的渴望。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/06/08/why-people-burn-out/" itemprop="url">为什么你会不堪重负</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-06-08T16:35:28+08:00" content="2016-06-08">2016-06-08 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/06/08/why-people-burn-out/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/06/08/why-people-burn-out/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="强迫证明自己"><a href="#强迫证明自己" class="headerlink" title="强迫证明自己"></a>强迫证明自己</h3><p>通常情况下都是具有过度的野心。这欲望本是用来证明自己的，但在工作场所，这个欲望往往变成决心和强制性的。</p><h3 id="更加努力的工作"><a href="#更加努力的工作" class="headerlink" title="更加努力的工作"></a>更加努力的工作</h3><p>为了融入一个不适合自己的组织，为自己定了较高的期望值。为了满足这些期望，他们往往只专注于工作，而且他们愿意承担更多的工作。这往往都会让他们任何事都要亲自作为，这都是为了表明他们是最好的，因为他们不需要他人的帮助完成更多的工作量。</p><h3 id="忽略需求"><a href="#忽略需求" class="headerlink" title="忽略需求"></a>忽略需求</h3><p>因为他们一心只关注与工作，他们几乎没有时间和精力再做别的事情。与朋友，家人聚餐和吃饭，睡觉一般的生理需求已经被他们视为不重要的了，因为这会浪费他们的时间。</p><h3 id="冲突转移"><a href="#冲突转移" class="headerlink" title="冲突转移"></a>冲突转移</h3><p>他们开始意识到某些地方不太对劲，但他们无法正确归因。这可能导致他们激烈的内心冲突进而引发一系列的身体症状——这是他们首先表现出身体症状的阶段。</p><h3 id="价值观重组"><a href="#价值观重组" class="headerlink" title="价值观重组"></a>价值观重组</h3><p>在这个阶段，他们将自己无形中隔离，规避与他人的冲突，并且因为他们认知模式的改变，他们否认或是拒绝自己正当的生理需要。他们的价值观体系也随之改变。工作占据了他们能支配的所有精力，从而他们再没有关照朋友或者家人的功夫。他们新的价值观围绕着工作，并且他们开始变得情感迟钝。</p><h3 id="否认暴露的问题"><a href="#否认暴露的问题" class="headerlink" title="否认暴露的问题"></a>否认暴露的问题</h3><p>他们开始变得偏执。他们不再喜欢社会生活，如果要他们参加社交活动的话，他们会觉得那几乎无法忍受。对他们了解不多的局外人可能会看到他们显示出更加强烈的攻击性。人们常常会发现，他们越发倾向于抱怨他们的工作是多么庞杂难以完成，他们的时间是如何不够他们支配，而非他们自己是否做出了什么改变。</p><h3 id="自闭"><a href="#自闭" class="headerlink" title="自闭"></a>自闭</h3><p>他们的社交只维持在最小限度，并且很快他们自己陷入自闭的状态之中。酒精和兴奋性药物可能会被滥用用来在他们满负荷的工作之余排解他们的压力。他们在这个阶段开始常常经历无助感和无方向感。</p><h3 id="自显著的行为改变"><a href="#自显著的行为改变" class="headerlink" title="自显著的行为改变"></a>自显著的行为改变</h3><p>他们的同事，家人，朋友以及他们社交圈中的其他人会显著注意到他们行为上的改变。</p><h3 id="人格解体"><a href="#人格解体" class="headerlink" title="人格解体"></a>人格解体</h3><p>他们与自己失去了沟通，也就很难在他们自己或是他人身上看到任何价值之所在。与此同时，他们失去了对自己个人需求的响应。他们对生活的观念下降到只关注现有的时间，他们的人生变成了一系列的机械的功能组合。</p><h3 id="内心空虚"><a href="#内心空虚" class="headerlink" title="内心空虚"></a>内心空虚</h3><p>他们感到内心空虚。为了规避这一点，他们可能会去找其他乐子，暴饮暴食，乱性，酒精或者毒品。这些行为可能会非常夸张。</p><h3 id="抑郁"><a href="#抑郁" class="headerlink" title="抑郁"></a>抑郁</h3><p>心力交瘁可能带来抑郁。他们感到疲惫不堪，绝望，冷漠，并且认为未来的生活对他们毫无意义。典型的抑郁症状开始出现。</p><h3 id="心力交瘁综合症"><a href="#心力交瘁综合症" class="headerlink" title="心力交瘁综合症"></a>心力交瘁综合症</h3><p>身心崩溃。在这个阶段，他们应该立即寻求医疗的帮助。在极端的抑郁状况下，可能会出现自杀意念——自杀被这时的他们视为一种逃离现有状况的方式。但只有很少一部分人会实施自杀。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/05/27/flashroom/" itemprop="url">flashroom</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-05-27T15:29:34+08:00" content="2016-05-27">2016-05-27 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/05/27/flashroom/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/05/27/flashroom/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>最近在做 Corebios （曾经的 Linuxbios）到 EPIA 板子的移植，发现 flashrom 真是好用。</p><h3 id="1-手动安装："><a href="#1-手动安装：" class="headerlink" title="1. 手动安装："></a>1. 手动安装：</h3><pre><code>$ svn co svn://coreboot.org/repos/trunk/util/flashrom
$ cd flashrom
$ make
$ sudo make install
</code></pre><h3 id="2-直接安装："><a href="#2-直接安装：" class="headerlink" title="2.直接安装："></a>2.直接安装：</h3><p>Debian</p><pre><code>$ sudo aptitude install flashrom
</code></pre><p>Fedora</p><pre><code>$ sudo yum install flashrom
</code></pre><p>Mandriva</p><pre><code>$ urpmi flashrom
</code></pre><p>openSUSE</p><pre><code>$ yast -i coreboot-utils
</code></pre><h3 id="3-使用方法："><a href="#3-使用方法：" class="headerlink" title="3 使用方法："></a>3 使用方法：</h3><p>检测主板和芯片是否支持：<br>$ flashrom</p><p>将原有 BIOS 备份读取出来</p><pre><code>$ flashrom -r backup.bin
</code></pre><p>写入新的 BIOS</p><pre><code>$ flashrom -wv newbios.bin
</code></pre><h3 id="4-更详细的信息请查看Flashrom的README"><a href="#4-更详细的信息请查看Flashrom的README" class="headerlink" title="4 更详细的信息请查看Flashrom的README"></a>4 更详细的信息请查看Flashrom的README</h3></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/05/27/PCI-device-driver/" itemprop="url">PCI 设备驱动</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-05-27T15:25:07+08:00" content="2016-05-27">2016-05-27 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/05/27/PCI-device-driver/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/05/27/PCI-device-driver/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="1-PCI-简介"><a href="#1-PCI-简介" class="headerlink" title="1. PCI 简介"></a>1. PCI 简介</h3><p>PCI 总线标准是一种将系统外部设备连接起来的总线标准，是 PC 中最重要的总线，实际上是系统的各个部分如何交互的接口。传输速率可达到 133MB/s。在当前的 PC 体系结构中，几乎所有的外部设备采用的各种各样的接口总线，均是通过桥接电路挂接到 PCI 系统上。在这种 PCI 系统中， Host/PCI 桥称为北桥，连接主处理器总线到基础 PCI 局部总线。 PCI 与其他总线的接口称为南桥，其中南桥还通常含有中断控制器、IDE 控制器、USB 控制器和 DMA 控制器等。南桥和北桥组成主板的芯片组。</p><h3 id="2-PCI配置空间"><a href="#2-PCI配置空间" class="headerlink" title="2. PCI配置空间"></a>2. PCI配置空间</h3><p>每个PCI设备都有自己的配置空间，用于支持即插即用，使之满足现行的系统配置结构。下面对PCI配置空间做一下简要介绍。</p><p>配置空间是一容量为256字节并具有特定结构的地址空间。这个空间又分为头标区和设备有关区两部分。头标区的长度是64字节，每个设备都必须配置该区的寄存 器。该区中的各个字段用来唯一地识别设备。其余的192字节因设备而异。配置空间的头标区64个字节的使用情况如图1示。</p><p>为了实现即插即用，系统可根据硬件资源的使用情况，为PCI设备分配新的资源。因此编写设备驱动程序重点是获得基址寄存器（Base Address）和中断干线寄存器的内容。配置空间共有六个基址寄存器和一个中断干线寄存器，具体用法如下：</p><p>PCI Base Address 0 寄存器：系统利用此寄存器为PCI接口芯片的配置寄存器分配一段PCI地址空间，通过这段地址我们可以以内存映射的形式访问PCI接口芯片的配置寄存器。</p><p>PCI Base Address 1寄存器：系统利用此寄存器为 PCI 接口芯片的配置寄存器分配一段PCI地址空间，通过这段地址我们可以以I/O的形式访问PCI接口芯片的配置寄存器。</p><p>PCI Base Address 2、3、4、5寄存器：系统BIOS利用这些寄存器分配PCI地址空间以支持PCI接口芯片的局部配置寄存器0、1、2、3的访问。</p><p>在所有基址寄存器中，第0位均为只读位，表示这段地址映射到存储器空间还是I/O空间，如果是“1”表示映射到I/O空间，如果是“0”则表示映射到存储器空间。</p><p>中断干线寄存器（Interrupt Line）：用于说明中断线的连接情况，这个寄存器的值与标准8259的IRQ编号（0~15）对应。</p><p>表1 PCI配置空间</p><h3 id="3-设备初始化"><a href="#3-设备初始化" class="headerlink" title="3.设备初始化"></a>3.设备初始化</h3><p>PCI 设备驱动程序要完成识别 PCI 器件、寻找 PCI 硬件的资源和对 PCI 器件中断的服务。在驱动程序初始化过程中，使用 HalGetBusData（）函数完 成寻找 PCI 设备的工作。在初始化过程中，使用器件识别号（Device ID）和厂商识别号（Vendor ID），通过遍历总线上的所有设备，寻找到指定的PCI设备，并获取设备的总线号，器件号与功能号。通过这些配置信息，可以在系统中寻址该设备的资源配置 列表。</p><p>在此之后，驱动程序需要从配置空间获取硬件的参数。PCI设备的中断号、端口地址的范围（I/O）方式、存储器的地址与映射 方式等，都可以从硬件资源列表数据结构中获取。在Windows NT中，调用HalAssignSlotResources（）函数来获得指定设备的资源列表数据结构指针，然后通过遍历该列表中的所有资源描述符，获取 该设备的I/O端口基地址与长度，中断的中断级、中断向量与模式，存储器基地址与长度等硬件资源数据。</p><p>我们设计的DMA通信采用总线主控方式进行通信，在 设备初始化时需要对DMA适配器进行初始化，使用HalGetAdapter（）获得操作系统分配的适配器对象指针。<br>示例代码如下：</p><p>// 遍历总线，获得指定设备的总线号，器件号与功能号<br>for ( busNumber = 0; busNumber &lt; MAX_PCI_BUSES; busNumber++ ) {<br>for ( deviceNumber = 0;deviceNumber &lt; PCI_MAX_DEVICES;deviceNumber++ ) {<br>slotNumber.u.bits.DeviceNumber = deviceNumber;<br>for ( functionNumber = 0; functionNumber &lt; PCI_MAX_FUNCTION; functionNumber++ ) {<br>slotNumber.u.bits.FunctionNumber = functionNumber;<br>if (!HalGetBusData(PCIConfiguration, busNumber, slotNumber.u.AsULONG,<br>&amp;pciData,sizeof(ULONG)) ) {<br>deviceNumber = PCI_MAX_DEVICES;<br>break;<br>}</p><pre><code>          if (pciData.VendorID == PCI_INVALID_VENDORID ) { 
              continue;
          }

          if ( ( VendorId != PCI_INVALID_VENDORID ) &amp;&amp; ( pciData.VendorID != VendorId || pciData.DeviceID != DeviceId )) {
              continue;
          }
          pPciDeviceLocation-&gt;BusNumber = busNumber; 
          pPciDeviceLocation-&gt;SlotNumber = slotNumber;
          pPciDeviceLocation = &amp;PciDeviceList-&gt;List[++count];
          status = STATUS_SUCCESS;
        } 
    } 
} 
// 获取设备的资源列表数据指针
status = HalAssignSlotResources(RegistryPath,
&amp;pDevExt-&gt;ClassUnicodeString,
DriverObject,
DeviceObject,
pDevExt-&gt;InterfaceType,
pDevExt-&gt;BusNumber,
pDevExt-&gt;SlotNumber,
&amp;pCmResourceList );
</code></pre><h3 id="4-I-O端口访问"><a href="#4-I-O端口访问" class="headerlink" title="4. I/O端口访问"></a>4. I/O端口访问</h3><p>在 PC机上，I/O寻址方式与内存寻址方式不同，所以处理方法也不同。I/O空间是一个64K字节的寻址空间，I/O寻址没有实模式与保护模式之分，在各种 模式下寻址方式相同。在Windows NT下，系统不允许处于Ring3级的用户程序和用户模式驱动程序直接使用I/O指令，对I/O端口进行访问，任何对I/O的操作都需要借助内核模式驱动 来完成。在访问I/O端口时，使用READ_PORT_XXX与WRITE_PORT_XXX函数来进行读写。I/O端口基地址使用从配置空间基址寄存器 PCI Base Address 1中返回的I/O端口基地址。</p><p>示例代码如下：<br>RegValue = READ_PORT_ULONG(pBaseAddr+RegOffSet);<br>WRITE_PORT_ULONG(pBaseAddr+ RegOffset, RegValue);</p><h3 id="5-设备内存访问"><a href="#5-设备内存访问" class="headerlink" title="5. 设备内存访问"></a>5. 设备内存访问</h3><p>Winsows 工作在32位保护模式下，保护模式与实模式的根本区别在于CPU寻址方式上的不同，这也是Windows驱动程序设计中需要着重解决的问题。 Windows采用了分段、分页机制，使得一个程序可以很容易地在物理内存容量不一样的、配置范围差别很大的计算机上运行，编程人员使用虚拟存储器可以写 出比任何实际配置的物理存储器都大得多的程序。每个虚拟地址由16位的段选择字和32位段偏移量组成。通过分段机制，系统由虚拟地址产生线性地址。再通过 分页机制，由线性地址产生物理地址。线性地址被分割成页目录(Page Directory)、页表(Page Table)和页偏移(Offset)三个部分。当建立一个新的Win32进程时，操作系统会为它分配一块内存，并建立它自己的页目录、页表，页目录的地 址也同时放入进程的现场信息中。当计算一个地址时，系统首先从CPU控制器CR3中读出页目录所在的地址，然后根据页目录得到页表所在的地址，再根据页表 得到实际代码／数据页的页帧，最后再根据页偏移访问特定的单元。硬件设备读写的是物理内存，但应用程序读写的是虚拟地址，所以存在着将物理内存地址映射到 用户程序线性地址的问题。</p><p>从物理内存到线性地址的转换是驱动程序需要完成的工作，可以在初始化驱动程序的进行。在已经获得设备的存 储器基地址后，首先调用HalTranslateBusAddress()函数将总线相关的内存地址转换成系统的物理地址，然后调用 MmMapIoSpace()函数将系统的物理地址映射到线性地址空间。在需要访问设备内存时，调用READ_REGISTER_XXX()与 WRITE_REGISTER_XXX ()函数来进行，基地址使用前面映射后的线性地址。在设备卸载时，调用MmUnmapIoSpace()断开设备内存与线性地址空间的映射。</p><p>示例代码如下：<br>HalTranslateBusAddress(InterfaceType,<br>BusNumber,<br>BaseAddress-&gt;RangeStart,<br>&amp;addressSpace,<br>&amp;cardAddress)</p><pre><code>BaseAddress-&gt;MappedRangeStart = MmMapIoSpace(cardAddress,
BaseAddress-&gt;RangeLength,
MmCached );
……
RegValue = READ_REGISTER_ULONG(pRegister);
WRITE_REGISTER_ULONG(pRegister, pInBuf-&gt;RegValue);
……
MmUnmapIoSpace(pBaseAddress-&gt;MappedRangeStart, pBaseAddress-&gt;RangeLength );
</code></pre><h3 id="6-中断处理"><a href="#6-中断处理" class="headerlink" title="6. 中断处理"></a>6. 中断处理</h3><p>中 断的设置、响应与调用在驱动程序中完成。设置中断应该在设备创建时完成，使用从CmResourceTypeInterrupt描述符中提取的参数，先调 用HalGetInterruptVector()将与总线有关的中断向量参数转换为系统的中断向量，然后调用IoConnectInterrupt() 指定中断服务，注册中断服务函数ISR（Interrupt Service Routine）的函数指针。</p><p>当硬件设备产生中断时，系统 会自动调用ISR函数来响应中断。ISR函数运行的中断请求级较高，主要完成对硬件设备中断的清除，不适合执行过多的代码。在传输大块数据时，需要使用延 迟过程调用（Delay Process Call，DPC）机制。例如，使用PCI设备进行DMA通信时，在ISR函数中完成对指定设备中断的判断以及清除中断，在退出ISR前，调用DPC函 数；在DPC函数中，完成DMA通信的过程，并将数据返回给用户程序。</p><p>示例代码如下：<br>DeviceExtension-&gt;InterruptLevel = partialData-&gt;u.Interrupt.Level;<br>DeviceExtension-&gt;InterruptVector = partialData-&gt;u.Interrupt.Vector;<br>DeviceExtension-&gt;InterruptAffinity = partialData-&gt;u.Interrupt.Affinity;<br>if (partialData-&gt;Flags &amp; CM_RESOURCE_INTERRUPT_LATCHED)<br>{<br>DeviceExtension-&gt;InterruptMode = Latched;<br>} else {<br>DeviceExtension-&gt;InterruptMode = LevelSensitive;<br>}<br>……<br>vector = HalGetInterruptVector(pDevExt-&gt;InterfaceType,<br>pDevExt-&gt;BusNumber,<br>pDevExt-&gt;InterruptLevel,<br>pDevExt-&gt;InterruptVector,<br>&amp;irql,<br>&amp;affinity );</p><pre><code>status = IoConnectInterrupt(&amp;pDevExt-&gt;InterruptObject,
(PKSERVICE_ROUTINE)PciDmaISR,
DeviceObject,
NULL,
vector,
irql,
irql,
pDevExt-&gt;InterruptMode,
TRUE,
affinity,
FALSE );
</code></pre><h3 id="7-DMA通信过程"><a href="#7-DMA通信过程" class="headerlink" title="7. DMA通信过程"></a>7. DMA通信过程</h3><p>DMA通信在驱动程序中实现，需要多个例程才能完成一次DMA通信。</p><p>1） DriverEntry例程<br>构造DEVICE_DESCRIPTION结构，并调用HalGetAdapter，找到与设备关联的Adapter对象，并将返回的Adapter对象的地址和映射寄存器的数目保存在设备扩展的数据结构中。</p><p>示例代码：<br>// 申请DMA的适配器对象<br>deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;<br>deviceDescription.Master = TRUE;<br>deviceDescription.ScatterGather = pDevExt-&gt;ScatterGather;<br>deviceDescription.DemandMode = FALSE;<br>deviceDescription.AutoInitialize = FALSE;<br>deviceDescription.Dma32BitAddresses = TRUE;<br>deviceDescription.BusNumber = pDevExt-&gt;BusNumber;<br>deviceDescription.InterfaceType = pDevExt-&gt;InterfaceType;<br>deviceDescription.MaximumLength = pDevExt-&gt;MaxTransferLength;<br>pDevExt-&gt;AdapterObject = HalGetAdapter(&amp;deviceDescription,<br>&amp;numberOfMapRegisters<br>);<br>……</p><p>2）Start I/O例程</p><p>该例程请求Adapter对象的拥有权，然后把其余的工作留给AdapterControl回调例程。</p><p>a) 调用KeFlushIoBuffers从CPU的Cache把数据清到物理内存，然后计算映射寄存器的数目和用户缓冲区的大小，及在第一次设备操作中传输的字节数。<br>b) 调用MmGetMdlVirtualAddress，从MDL中恢复用户缓冲区的虚地址，并存入设备扩展数据结构中。<br>c) 调用IoAllocateAdapterChannel请求Adapter对象的拥有权。如果调用成功，其余的设置工作由AdapterControl例程去做；如果失败了，则完成本次IRP包处理，开始处理下一个IRP。</p><p>3) AdapterControl例程<br>该例程完成初始化DMA控制器，并启动设备的工作。<br>a) 调用IoMapTransfer，装入Adapter对象的映射寄存器。<br>b) 向设备发送合适的命令开始传输操作。<br>c) 返回值KeepObject保留Adapter对象的拥有权。</p><p>4）中断服务（ISR）例程<br>在设备中断时，由系统调用。<br>a) 向硬件设备发出中断响应的指令。<br>b) 调用IoRequestDpc在驱动程序的DpcForIsr中继续处理该请求。<br>c) 返回TRUE，表示已经服务了本次中断。</p><p>5)DpcForIsr例程<br>由ISR在每个部分数据传输操作的结束时触发，完成当前IRP请求。<br>a) 调用IoFlushAdapterBuffers，清除Adapter对象的Cache中的任何剩余数据。<br>b) 调用IoFreeMapRegisters，释放所使用的映射寄存器。<br>c) 检查有未传完的剩余数据，如果有，则计算下次设备操作中需要传输的字节数，调用IoMapTransfer重设映射寄存器，并启动设备；如果没有剩余数据，则完成当前IRP请求，并开始下一个请求。</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/05/27/initrd/" itemprop="url">initrd</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-05-27T15:14:51+08:00" content="2016-05-27">2016-05-27 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/05/27/initrd/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/05/27/initrd/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>内存磁盘（RAM Disk)，就是把内存的一部分当成磁盘使用。作为一个临时文件系统，可以提高系统速度。而初始内存磁盘(initrd) 则在系统启动的时候提供了一个临时根文件系统，以支持内核的两步启动过程。这个内存磁盘包含了必要的可执行程序和驱动，以挂载硬盘上真正的文件系统。在桌面系统中，初始内存磁盘的寿命很短暂，仅仅是启动真正根文件系统的一个桥梁，挂载完根文件系统之后就会释放其所占内存；而在许多嵌入式系统中，不存在硬盘上的文件系统，所以 initrd 作为最终的系统一直使用。</p><h3 id="一-initrd-的意义"><a href="#一-initrd-的意义" class="headerlink" title="一. initrd 的意义"></a>一. initrd 的意义</h3><p>内核直接启动不就行了，为什么需要两步启动？</p><p>内核要挂载硬盘等存储设备，就需要这些设备的驱动程序。一种方式就是把已知硬件的驱动直接编译进内核，这在单个系统上是可行的。可以不需要 initrd 就启动系统。但是对于安装面广泛的发行版来说，就等于需要把所有有关存储的驱动都编译进内核，是无法接受的。所以就采取了安装系统后，根据检测到的硬件信 息自动生成 initrd 的方式，把需要的驱动放入，并提供加载驱动，挂载真实文件系统所需要的各个程序（常由 Busybox 提供）。</p><h3 id="二-initrd-工作原理"><a href="#二-initrd-工作原理" class="headerlink" title="二. initrd 工作原理"></a>二. initrd 工作原理</h3><p>既然内核没有驱动，读取不了硬盘，那么 initrd 又是怎么被加载的？<br>initrd 的加载，是由启动管理器 Grub 完成的。这时候的内核并未被启动，硬盘设备的初始化由 BIOS 初始化。Grub 把 initrd 和内核镜像文件载如到内存之后，就会通过 boot 命令启动内核，此时内核可能并无法识别硬盘，但是内存是没问题的，所以内核可以先挂载 initrd 这个精简系统，装入必要驱动然后挂载硬盘中的真实系统。</p><h3 id="三-initrd-的生成"><a href="#三-initrd-的生成" class="headerlink" title="三. initrd 的生成"></a>三. initrd 的生成</h3><p>大部分发行版都有 initrd 的工具，比如 mkinitrd, mkinitramfs 等。实际就是一个 Shell 脚本，可以直接利用这些脚本建立 initrd。 如果需要定制自己的 initrd ，则可以用文本编辑器打开这些程序查看并进行相应修改。</p><h3 id="四-内核通过-initrd-启动的机制"><a href="#四-内核通过-initrd-启动的机制" class="headerlink" title="四. 内核通过 initrd 启动的机制"></a>四. 内核通过 initrd 启动的机制</h3><p>内核启动的代码大都位于 init 子目录，其中 main.c 中的 init() 就是执行的入口地址。在执行了各个子系统的初始化工作之后，调用 do_mounts_initrd.c 中的 initrd_load() 函数，initrd_load 调用 rd_load_image() 将内存中的 initrd 镜像载入到内核的地址空间之中。这样就可以进行下一步的挂载。然后调用 do_mounts.c 的 mount_root() 函数将内存磁盘挂载到内核中，最终调用 fs/namespace.c 中的 sys_mount()挂载根文件系统。</p><p>根文件系统挂载完成之后，返回 init() 主程序，并调用 run_init_process() 函数，这个函数就一句话，通过 kernel_execve 调用系统初始文件比如 linuxrc ,开始应用程序的启动工作。</p><p>完整的函数调用流程：<br>init/main.c:init<br>init/do_mounts.c:prepare_namespace<br>init/do_mounts_initrd.c:initrd_load<br>init/do_mounts_rd.c:rd_load_image<br>init/do_mounts_rd.c:identify_ramdisk_image<br>init/do_mounts_rd.c:crd_load<br>lib/inflate.c:gunzip<br>init/do_mounts.c:mount_root<br>init/do_mounts.c:mount_block_root<br>init/do_mounts.c:do_mount_root<br>fs/namespace.c:sys_mount<br>init/main.c:run_init_process<br>kernel_execve</p><h3 id="五-解压查看"><a href="#五-解压查看" class="headerlink" title="五. 解压查看"></a>五. 解压查看</h3><p>以前的 initrd 是一个独立的文件系统，需要挂载到一个目录才能查看。现在的 initrd 基本都是由 cpio 生成，用如下方法查看：<br>$ gunzip -c /boot/initrd &gt; /tmp/my_initrd<br>$ mkdir ~/initrd_dir<br>$ cd ~/initd_dir<br>$ cpio -i &lt; /tmp/my_initrd参考：</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/05/27/Tao-of-programing/" itemprop="url">编程之道</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-05-27T15:13:42+08:00" content="2016-05-27">2016-05-27 </time></span><span class="post-comments-count">&nbsp; | &nbsp; <a href="/2016/05/27/Tao-of-programing/#comments" itemprop="discussionUrl"><span class="post-comments-count ds-thread-count" data-thread-key="2016/05/27/Tao-of-programing/" itemprop="commentsCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>The Silent Void</p><p>Book One</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“When you have learned to snatch the error code from the trap frame, it will be time for you to leave.”</p><p>“当你从我手中夺走水晶球时，就是你离开的时候了。”</p><p>1.1</p><p>Something mysterious is formed, born in the silent void. Waiting alone and unmoving, it is at once still and</p><p>yet in constant motion. It is the source of all programs. I do not know its name, so I will call it the Tao of</p><p>Programming.</p><p>寂静的虚空里诞生了神秘的东西，这种东西恒久存在永不消失，它是所有程序的根源所在，我不知道怎么形容它，姑且称它为编程之道。</p><p>If the Tao is great, then the operating system is great. If the operating system is great, then the compiler is</p><p>great. If the compiler is greater, then the applications is great. The user is pleased and there is harmony in</p><p>the world.</p><p>如果道是完美的，那么操作系统就是完美的，如果操作系统是完美的，那么编译嚣就是完美的，如果编译嚣是完美的，那么应用程序</p><p>就是完美的，所以用户心满意足，整个世界因此和谐。</p><p>The Tao of Programming flows far away and returns on the wind of morning.</p><p>编程之道去如黄鹤来如晨风。</p><p>1.2</p><p>The Tao gave birth to machine language. Machine language gave birth to the assembler.</p><p>道生机器语言，机器语言生汇编嚣。</p><p>The assembler gave birth to the compiler. Now there are ten thousand languages.</p><p>汇编器生编译器，最后产生上万种高级语言。</p><p>Each language has its purpose, however humble. Each language expresses the Yin and Yang of software. Each</p><p>language has its place within the Tao.</p><p>不论多么的微不足道，每种语言都有它自己的目的，每种语言都表达了软件的阴阳两极。每种语言都各得其道。</p><p>But do not program in COBOL if you can avoid it.</p><p>但是尽量不要用COBOL语言。</p><p>1.3</p><p>In the beginning was the Tao. The Tao gave birth to Space and Time. Therefore, Space and Time are the Yin and Yang of</p><p>programming.</p><p>道之初，带来了空间和时间，所以，空间和时间是编程的阴阳两极。</p><p>Programmers that do not comprehend the Tao are always running out of time and space for their programs.</p><p>Programmers thatcomprehend the Tao always have enough time and space to accomplish their goals.</p><p>不懂编程之道的程序员常常把空间和时间消耗殆尽，得道的程序员则总是有足够的空间和时间去完成编程任务。</p><p>How could it be otherwise?</p><p>否则会是什么样呢？</p><p>1.4</p><p>The wise programmer is told about the Tao and follows it. The average programmer is told about the Tao and searches for it. The foolish programmer is told about the Tao and laughs at it.</p><p>上士闻道，从而行之。中士闻道，谨而寻之。下士闻道，大笑之。</p><p>If it were not for laughter, there would be no Tao.</p><p>大笑不足为道。</p><p>The highest sounds are the hardest to hear. Going forward is a way to retreat. Greater talent shows itself late in life.</p><p>Even a perfect program still has bugs.</p><p>希音不闻，进即是退，大嚣晚成。任何程序都有漏洞。</p><hr><p>The Ancient Masters</p><p>Book Two</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“After three days without programming, life becomes meaningless.”</p><p>三日不编程，食肉无味。</p><p>2.1</p><p>The programmers of old were mysterious and profound. We cannot fathom their thoughts, so all we do is describe their appearance.</p><p>远古时代的编程大师们高深莫测，我们不能揣测他们的所思所想，只能描述外表所见。</p><p>Aware, like a fox crossing the water. Alert, like a general on the battlefield. Kind, like a hostess greeting her guests. Simple, like uncarved blocks of wood. Opaque, like black pools in darkened caves.</p><p>他达明，如狐狸过水；机警，如战场上的将军；和善，如主妇款待客人；简单，呆若木鸡；混沌，如深渊之水。</p><p>Who can tell the secrets of their hearts and minds?</p><p>谁能道尽他们的所有？</p><p>The answer exists only in the Tao.</p><p>答案仅存于道。</p><p>2.2</p><p>Grand Master Turing once dreamed that he was a machine. When he awoke he exclaimed:</p><p>超级大师图灵曾梦见自己是一台机器，醒后他这样回忆：</p><p>“I don’t know whether I am Turing dreaming that I am a machine, or a machine dreaming that I am Turing!”</p><p>“我不知道是图灵梦见自己变成机器还是机器梦见自己变成图灵。”</p><p>2.3</p><p>A programmer from a very large computer company went to a software conference and then returned to report to his manager, saying: “What sort of programmers work for other companies? They behaved badly and were unconcerned with appearances. Their hair was long and unkempt and their clothes were wrinkled and old. They crashed out hospitality suites and they made rude noises during my presentation.”</p><p>一个大公司的程序员参加一个软件会议后向他的主管汇报：“那些别的公司的程序员都是些什么样的人呀？他们举止不雅，不修边幅，头发蓬乱，衣服破旧，根本不热情好客，还在我说话的时候乱嚷嚷。”</p><p>The manager said: “I should have never sent you to the conference. Those programmers live beyond the physical world. They consider life absurd, an accidental coincidence. They come and go without knowing limitations. Without a care, they live only for their programs. Why should they bother with social conventions?”</p><p>他的主管说：“我不应该让你参加这次会议，这些程序员生活在现实世界之外。他们认为生活是可笑的，一场意外的偶然而已。他们来去自由，无所牵挂，他们只为他们的程序生活。为什么要用世俗的烦扰去扰乱他们呢？”</p><p>“They are alive within the Tao.”</p><p>“他们生活在道中”。</p><p>2.4</p><p>A novice asked the Master: “Here is a programmer that never designs, documents, or tests his programs. Yet all who know him consider him one of the best programmers in the world. Why is this?”</p><p>一个初学者问主管经理：“有一个程序员，他从来不预先设计，也不写文档，甚至不测试他的程序，但是知道他的人都认为他是世界上最伟大的程序员，为什么呢？”</p><p>The Master replies: “That programmer has mastered the Tao. He has gone beyond the need for design; he does not become angry when the system crashes, but accepts the universe without concern. He has gone beyond the need for documentation; he no longer cares if anyone else sees his code. He has gone beyond the need for testing; each of his programs are perfect within themselves, serene and elegant, their purpose self-evident. Truly, he has entered the mystery of the Tao.”</p><p>经 理说：“那个程序员掌握了道。他不需要预先进行设计；系统崩溃时他也从不烦燥，只是接受发生的一切而不管发生的事是好是坏 。他不需要写文档，他从不顾及有没有人看他写的代码。他也不需要进行测试；他写的每个程序都有一个完美的自我，平静而优雅，它们的目的不言自明。他已经真 正掌握了道的精髓。”</p><hr><p>Design</p><p>Book Three</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“When program is being tested, it is too late to make design changes.”</p><p>“程序被测试时再去改变它的设计已经太晚了。”</p><p>3.1</p><p>There once was a man who went to a computer trade show. Each day as he entered, the man told the guard at the door:</p><p>曾经有一个人参加计算机展览，每天他进门时都对门卫说：</p><p>“I am a great thief, renowned for my feats of shoplifting. Be forewarned, for this trade show shall not escape unplundered.”</p><p>“先警告你，我是偷盗高手，我入室偷盗的本领闻名遐迩。这次展览会也再劫难逃。”</p><p>This speech disturbed the guard greatly, because there were millions of dollars of computer equipment inside, so he watched the man carefully. But the man merely wandered from booth to booth, humming quietly to himself.</p><p>警卫因此大动干戈，因为里面有价值百万的计算机设备，所以他牢牢盯紧了这个人，但是这个人只是从一个摊位逛到另一个摊位，一边平静地喃喃自语。</p><p>When the man left, the guard took him aside and searched his clothes, but nothing was to be found.</p><p>当这个人离开时，警卫搜了他的身，但是什么也没有发现。</p><p>On the next day of the trade show, the man returned and chided the guard saying: “I escaped with a vast booty yesterday, but today will be even better.” So the guard watched him ever more closely, but to no avail.</p><p>展览会的第二天，这个人又对警卫说：“昨天我满载而归，但是今天我会收获更大。”所以警卫更加小心地盯紧他，但是这样做完全于事无补。</p><p>On the final day of the trade show, the guard could restrain his curiosity no longer. “Sir Thief,” he said, “I am so perplexed, I cannot live in peace. Please enlighten me. What is it that you are stealing?”</p><p>展览会的最后一天，警卫再也不能忍住他的好奇心了。“小偷先生，”他说，“ 你说我惊慌不安，请告诉我，你到底偷了什么？”。</p><p>The man smiled. “I am stealing ideas,” he said.</p><p>这个人笑笑说：“我在偷想法。”</p><p>3.2</p><p>There once was a master programmer who wrote unstructured programs. A novice programmer, seeking to imitate him, also began to write unstructured programs. When the novice asked the master to evaluate his progress, the master criticized him for writing unstructured programs, saying: “What is appropriate for the master is not appropriate for the novice. You must understand the Tao before transcending structure.”</p><p>有一位编程大师，他写非结构化的程序，一位初学者刻意模仿他，也写非结构化的程序。当他让大师看他的进步时，大师批评了他的非结构化程序：“ 对一位编程大师合适的东西未必对一个初学者同样合适，在超越结构化之前，你必须理解编程之道。”</p><p>3.3</p><p>There was once a programmer who was attached to the court of the warlord of Wu. The warlord asked the programmer: “Which is easier to design: an accounting package or an operating system?”</p><p>###有人问一位程序员，“一个财务软件和一个操作系统哪个更容易设计？”</p><p>“An operating system,” replied the programmer.</p><p>“是操作系统”，这位程序员回答说。</p><p>The warlord uttered an exclamation of disbelief. “Surely an accounting package is trivial next to the complexity of an operating system,” he said.</p><p>此人大惑不解。他说：“显然一个财务软件比起操作系统来说其复杂性是微不足道的”。</p><p>“Not so,” said the programmer, “when designing an accounting package, the programmer operates as a mediator between people having different ideas: how it must operate, how its reports must appear, and how it must conform to the tax laws. By contrast, an operating system is not limited my outside appearances. When designing an operating system, the programmer seeks the simplest harmony between machine and ideas. This is why an operating system is easier to design.”</p><p>程 序员说：“不，设计财务软件时，一个程序员 必须成为持不同意见的用户与计算机的一个中介，他必须了解用户的操作习惯，报表要是什么形式，如何遵循税法。相反，一个操作系统完全与这些外部的东西无 关。设计操作系统，程序员只需要达到自己的设想与机器之间的简单的和谐。这就是为什么操作系统反而比财务软件更容易设计。”</p><p>The warlord of Wu nodded and smiled. “That is all good and well, but which is easier to debug?”</p><p>这些人笑着说。“不错，但是哪一个更容易调试呢？”</p><p>The programmer made no reply.</p><p>程序员没有回答。</p><p>3.4</p><p>A manager went to the master programmer and showed him the requirements document for a new application. The manager asked the master: “How long will it take to design this system if I assign five programmers to it?”</p><p>一个项目经理带给编程大师一个项目的需求，然后问大师：“如果我给你5个程序员，要多少时间设计这个项目？”</p><p>“It will take one year,” said the master promptly.</p><p>“一年”，大师说。</p><p>“But we need this system immediately or even sooner! How long will it take it I assign ten programmers to it?”</p><p>“但是我们等不了那么长时间，越快越好，如果10个程序员呢？”</p><p>The master programmer frowned. “In that case, it will take two years.”</p><p>大师皱了一下眉头说：“那就要花2年”。</p><p>“And what if I assign a hundred programmers to it?”</p><p>“那，100个程序员呢？”</p><p>The master programmer shrugged. “Then the design will never be completed,” he said.</p><p>大师耸了耸肩说：“那这个项目就永远完不成了。”</p><hr><p>Coding</p><p>Book Four</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“A well-written program is its own heaven;</p><p>a poorly-written program is its own hell.”</p><p>“写的好的程序是它自己的天堂，写的不好的程序是它自己的地狱”</p><p>4.1</p><p>A program should be light and agile, its subroutines connected like a strings of pearls. The spirit and intent of the program should be retained throughout. There should be neither too little nor too much, neither needless loops nor useless variables, neither lack of structure nor overwhelming rigidity.</p><p>一个程序应该是轻灵自由的，它的子过程就象串在一根线上的珍珠。自始至终，目标明确。增之一字节则太长，减之一字节则太短。既没有不必要的循环也没有没有被引用的变量，既不缺少结构化也不至于僵硬呆板。</p><p>A program should follow the Law of Least Astonishment. What is this law? It is simply that the program should always respond to the user in the way that astonishes him least.</p><p>一个程序应该遵循”最小惊讶原则’’，什么是”最小惊讶原则’’？就是说一个程序应该最小程度地引起用户的惊讶。</p><p>A program, no matter how complex, should act as a single unit. The program should be directed by the logic within rather than by outward appearances.</p><p>无论一个程序无论有多么复杂都应该是一个单一的整体。程序是被它的内部逻辑所指引而不是它的外观表现。</p><p>If the program fails in these requirements, it will be in a state of disorder and confusion. The only way to correct this is to rewrite the program.</p><p>如果一个程序不能满足所要的需求，它就会处于混乱无序的状态中。唯一的出路就是重写这个程序。</p><p>4.2</p><p>A novice asked the master: “I have a program that sometimes runs and sometimes aborts. I have followed the rules of programming, yet I am totally baffled. What is the reason for this?”</p><p>一个初学者问大师：“我的一个程序有时正常有时不正常。我已经完全遵循编程的规则，而且我完全被它弄糊涂了，到底是什么原因会导致这样呢？”</p><p>The master replied: “You are confused because you do not understand the Tao. Only a fool expects rational behavior from his fellow humans. Why do you expect it from a machine that humans have constructed? Computers simulate determinism; only the Tao is perfect.</p><p>大师说：“你困惑是因为你不了解道。只有傻瓜才会相信只要遵循别人所说就能得到想当然的结果。为什么你要从一个人类自己构造的机器中去得到想当然的结果呢？计算机只是决定论的产物；只有道才是唯一完美的。</p><p>The rules of programming are transitory; only the Tao is eternal. Therefore you must contemplate the Tao before you receive enlightenment.</p><p>任何编程的规则都只适合于特定的情况，只有道才是永恒不变的。所以在你受到指引之前要先去思考道。</p><p>“But how will I know when I have received enlightenment?” asked the novice.</p><p>“但是我怎么知道我何时受到指引呢？”</p><p>“Your program will then run correctly,” replied the master.</p><p>“当你的程序正确运行时”。大师说。</p><p>4.3</p><p>A master was explaining the nature of the Tao to one of his novices, “The Tao is embodied in all software – regardless of how insignificant,” said the master.</p><p>初学者请大师解释“道法自然”。大师说：“道存在于任何软件中－－无论是多么没有意义的软件”。</p><p>“Is the Tao in a hand-held calculator?” asked the novice.</p><p>“难道也存在于手持式的计算嚣里？”，初学者问。</p><p>“It is,” came the reply.</p><p>“是的，”</p><p>“Is the Tao in a video game?” continued the novice.</p><p>“也在游戏机里？”，初学者又问到。</p><p>“It is even in a video game,” said the master.</p><p>“是的，甚至也存在于游戏机里”。大师说。</p><p>“And is the Tao in the DOS for a personal computer?”</p><p>“也存在于个人计算机的DOS里吗？”</p><p>The master coughed and shifted his position slightly. “The lesson is over for today,” he said.</p><p>大师咳嗽了一声，稍微动了一下，说，“今天的课就到这里”。</p><p>4.4</p><p>Price Wang’s programmer was coding software. His fingers danced upon the keyboard. The program compiled without an error message, and the program ran like a gentle wind.</p><p>###编程大师编写软件时，手指在键盘上快速飞舞。程序编译时没有一条错误信息，程序运行起来就象一阵微风吹过。</p><p>Excellent!” the Price exclaimed, “Your technique is faultless!”</p><p>太精彩了！你的技巧已经无可挑剔了。</p><p>“Technique?” said the programmer, turning from his terminal, “What I follow is the Tao – beyond all technique. When I first began to program I would see before me the whole program in one mass. After three years I no longer saw this mass. Instead, I used subroutines. But now I see nothing. My whole being exists in a formless void. My senses are idle. My spirit, free to work without a plan, follows its own instinct. In short, my program writes itself. True, sometimes there are difficult problems. I see them coming, I slow down, I watch silently. Then I change a single line of code and the difficulties vanish like puffs of idle smoke. I then compile the program. I sit still and let the joy of the work fill my being. I close my eyes for a moment and then log off.”</p><p>“技巧？”，大师转过身说，“我所遵循的是道–它 超乎所有的技巧。当我开始编程时我看到的是整个一大块的程序，三年后我看到的是子过程。现在我什么也看不到了。我的整个存在是没有任何形式的虚无。我感觉 很悠闲，总之，事实上是我的程序自己在写，有时我看到一些问题，我看到它们，就停下来静静地观察它们，然后我改变了一行代码，难题就象一阵轻烟一样化为乌 有。然后我编译程序。坐在那里享受工作的喜悦。闭了一会眼睛然后退出系统。</p><p>Price Wang said, “Would that all of my programmers were as wise!”</p><p>“什么时候我的程序员才能都达到这样的境界!”</p><p>Mainteance</p><p>Book Five</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“Though a program be but three lines long, someday it will have to be maintained.”</p><p>“既使一个程序只有三行长，也总有一天需要去维护它”</p><p>5.1</p><p>A well-used door needs no oil on its hinges.</p><p>A swift-flowing steam does no grow stagnant.</p><p>Neither sound nor thoughts can travel through a vacuum.</p><p>Software rots if not used.</p><p>经常使用的门不需要往门轴里上油。</p><p>流动的东西就不会停滞不前。</p><p>流水不腐，户枢不蠹。–王磊</p><p>声音和思想都不能在真空里传播。</p><p>软件不用就会腐朽。</p><p>These are great mysteries.</p><p>5.2</p><p>A manager asked a programmer how long it would take him to finish the program on which he was working. “I will be finished tomorrow,” the programmer promptly replied.</p><p>经理问程序员要多长时间才能完成他的项目。“明天”</p><p>“I think you are being unrealistic,” said the manager. “Truthfully, how long will it take?”</p><p>“太不着边际了，老实说，要多久？”</p><p>The programmer thought for a moment. “I have some features that I wish to add. This will take at least two weeks,” he finally said.</p><p>程序员想了一想说。“还有一些新的功能要加进去，可能至少要两个星期吧。”</p><p>“Even that is too much to expect,” insisted the manager, “I will be satisfied if you simply tell me when the program is complete.”</p><p>“即使两个星期恐怕也太夸张了，什么时候你只要告诉我说程序已经完成就好了。”</p><p>The programmer agreed to this.</p><p>Several years slated, the manager retired. On the way to his retirement lunch, he discovered the programmer asleep at his terminal. He had been programming all night.</p><p>几年后，这个经理已经退休了，在他的离职午餐上，他发现这些程序员在他的终端前睡着了，他整夜都在编程。</p><p>5.3</p><p>A novice programmer was once assigned to code a simple financial package.</p><p>一个初学者被要求编写一个财务软件。</p><p>The novice worked furiously for many days, but when his master reviewed his program, he discovered that it contained a screen editor, a set of generalized graphics routines, and artificial intelligence interface, but not the slightest mention of anything financial.</p><p>他疯狂地工作了很多天，但他的主管检视他的程序时发现，它写了一个编辑嚣，一个图形程序集，和人工智能的界面，但是看不到任何跟财务有关的东西。</p><p>When the master asked about this, the novice became indignant. “Don’t be so impatient,” he said, “I’ll put the financial stuff in eventually.”</p><p>主管要求解释时，程序员被激怒了：“你太没耐心了，我会在最后写财务的部分。”</p><p>5.4</p><p>Does a good farmer neglect a crop he has planted?</p><p>Does a good teacher overlook even the most humble student?</p><p>Does a good father allow a single child to starve?</p><p>Does a good programmer refuse to maintain his code?</p><p>一个好的农民不会不管他的庄稼。</p><p>一个好的老师不会不管哪怕是最差的学生。</p><p>一个好的父亲不会让他的任何一个孩子挨饿。</p><p>一个好的程序员不应拒绝维护他的程序。</p><hr><p>Management</p><p>Book Six</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“Let the programmer be many and the managers few – then all will be productive.”</p><p>“增加程序员，减少经理–这样他们都可提高效率。”</p><p>6.1</p><p>When managers hold endless meetings, the programmers write games. When accountants talk of quarterly profits, the development budget is about to be cut. When senior scientists talk blue sky, the clouds are about to roll in.</p><p>经理们忙于无休无止的会议时，程序员们在写游戏。财务主管在谈论季度盈利时开发预算将会被削减。当老科学家在谈天空的蓝色时，云团蜂拥而至。</p><p>Truly, this is not the Tao of Programming.</p><p>这不是编程之道。</p><p>When managers make commitments, game programs are ignored. When accountants make long-range plans, harmony and order are about to be restored. When senior scientists address the problems at hand, the problems will soon be solved.</p><p>经理分配任务时不会包括游戏，会计师做长期计划时，应该做到面面俱到，皆大欢喜。科学家提出一个问题，就会很快得到解决。</p><p>Truly, this is the Tao of Programming.</p><p>这才是编程之道。</p><p>6.2</p><p>Why are programmers non-productive? Because their time is wasted in meetings.</p><p>为什么程序员没有效率，因为他们把时间都浪费在开会上了。</p><p>Why are programmers rebellious? Because the management interferes too much.</p><p>为什么程序员难于管理？因为管理者的干预太多了。</p><p>Why are the programmers resigning one by one? Because they are burnt out.</p><p>为什么程序员一个接一个地辞职，因为他们累坏了。</p><p>Having worked for poor management, they no longer value their jobs.</p><p>在糟糕的管理下工作，他们享受不到工作的乐趣。</p><p>6.3</p><p>A manager was about to be fired, but a programmer who worked for him invented a new program that became popular and sold well. As a result, the manager retained his job.</p><p>一个经理将被解雇，但他手下的一个程序员写了一个流行的软件并且销路很旺。所以经理保住了他的工作。</p><p>The manager tried to give the programmer a bonus, but the programmer refused it, saying, “I wrote the program because I though it was an interesting concept, and thus I expect no reward.”</p><p>经理为程序员分红，但程序员拒绝了，他说：“我写程序是因为写程序很有趣，所以我并没想过得资金”。</p><p>The manager, upon hearing this, remarked, “This programmer, though he holds a position of small esteem, understands well the proper duty of an employee. Lets promote him to the exalted position of management consultant!”</p><p>这位经理说，“这位程序员，不管他现在是什么位置，他都能理解一个雇员的职责所在。我们要把他提升为管理顾问”。</p><p>But when told this, the programmer once more refused, saying, “I exist so that I can program. If I were promoted, I would do nothing but waste everyone’s time. Can I go now? I have a program that I’m working one.”</p><p>这位程序员又一次拒绝了，他说：“我是一个程序员所以我可以编程，如果我被提升了，除了浪费别人的时间什么也做不了，现在我可以走了吗？我还有一个程序没写完。”</p><p>6.4</p><p>A manger went to his programmers and told them: “As regards to your work hours: you are going to have to come in at nine in the morning and leave at five in the afternoon.” At this, all of them became angry and several resigned on the spot.</p><p>经理对程序员说，“你们的工作时间是早上9点到正午点。”，所有的程序员都很不满。</p><p>So the manager said: “All right, in that case you may set your own working hours, as long as you finish your projects on schedule.” The programmers, now satisfied, began to come in a noon and work to the wee hours of the morning.</p><p>经理又说：“好吧，那随你们的便，只要能按时完成任务。”，程序员们这下满意了，他们中午上班，一直工作到凌晨。</p><hr><p>Corporate Wisdom</p><p>Book Seven</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“You can demonstrate a program for a corporate executive, but you can’t make him computer literate.”</p><p>###</p><p>“你可以向一位公司主管演示一套程序，但你不能让他的电脑变得象人一样。”</p><p>7.1</p><p>A novice asked the master: “In the east there is a great tree-structure that men call ‘Corporate Headquarters’. It is bloated out of shape with vice-presidents and accountants. It issues a multitude of memos, each saying ‘Go, Hence!’ or ‘Go, Hither!’ and nobody knows what is meant. Every year new names are put onto the branches, but all to no avail. How can such an unnatural entity exist?”</p><p>一 个新学问大师：“在东方，有一个庞大的机 构，人们称作总部。它由为数众多的大小领导。每天发出大量的备忘录，每个备忘录都说：‘干这个，干那个’，没有一个人知道它是什么意思。每年这个机构都会 有更多的人加进来而变得越来越大，但是去没有人去做事情。怎么烩样奇怪的东西还能存在呢？”</p><p>The master replies: “You perceive this immense structure and are disturbed that it has no rational purpose. Can you not take amusement from its endless gyrations? Do you not enjoy the untroubled ease of programming beneath its sheltering branches? Why are you bothered by its uselessness?”</p><p>大师说：“你已经知道这个巨大的机构并不合理，你就不能不管它为什么这样吗？你尽管享受它的好处就是了，干吗要去管它到底是没有效率呢？”</p><p>7.2</p><p>In the east there is a shark which is larger than all other fish. It changes into a bird whose winds are like clouds filling the sky. When this bird moves across the land, it brings a message from Corporate Headquarters. This message it drops into the midst of the program- mers, like a seagull making its mark upon the beach. Then the bird mounts on the wind and, with the blue sky at its back, returns home.</p><p>在遥远的东方，传说有一只巨大的鱼，叫鲲，它变成了一只大鸟，叫鹏，鹏的翅膀可以遮天蔽日，这只大鸟经过陆地的时候，它带来了一个消息，它把这个消息丢在程序员中，就象一只海鸥在海滩上做的记号，然后鹏背负蓝天，乘风而上，回家去了。</p><p>The novice programmer stares in wonder at the bird, for he understands it not. The average programmer dreads the coming of the bird, for he fears its message. The master programmer continues to work at his terminal, for he does not know that the bird has come and gone.</p><p>初学者惊恐地看着这只鸟，根本不敢相信，中级程序员担心这只鸟的到来，因为它害怕它带来的消息，编程大师则继续在他的终端前工作他根本不知道这只鸟曾经来过。</p><p>7.3</p><p>The Magician of the Ivory Tower brought his latest invention for the master programmer to examine. The magician wheeled a large black box into the master’s office while the master waited in silence.</p><p>一个学究带着他的最新发明去见编程大师，他把一个大黑盒子推进大师的办公室。</p><p>“This is an integrated, distributed, general-purpose workstation,” began the magician, “ergonomically designed with a proprietary operating system, sixth generation languages, and multiple state of the art user interfaces. It took my assistants several hundred man years to construct. Is it not amazing?”</p><p>“这是综合的、分布式的通用工作站，”，学究开始介绍了，“按人体工学设计的</p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Feng Chao"><p class="site-author-name" itemprop="name">Feng Chao</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">107</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">5</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/fengchao" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="https://twitter.com/fengchao" target="_blank" title="Twitter"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2008 - <span itemprop="copyrightYear">2016</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Feng Chao</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/javascript">var duoshuoQuery={short_name:"chaosite"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.id="duoshuo-script",t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script><script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script><script src="/js/src/hook-duoshuo.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js"></script></body></html><!-- rebuild by neat -->