<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[商业模式]]></title>
      <url>http://fengchao.github.io/2016/12/09/Business-mode/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><h2 id="商业模式的常见问题"><a href="#商业模式的常见问题" class="headerlink" title="商业模式的常见问题"></a>商业模式的常见问题</h2><ol><li>把企业愿景当作商业模式</li><li>平台类产品未认准自己的用户</li><li>简单的罗列自己的资源</li><li>追求大而全</li><li>缺乏可爆发性</li></ol><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[蓝海战略]]></title>
      <url>http://fengchao.github.io/2016/12/07/Blue-Ocean-Strategy/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><h2 id="确立"><a href="#确立" class="headerlink" title="确立"></a>确立</h2><ul><li>重新确立市场边界</li><li>关注整体状况，而不是数字</li><li>超出现有需求</li><li>确保顺序正确</li></ul><h2 id="执行原则"><a href="#执行原则" class="headerlink" title="执行原则"></a>执行原则</h2><ul><li>解决组织限制</li><li>将执行加入战略</li></ul><h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><ul><li>计划的风险</li><li>增长的风险</li><li>商业模式的风险</li><li>组织风险</li><li>管理风险</li></ul><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[npm]]></title>
      <url>http://fengchao.github.io/2016/11/25/npm/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h2><a href="#" class="headerlink" title="^ ~"></a>^ ~</h2><p>Major. Minor.Bugfix</p><ul><li>^: 仅更新不涉及 API 变更的 Minor 版本</li><li>~: 仅更新问题修复版本</li></ul><pre><code>$npm update 
</code></pre><h2 id="latest"><a href="#latest" class="headerlink" title="@latest"></a>@latest</h2><p>查找有更新版本的软件包</p><pre><code>$ npm outdated
</code></pre><p>更新软件包</p><pre><code>$ npm install packagename@latest --save
</code></pre><p>处理不兼容的 API 调用</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[时间管理，提升效率]]></title>
      <url>http://fengchao.github.io/2016/11/15/Time-management/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>Work = Time * Speed</p><p>时间是固定的，所以要收获更多，需要提高速度/效率.</p><h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><p>清楚自己到底要的是什么。集中经历做最重要的事情，避免在无关紧要的事情上浪费时间。</p><h2 id="减少打断"><a href="#减少打断" class="headerlink" title="减少打断"></a>减少打断</h2><p>大脑在每次任务切换后，都需要一些爬坡时间才能恢复到之前的效率。减少碎片化任务，避免被外部事情打断，就可以一直保持高效率。</p><h2 id="高效人士的七个习惯"><a href="#高效人士的七个习惯" class="headerlink" title="高效人士的七个习惯"></a>高效人士的七个习惯</h2><ul><li>Act Proactive: They take time to formulate their responses to situations<br>they find themselves in rather than simply making knee-jerk reactions to<br>them.</li><li>Begin with the End in Mind: They visualize the desired results and then<br>take the steps necessary to achieve them.</li><li>Put First Things First: As the masters of time management and<br>organization, they successfully prioritize their tasks to reach their goals.</li><li>Think Win/Win: They seek accords and results that are mutually satisfying<br>to everyone involved rather than simply seeking to triumph at any cost.</li><li>Seek First to Understand, and Then Be Understood: They practice<br>“empathic listening” whereby they listen to others with the intention of<br>understanding what others are saying, rather than preparing a reply to it.</li><li>Synergize: They practice creative cooperation whereby they remain<br>open to new possibilities, alternatives, and options.</li><li>Sharpen the Saw: They practice principles of balanced self-renewal that<br>enable them to reenergize themselves physically, mentally, socially, and<br>spiritually.</li></ul><h2 id="Getting-Things-Done"><a href="#Getting-Things-Done" class="headerlink" title="Getting Things Done"></a>Getting Things Done</h2><ul><li>Collect: This stage involves using your own preferred tools to accumulate<br>all of the stuff in your professional and personal lives that you consider<br>incomplete or requiring some sort of change.</li><li>Process: This stage involves determining the relative importance of<br>all the stuff you identify as incomplete and deciding what steps are<br>required to make them complete.</li><li>Organize: This stage involves deciding where to store all the stuff that<br>you determine still needs completing.</li><li>Review: This stage involves routinely reviewing (Allen usually recommends<br>on a weekly basis) all the stuff that you still identify as incomplete.</li><li>Do: This stage involves deciding whether or not the stuff you see as<br>incomplete is worth taking up now or at some later time.</li></ul><h2 id="记录待完成事项"><a href="#记录待完成事项" class="headerlink" title="记录待完成事项"></a>记录待完成事项</h2><p>将待完成事项记录下来，而不是脑子里，可以减少心理压力。清理列表，清理收件箱：</p><ul><li>Do It: You perform the action if you estimate that you can complete it<br>within two minutes or less (Allen’s two-minute rule).</li><li>Delegate It: You send it to someone else on the team if you determine<br>that you’re not the best person to undertake the action.</li><li>Defer It: You place it in a Someday or Snooze file if you determine that<br>you need more information to do it or it will take longer than a couple of<br>minutes.</li><li>Delete it: If you read a message (or its preview lines, if you view your<br>e-mail messages using Messages with AutoPreview as your current Mail<br>view) and find that it clearly falls into the junk category, move it into<br>your Deleted Items folder by pressing the Delete key.</li></ul><h2 id="专注于现在能够做的事情"><a href="#专注于现在能够做的事情" class="headerlink" title="专注于现在能够做的事情"></a>专注于现在能够做的事情</h2><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scrapy - python spider]]></title>
      <url>http://fengchao.github.io/2016/09/08/Scrapy-python-spider/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><a href="https://scrapy.org/" target="_blank" rel="external">Scrapy</a> 是一个 python 下面功能丰富、使用快捷方便的爬虫框架。</p><pre><code>    $ pip install scrapy

     $ cat &gt; myspider.py &lt;&lt;EOF
    import scrapy

    class BlogSpider(scrapy.Spider):
        name = &apos;blogspider&apos;
        start_urls = [&apos;https://blog.scrapinghub.com&apos;]

        def parse(self, response):
            for url in response.css(&apos;ul li a::attr(&quot;href&quot;)&apos;).re(&apos;.*/category/.*&apos;):
                yield scrapy.Request(response.urljoin(url), self.parse_titles)

        def parse_titles(self, response):
            for post_title in response.css(&apos;div.entries &gt; ul &gt; li a::text&apos;).extract():
                yield {&apos;title&apos;: post_title}
 EOF

$ scrapy runspider myspider.py
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程-中断-效率]]></title>
      <url>http://fengchao.github.io/2016/07/22/Mutithread-efficency/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>没有学过编程的人，也有多线程的经历: 一边走路，一边想事情；一边听音乐，一边学习。在计算机里面，多线程是为了提高效率。但是人类的大脑不是计算机，并不擅长多任务的同时处理。</p><p>每次中断一个任务，进入另外一个任务的时候，大脑都会经历一个转换过程。可能需要十分钟以上的时间，效率才能达到最高。所以每次中断，每次任务切换，都是效率杀手。从进化心理学上讲，古代人为了求生，必须把注意力集中，时刻应对外界威胁。如果注意力频繁切换，会有外界危险增多的暗示，增加心理压力。</p><p>解决方法：</p><ul><li>尽量保留不被任何事情打断的时间，高效率的处理重要问题.</li><li>多使用邮件等异步通信方式，减少手机、即时通信的使用。</li><li>关闭邮件通知，消息通知，微信通知，在集中的时间处理。使用 Pull，而不是中断。</li></ul><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[斯托克代尔悖论]]></title>
      <url>http://fengchao.github.io/2016/07/13/The-Stockdale-Paradox/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>斯托克代尔是美国的一个海军上将，在越南战争期间，是被俘的美军里级别最高的将领。但他没有得到越南的丝毫优待，被拷打了20多次，关押了长达8年。他说：“我不知道自己能不能活着出去，还能不能见到自己的妻子和小孩。”但是他在监狱中表现得很坚强。越南人有一次为了表现他们优待俘虏，把他养了一段时间，准备给他拍照。结果斯托克代尔就自己用铁条把自己打得遍体鳞伤，并用刀片把自己的脸割破。越南人拿他没办法，只好放弃了。</p><p>他为了鼓励监狱中的同胞，因为是一个人关一间，彼此看不到，就发明了一种密码，通过敲墙用快慢节奏来表达英文字母。有次一位战俘因思念家人掩面痛哭的时候，他们全监狱的战俘都通过敲墙，用代码敲出了“我爱你”，那个战俘非常感动。</p><p>斯托克代尔被关押8年后放了出来。吉姆·柯林斯先生去采访他，问：“你为什么能熬过这艰难的8年？”斯托克代尔说：“因为我有一个信念，相信自己一定能出来，一定能够再见到我的妻子和孩子，这个信念一直支撑着我，使我生存了下来。”吉姆·柯林斯又问：“那你的同伴中最快死去的又是哪些人呢？”他回答说：“是那些太乐观的人。”吉姆·柯林斯说这不是很矛盾吗？为什么那些乐观的人会死得很快呢？斯托克代尔说：“他们总想着圣诞节可以被放出去了吧？圣诞节没被放出去；就想复活节可以被放出去，复活节没被放出去；就想着感恩节，而后又是圣诞节，结果一个失望接着一个失望，他们逐渐丧失了信心，再加上生存环境的恶劣，于是，他们郁郁而终。”斯托克代尔说：“对长远我有一个很强的信念，相信自己一定能够活着出去，一定能再见到我的妻子和小孩；但是我又正视现实的残酷。”</p><p>吉姆·柯林斯说：斯托克代尔悖论是持续50年能保持在世界500强的企业全部采用的理论。它们之所以能常青50年，是因为他们对前景充满乐观，相信前途一定是光明的，但是又直面现实的残酷。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dvorak 键盘]]></title>
      <url>http://fengchao.github.io/2016/07/12/Dvorak/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><h2 id="QWERT-键盘"><a href="#QWERT-键盘" class="headerlink" title="QWERT 键盘"></a>QWERT 键盘</h2><p>最初，打字机的键盘是按照字母顺序排列的，但如果打字速度过快，某些键的组合很容易出现卡键问题，于是克里斯托夫·拉森·寿司（Christopher Latham Sholes）发明了 QWERTY 键盘布局，他将最常用的几个字母安置在相反方向，最大限度放慢敲键速度以避免卡键。寿司在1868年申请专利，1873 年使用此布局的第一台商用打字机成功投放市场。这就是为什么有今天键盘的排列方式。</p><p>但具有讽刺意味的是，这种129年前形成的、以放慢敲键速度为目的的键盘排列方式却延续至今。1986年布鲁斯·伯里文爵士曾在《奇妙的书写机器》一文中表示：“QWERTY的安排方式非常没效率。”比如：大多数打字员惯用右手，但使用QWERTY，左手却负担了57%的工作。两小指及左无名指是最没力 气的指头，却频频要使用它们。排在中列的字母，其使用率仅占整个打字工作的30%左右，因此，为了打一个字，时常要上上下下移动指头。</p><h2 id="Dvorak-键盘"><a href="#Dvorak-键盘" class="headerlink" title="Dvorak 键盘"></a>Dvorak 键盘</h2><p>Dvorak键盘是August Dvorak (1894 - 1975) 在二十世纪三十年代发明的一种异于QWERTY的键盘布局。关于这种键盘布局的普通知识，请参阅<a href="http://www.mwbrooks.com/dvorak。" target="_blank" rel="external">http://www.mwbrooks.com/dvorak。</a> 而Dvorak键盘是长成这样的：</p><p><img src="/images/Dvorak.jpg" alt="Dvorak"></p><h2 id="使用-Dvorak"><a href="#使用-Dvorak" class="headerlink" title="使用 Dvorak"></a>使用 Dvorak</h2><p>作为一个完美主义者，了解了一般键盘的反人类设计，是没有办法抵制 Dvorak 的诱惑的。从 2010 年 3 月开始切换的 Dvorak，熟悉一段时间之后，已经可以完全用 Dvorak 工作了。</p><ul><li><p>Linux 下使用 Dvorak 参考 <a href="https://wiki.archlinux.org/index.php/Dvorak" target="_blank" rel="external">Arch Wiki</a></p></li><li><p>Windows 下使用 Dvorak布局，修改注册表</p></li></ul><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000804</p><p>将layout file改为 <strong>kbddv.dll</strong> 即可.这样中文输入法也是 Dvorak 了.</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[破釜沉舟学习法]]></title>
      <url>http://fengchao.github.io/2016/07/06/Destory-books/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>很多人应该都有这样的经验：一本书，如果是买的，很可能仍在那里落灰；而如果是借的，因为有归还的压力会很快的读完。没有退路的时候，不光能让战士一往直前，还能让大脑更专注于记忆。</p><p>为了利用这个压力，一般我看书的时候会要求能完全了解页面的内容，不需要再回头看一遍。大学学英语的时候，看完一页书之后，会撕掉。书越看越薄，知识才真正到脑子里面。</p><p>从心理学上将，学了多少知识，是很难量化测量的。但是读了多少页书，撕了多少页书，却是可以量化的。通过这个量化，能够明确看到进展，学习的时候，就意识到事情正在朝向完成不断迈进，这种正面趋势所带来的积极情感能够进一步激励个体把事情执行到底。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[攻克 Linux]]></title>
      <url>http://fengchao.github.io/2016/07/06/Learn-linux-the-hard-way/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><a href="http://fengchao.github.io/2016/07/05/Archive-what-you-think/">上一篇文章</a>提到当克服一个困难的事情之后，剩下的事情就简单了。学习 Linux 也是如此，通过安装 Arch，Gentoo，Linux from scratch，会对整个 Linux 系统有更深刻的理解。</p><h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><ul><li><a href="https://www.archlinux.org/" target="_blank" rel="external">主页</a></li><li><a href="https://wiki.archlinux.org/index.php/Installation_guide" target="_blank" rel="external">安装指南</a></li></ul><h1 id="Gentoo"><a href="#Gentoo" class="headerlink" title="Gentoo"></a>Gentoo</h1><p>Gentoo 和 Linux From Scratch 简直是绝配。从某种意义上说，Gentoo 安装的 Stage3，就是 Linux From Scratch 前面准备的编译环境。Linux From Scratch 提供了最基本的系统，而 Gentoo 则是用一种优雅的方式管理软件包的下载、自动补丁和依赖关系解决。和 Ubuntu 不同，Gentoo 提供了最大的灵活性，用户可以按照自己的喜好进行选择而不是简单的提供默认选项。用 Gentoo 一年多了，系统基本没有出过什么问题，滚动升级，不但可以使用最新的软件，而且降低了一次升级许多软件包而产生的危险。即时出了问题，也更容易缩小范围，发现问题的所在。但是 Gentoo 也不是没有问题，编译安装需要不少时间，在以前我在台式机中用 xfce 最小安装，还算可以接受。现在换了笔记本，一直那么高负荷编译，发热大，硬盘也会吃不消。所以有了换 Arch 的打算。</p><h1 id="Linux-from-scratch"><a href="#Linux-from-scratch" class="headerlink" title="Linux from scratch"></a>Linux from scratch</h1><p>也许 LFS 不应该被成为一个发行版，因为基本上它只是一个供人学习的工具，通过从 0 开始一步一步安装系统需要的程序。我对这个系统的使用，仅限于从头到尾安装了两次，而装完之后就立即删掉了。但是通过 Linux From Scratch,我对操作系统的认识产生了质的飞跃。在之前，光操作系统这个词都能把我镇住。而从头装卸了一次之后，突然间豁然开朗，操作系统整个的解体了，“提刀而立，为之四顾，为之踌躇满志，善刀而藏之”。所以向每个希望了解操作系统的人推荐这个系统。安装下来，可能需要花费两三天的时间，但是学到的东西，比用 Ubuntu 两三年都要多。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[会当临绝顶]]></title>
      <url>http://fengchao.github.io/2016/07/05/Archive-what-you-think/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>人的主观能有多大的魔力，是一个哲学问题。曾经经历过的几个事情，促使我做一些思考和总结。</p><h2 id="爬黄山"><a href="#爬黄山" class="headerlink" title="爬黄山"></a>爬黄山</h2><p>六岁的时候，父亲带我去爬黄山。上山的路都是自己走的，包括天都峰。当时确实很累，但是咬牙坚持下来了。那时候太小，是不懂什么“会当临绝顶，一览众山小”的，只知道云海很好看。</p><p>后来很长一段时间，都觉得自己内心有一股劲，遇到困难的时候，想想自己爬过黄山，就咬牙坚持。后来想想，这股劲，就是毅力吧。这股毅力，是战胜了一次困难之后产生的。当你战胜了它，所有比它小的困难，都是可以克服的。</p><blockquote><p>“世界上有两种人，赢家和失败者，两者的区别在于，赢家从不放弃…”</p></blockquote><h2 id="退学者"><a href="#退学者" class="headerlink" title="退学者"></a>退学者</h2><p>大二开始的时候，系里面有一个人因为玩游戏太多，挂科太多，被劝退。后来听说，这个同学回去之后重新高考，直接考上清华，数学还是满分。</p><p>听到这个消息时，内心还是很震撼，也许有一丝的嫉妒和不甘心。当时已经感觉出来：高三上三年和上了大一再回来上高三，有一种难以言喻差距存在。因为学习过高数，再看高中数学，不要太简单。</p><p>同样的时间，一直在低水平的地方重复，效果并不大。</p><p>克服了高数，高中数学就是那众山小。<br>克服了泛函，线性代数就是那众山小。</p><h2 id="攀岩"><a href="#攀岩" class="headerlink" title="攀岩"></a>攀岩</h2><p>大四毕业的时候，和同学一起去攀岩。同样一个道，开始的时候，每个人都爬不到顶。也许是爬道中间确实有些地方有点难。直到有一个女生，尝试很多次终于通过了困难区，攀到顶端。然后奇迹出现了，后面的每个人，都能爬道顶了。</p><p>攀岩回去之后，整个手都抖的不行，两天抬不起来，两天一直思考这个事情。前面的人，因为没有人成功过，所以老是以为我也不行。而当认识到这个事情是可能的时候，就可以成功了，这就是榜样的力量。</p><p>所谓的榜样，就是让人真正相信，之前不可能的事情，现在是可行的了。一个人临绝顶，天下人看众山小。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最难解的代码问题]]></title>
      <url>http://fengchao.github.io/2016/07/05/Hard-Bugs/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>由于C语言的本身设计非常贴近底层，所以会有一些坑，很容易出问题。回想一下之前遇到的难解问题，大概包括下面几类：</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a>堆栈溢出</h3><p>Linux 的堆栈是比较小的，32 位系统上是 8KB，64 位系统上是 16KB。所以使用静态变量，长调用栈时要非常小心。</p><p>因为堆栈后面会有 Thread 的重要信息，所以堆栈溢出后，很可能看到调用栈都是乱七八糟的。</p><p>最近 Linux 内核有计划将堆栈使用的直接映射内存变为虚拟映射内存。这样可以通过映射表检查是否有堆栈溢出访问，堆栈溢出的错误会更容易发现和调试。</p><h3 id="多次回收-Double-free"><a href="#多次回收-Double-free" class="headerlink" title="多次回收 (Double free)"></a>多次回收 (Double free)</h3><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[建立社群的步骤]]></title>
      <url>http://fengchao.github.io/2016/06/30/How-to-create-community/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><h3 id="1-重新定义目标用户群体，确立产品定位"><a href="#1-重新定义目标用户群体，确立产品定位" class="headerlink" title="1. 重新定义目标用户群体，确立产品定位"></a>1. 重新定义目标用户群体，确立产品定位</h3><ul><li>确定目标人群，用户画像</li><li>设计联系成员的纽带</li></ul><h3 id="2-寻找初始用户"><a href="#2-寻找初始用户" class="headerlink" title="2. 寻找初始用户"></a>2. 寻找初始用户</h3><h3 id="3-策划社群活动，强化身份认同"><a href="#3-策划社群活动，强化身份认同" class="headerlink" title="3. 策划社群活动，强化身份认同"></a>3. 策划社群活动，强化身份认同</h3><h3 id="4-社群裂变，培植自组织"><a href="#4-社群裂变，培植自组织" class="headerlink" title="4. 社群裂变，培植自组织"></a>4. 社群裂变，培植自组织</h3><h3 id="5-建章立制，健全社群运营机制"><a href="#5-建章立制，健全社群运营机制" class="headerlink" title="5. 建章立制，健全社群运营机制"></a>5. 建章立制，健全社群运营机制</h3><ul><li>评价机制</li><li>激励机制</li><li>会员积分体系</li><li>游戏化等级</li></ul><h3 id="6-社群文化"><a href="#6-社群文化" class="headerlink" title="6. 社群文化"></a>6. 社群文化</h3><p>部落群体必须具备三个特征：</p><ul><li>相似的文化</li><li>频繁的互动</li><li>共同的利益</li></ul><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[创新者的窘境]]></title>
      <url>http://fengchao.github.io/2016/06/28/The-Innovators-Dilemma/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>具有领先优势的大公司，在面对突破性的技术创新时，失去了竞争优势，被后起者超越。《创新者的窘境》这本书希望找到问题原因</p><h2 id="原因总结"><a href="#原因总结" class="headerlink" title="原因总结"></a>原因总结</h2><ol><li>资源分配的重心是满足当前用户，所以创新产品得不到足够的重视。</li><li>公司规模和市场规模不匹配。新技术的市场规模开始时都比较小，大公司会忽略这个小市场。</li><li>新的市场可能是不存在的，所以很难去分析。不但是未知的，而且是不可知的。</li><li>害怕失败，不愿意离开安全区。</li></ol><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>创建与世隔绝的科研基地，封闭开发。</li><li>将突破性技术商业化的责任交给一个足够小的机构。</li><li>在未知市场试错，发现新的机会。避免传统的绩效考核方式。</li><li>创业公司、孵化器。</li></ol><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[技术类型和典型缺陷]]></title>
      <url>http://fengchao.github.io/2016/06/23/Tech-Type-and-solution/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>不同的技术类型，有不同的缺陷，需要重点关注和加强：</p><p><img src="/images/Tech_person_type.jpg" alt="Type"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[甲骨文告谷歌 - 输了]]></title>
      <url>http://fengchao.github.io/2016/06/14/Google-win-Oracle/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><h3 id="Java-开源十年"><a href="#Java-开源十年" class="headerlink" title="Java 开源十年"></a>Java 开源十年</h3><p>十年前 <a href="http://fengchao.github.io/2006/11/16/Sun-Opens-Java/">Sun 开源 Java</a> 的时候，普天同庆。一个新的世界展现在 Java 眼前，一个开源的 Java 吸引力更多开发者和公司的贡献。十年间，</p><p>谷歌做了 Android，用 Java 作为软件开发语言。Android 凭借开源属性，和苹果展开激烈竞争，成为世界第一手机操作系统。</p><h3 id="专利流氓搅局"><a href="#专利流氓搅局" class="headerlink" title="专利流氓搅局"></a>专利流氓搅局</h3><p>甲骨文收购了 Sun，但是花了很多年时间，依然搞不清楚怎么通过开源软件盈利，看到 Android 这么风生水起，显然眼红的不行。于是拿起专利大棒，状告谷歌侵权并索赔 90 亿美元。</p><p>甲骨文自己在 Java 开发上鲜有作为，却暗指谷歌 Android 的成功完全是 Java 带来的，说的好像自己也能搞出来一个 Android 似的，在专利流氓的道路上越走越远。</p><p>旧金山联邦法庭陪审团今日已做出裁决，认定谷歌 Android 并未侵犯 Oracle 所有的 Java 版权。Google 表示，陪审团的认定代表了 Android 生态体系、Java 开发社区以及依靠开放免费编程语言开发创新消费者产品的软件开发者的胜利。松下一口气的不只有 Google，也包括成千上万的软件开发者。</p><h3 id="阴霾笼罩-Java"><a href="#阴霾笼罩-Java" class="headerlink" title="阴霾笼罩 Java"></a>阴霾笼罩 Java</h3><p>虽然官司赢了，但是 Java 的开源道路已经蒙上了厚厚的阴霾。很多公司再做创新性开发的时候，一定会考虑避免再拿 Java 作为核心组件。毕竟不是每个公司都能像谷歌一样请到最好的律师，能够和甲骨文巨头搞法律对战。</p><p>微软一直想做，但是没有做成的事情，甲骨文做到了。</p><p>软件版权，已经成为创新的障碍；软件版权，应该消亡。</p><p><img src="/images/conways_law.png" alt="Sun 开源 Java"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Tmux 快速指南]]></title>
      <url>http://fengchao.github.io/2016/06/13/Tmux/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:23:01 GMT+0800 (CST) --><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>启动</td><td>tmux</td></tr><tr><td>帮助</td><td>^b ?</td></tr></tbody></table><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>新建会话</td><td>tmux new-session -s play</td></tr><tr><td>重命名会话</td><td>tmux rename-session tutorial</td></tr><tr><td>查看会话</td><td>tmux ls</td></tr><tr><td>加入会话</td><td>tmux attach -t ‘’session’’</td></tr><tr><td>脱离会话</td><td>^b d</td></tr></tbody></table><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>创建窗口</td><td>^b c</td></tr><tr><td>关闭窗口</td><td>^d</td></tr><tr><td>下个窗口</td><td>^b n</td></tr><tr><td>上个窗口</td><td>^b p</td></tr><tr><td>最后窗口</td><td>^b l</td></tr><tr><td>选择窗口</td><td>^b w</td></tr><tr><td>查找窗口</td><td>^b f</td></tr></tbody></table><h2 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h2><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>水平分割</td><td>^b %</td></tr><tr><td>垂直分割</td><td>^b “</td></tr><tr><td>切换</td><td>^b o</td></tr><tr><td>放大</td><td>^b z</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开源漏斗模型]]></title>
      <url>http://fengchao.github.io/2016/06/12/Open-source-funnel/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><img src="/images/Funnel.png" alt="Funnel" title="Funnel"></p><h2 id="销售漏斗"><a href="#销售漏斗" class="headerlink" title="销售漏斗"></a>销售漏斗</h2><p>销售中有一个经典的漏斗模型，一个用户需要一系列步骤才会真正购买。在每一个步骤上，都会有用户止步不前，所以最终购买的用户仅仅是潜在用户的很小一部分。</p><ol><li>潜在客户</li><li>了解产品</li><li>浏览网页</li><li>产生购买欲望</li><li>点击购物车</li><li>网银付款</li><li>快递收货</li><li>实际使用</li></ol><h2 id="开发漏斗"><a href="#开发漏斗" class="headerlink" title="开发漏斗"></a>开发漏斗</h2><p>同样，在开源开发中也有类似的漏斗模型存在:</p><ol><li>使用产品</li><li>参与社区讨论</li><li>首次参与贡献</li><li>长期开发者</li><li>核心开发者</li></ol><p>同样的，每一步都会有开发者止步不前，只有极少数人会成为核心开发者。所以为了提高最终的成功可能，获得更多的开发者，一个开源产品也需要进行运营工作。</p><h2 id="运营开源产品"><a href="#运营开源产品" class="headerlink" title="运营开源产品"></a>运营开源产品</h2><h3 id="用户社区"><a href="#用户社区" class="headerlink" title="用户社区"></a>用户社区</h3><p>互联网经济中，所有公司都已经大大提高了对用户社区的重视程度。对开源产品来说，更是如此。很多开源项目都有非常活跃的论坛、IRC、邮件列表等等，老用户帮助新用户。</p><h3 id="首次贡献"><a href="#首次贡献" class="headerlink" title="首次贡献"></a>首次贡献</h3><p>大部分用户开源软件的首次贡献，都是在使用的过程中遇到 Bug。为了解决自己遇到的问题，就去查看代码，找到问题原因，并提交补丁。</p><p>和封闭系统相比，开源系统大大降低了活跃用户参与贡献的难度。尤其是 <a href="https://github.com/" target="_blank" rel="external">Github</a> 的 pull request 机制，更是简化了 patch 提交和合并流程。为了让更多的用户进行首次贡献，一个开源项目最好提供一份快速启动手册，一个专门的页面介绍如何进行贡献。</p><h3 id="长期贡献"><a href="#长期贡献" class="headerlink" title="长期贡献"></a>长期贡献</h3><p>首次贡献变为长期贡献，是一个很艰难的过程。除了解决自己的问题，还是需要额外的动力。对于开源软件来说，商业社会惯用的钱已经起不了作用了。</p><p>不为钱，则为利。需要给这些开发者足够的荣誉，比如贡献者列表等等。激发人对内心自我实现的渴望。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么你会不堪重负]]></title>
      <url>http://fengchao.github.io/2016/06/08/why-people-burn-out/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h3 id="强迫证明自己"><a href="#强迫证明自己" class="headerlink" title="强迫证明自己"></a>强迫证明自己</h3><p>通常情况下都是具有过度的野心。这欲望本是用来证明自己的，但在工作场所，这个欲望往往变成决心和强制性的。</p><h3 id="更加努力的工作"><a href="#更加努力的工作" class="headerlink" title="更加努力的工作"></a>更加努力的工作</h3><p>为了融入一个不适合自己的组织，为自己定了较高的期望值。为了满足这些期望，他们往往只专注于工作，而且他们愿意承担更多的工作。这往往都会让他们任何事都要亲自作为，这都是为了表明他们是最好的，因为他们不需要他人的帮助完成更多的工作量。</p><h3 id="忽略需求"><a href="#忽略需求" class="headerlink" title="忽略需求"></a>忽略需求</h3><p>因为他们一心只关注与工作，他们几乎没有时间和精力再做别的事情。与朋友，家人聚餐和吃饭，睡觉一般的生理需求已经被他们视为不重要的了，因为这会浪费他们的时间。</p><h3 id="冲突转移"><a href="#冲突转移" class="headerlink" title="冲突转移"></a>冲突转移</h3><p>他们开始意识到某些地方不太对劲，但他们无法正确归因。这可能导致他们激烈的内心冲突进而引发一系列的身体症状——这是他们首先表现出身体症状的阶段。</p><h3 id="价值观重组"><a href="#价值观重组" class="headerlink" title="价值观重组"></a>价值观重组</h3><p>在这个阶段，他们将自己无形中隔离，规避与他人的冲突，并且因为他们认知模式的改变，他们否认或是拒绝自己正当的生理需要。他们的价值观体系也随之改变。工作占据了他们能支配的所有精力，从而他们再没有关照朋友或者家人的功夫。他们新的价值观围绕着工作，并且他们开始变得情感迟钝。</p><h3 id="否认暴露的问题"><a href="#否认暴露的问题" class="headerlink" title="否认暴露的问题"></a>否认暴露的问题</h3><p>他们开始变得偏执。他们不再喜欢社会生活，如果要他们参加社交活动的话，他们会觉得那几乎无法忍受。对他们了解不多的局外人可能会看到他们显示出更加强烈的攻击性。人们常常会发现，他们越发倾向于抱怨他们的工作是多么庞杂难以完成，他们的时间是如何不够他们支配，而非他们自己是否做出了什么改变。</p><h3 id="自闭"><a href="#自闭" class="headerlink" title="自闭"></a>自闭</h3><p>他们的社交只维持在最小限度，并且很快他们自己陷入自闭的状态之中。酒精和兴奋性药物可能会被滥用用来在他们满负荷的工作之余排解他们的压力。他们在这个阶段开始常常经历无助感和无方向感。</p><h3 id="自显著的行为改变"><a href="#自显著的行为改变" class="headerlink" title="自显著的行为改变"></a>自显著的行为改变</h3><p>他们的同事，家人，朋友以及他们社交圈中的其他人会显著注意到他们行为上的改变。</p><h3 id="人格解体"><a href="#人格解体" class="headerlink" title="人格解体"></a>人格解体</h3><p>他们与自己失去了沟通，也就很难在他们自己或是他人身上看到任何价值之所在。与此同时，他们失去了对自己个人需求的响应。他们对生活的观念下降到只关注现有的时间，他们的人生变成了一系列的机械的功能组合。</p><h3 id="内心空虚"><a href="#内心空虚" class="headerlink" title="内心空虚"></a>内心空虚</h3><p>他们感到内心空虚。为了规避这一点，他们可能会去找其他乐子，暴饮暴食，乱性，酒精或者毒品。这些行为可能会非常夸张。</p><h3 id="抑郁"><a href="#抑郁" class="headerlink" title="抑郁"></a>抑郁</h3><p>心力交瘁可能带来抑郁。他们感到疲惫不堪，绝望，冷漠，并且认为未来的生活对他们毫无意义。典型的抑郁症状开始出现。</p><h3 id="心力交瘁综合症"><a href="#心力交瘁综合症" class="headerlink" title="心力交瘁综合症"></a>心力交瘁综合症</h3><p>身心崩溃。在这个阶段，他们应该立即寻求医疗的帮助。在极端的抑郁状况下，可能会出现自杀意念——自杀被这时的他们视为一种逃离现有状况的方式。但只有很少一部分人会实施自杀。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[flashroom]]></title>
      <url>http://fengchao.github.io/2016/05/27/flashroom/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>最近在做 Corebios （曾经的 Linuxbios）到 EPIA 板子的移植，发现 flashrom 真是好用。</p><h3 id="1-手动安装："><a href="#1-手动安装：" class="headerlink" title="1. 手动安装："></a>1. 手动安装：</h3><pre><code>$ svn co svn://coreboot.org/repos/trunk/util/flashrom
$ cd flashrom
$ make
$ sudo make install
</code></pre><h3 id="2-直接安装："><a href="#2-直接安装：" class="headerlink" title="2.直接安装："></a>2.直接安装：</h3><p>Debian</p><pre><code>$ sudo aptitude install flashrom
</code></pre><p>Fedora</p><pre><code>$ sudo yum install flashrom
</code></pre><p>Mandriva</p><pre><code>$ urpmi flashrom
</code></pre><p>openSUSE</p><pre><code>$ yast -i coreboot-utils
</code></pre><h3 id="3-使用方法："><a href="#3-使用方法：" class="headerlink" title="3 使用方法："></a>3 使用方法：</h3><p>检测主板和芯片是否支持：<br>$ flashrom</p><p>将原有 BIOS 备份读取出来</p><pre><code>$ flashrom -r backup.bin
</code></pre><p>写入新的 BIOS</p><pre><code>$ flashrom -wv newbios.bin
</code></pre><h3 id="4-更详细的信息请查看Flashrom的README"><a href="#4-更详细的信息请查看Flashrom的README" class="headerlink" title="4 更详细的信息请查看Flashrom的README"></a>4 更详细的信息请查看Flashrom的README</h3><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PCI 设备驱动]]></title>
      <url>http://fengchao.github.io/2016/05/27/PCI-device-driver/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h3 id="1-PCI-简介"><a href="#1-PCI-简介" class="headerlink" title="1. PCI 简介"></a>1. PCI 简介</h3><p>PCI 总线标准是一种将系统外部设备连接起来的总线标准，是 PC 中最重要的总线，实际上是系统的各个部分如何交互的接口。传输速率可达到 133MB/s。在当前的 PC 体系结构中，几乎所有的外部设备采用的各种各样的接口总线，均是通过桥接电路挂接到 PCI 系统上。在这种 PCI 系统中， Host/PCI 桥称为北桥，连接主处理器总线到基础 PCI 局部总线。 PCI 与其他总线的接口称为南桥，其中南桥还通常含有中断控制器、IDE 控制器、USB 控制器和 DMA 控制器等。南桥和北桥组成主板的芯片组。</p><h3 id="2-PCI配置空间"><a href="#2-PCI配置空间" class="headerlink" title="2. PCI配置空间"></a>2. PCI配置空间</h3><p>每个PCI设备都有自己的配置空间，用于支持即插即用，使之满足现行的系统配置结构。下面对PCI配置空间做一下简要介绍。</p><p>配置空间是一容量为256字节并具有特定结构的地址空间。这个空间又分为头标区和设备有关区两部分。头标区的长度是64字节，每个设备都必须配置该区的寄存 器。该区中的各个字段用来唯一地识别设备。其余的192字节因设备而异。配置空间的头标区64个字节的使用情况如图1示。</p><p>为了实现即插即用，系统可根据硬件资源的使用情况，为PCI设备分配新的资源。因此编写设备驱动程序重点是获得基址寄存器（Base Address）和中断干线寄存器的内容。配置空间共有六个基址寄存器和一个中断干线寄存器，具体用法如下：</p><p>PCI Base Address 0 寄存器：系统利用此寄存器为PCI接口芯片的配置寄存器分配一段PCI地址空间，通过这段地址我们可以以内存映射的形式访问PCI接口芯片的配置寄存器。</p><p>PCI Base Address 1寄存器：系统利用此寄存器为 PCI 接口芯片的配置寄存器分配一段PCI地址空间，通过这段地址我们可以以I/O的形式访问PCI接口芯片的配置寄存器。</p><p>PCI Base Address 2、3、4、5寄存器：系统BIOS利用这些寄存器分配PCI地址空间以支持PCI接口芯片的局部配置寄存器0、1、2、3的访问。</p><p>在所有基址寄存器中，第0位均为只读位，表示这段地址映射到存储器空间还是I/O空间，如果是“1”表示映射到I/O空间，如果是“0”则表示映射到存储器空间。</p><p>中断干线寄存器（Interrupt Line）：用于说明中断线的连接情况，这个寄存器的值与标准8259的IRQ编号（0~15）对应。</p><p>表1 PCI配置空间</p><h3 id="3-设备初始化"><a href="#3-设备初始化" class="headerlink" title="3.设备初始化"></a>3.设备初始化</h3><p>PCI 设备驱动程序要完成识别 PCI 器件、寻找 PCI 硬件的资源和对 PCI 器件中断的服务。在驱动程序初始化过程中，使用 HalGetBusData（）函数完 成寻找 PCI 设备的工作。在初始化过程中，使用器件识别号（Device ID）和厂商识别号（Vendor ID），通过遍历总线上的所有设备，寻找到指定的PCI设备，并获取设备的总线号，器件号与功能号。通过这些配置信息，可以在系统中寻址该设备的资源配置 列表。</p><p>在此之后，驱动程序需要从配置空间获取硬件的参数。PCI设备的中断号、端口地址的范围（I/O）方式、存储器的地址与映射 方式等，都可以从硬件资源列表数据结构中获取。在Windows NT中，调用HalAssignSlotResources（）函数来获得指定设备的资源列表数据结构指针，然后通过遍历该列表中的所有资源描述符，获取 该设备的I/O端口基地址与长度，中断的中断级、中断向量与模式，存储器基地址与长度等硬件资源数据。</p><p>我们设计的DMA通信采用总线主控方式进行通信，在 设备初始化时需要对DMA适配器进行初始化，使用HalGetAdapter（）获得操作系统分配的适配器对象指针。<br>示例代码如下：</p><p>// 遍历总线，获得指定设备的总线号，器件号与功能号<br>for ( busNumber = 0; busNumber &lt; MAX_PCI_BUSES; busNumber++ ) {<br>for ( deviceNumber = 0;deviceNumber &lt; PCI_MAX_DEVICES;deviceNumber++ ) {<br>slotNumber.u.bits.DeviceNumber = deviceNumber;<br>for ( functionNumber = 0; functionNumber &lt; PCI_MAX_FUNCTION; functionNumber++ ) {<br>slotNumber.u.bits.FunctionNumber = functionNumber;<br>if (!HalGetBusData(PCIConfiguration, busNumber, slotNumber.u.AsULONG,<br>&amp;pciData,sizeof(ULONG)) ) {<br>deviceNumber = PCI_MAX_DEVICES;<br>break;<br>}</p><pre><code>          if (pciData.VendorID == PCI_INVALID_VENDORID ) { 
              continue;
          }

          if ( ( VendorId != PCI_INVALID_VENDORID ) &amp;&amp; ( pciData.VendorID != VendorId || pciData.DeviceID != DeviceId )) {
              continue;
          }
          pPciDeviceLocation-&gt;BusNumber = busNumber; 
          pPciDeviceLocation-&gt;SlotNumber = slotNumber;
          pPciDeviceLocation = &amp;PciDeviceList-&gt;List[++count];
          status = STATUS_SUCCESS;
        } 
    } 
} 
// 获取设备的资源列表数据指针
status = HalAssignSlotResources(RegistryPath,
&amp;pDevExt-&gt;ClassUnicodeString,
DriverObject,
DeviceObject,
pDevExt-&gt;InterfaceType,
pDevExt-&gt;BusNumber,
pDevExt-&gt;SlotNumber,
&amp;pCmResourceList );
</code></pre><h3 id="4-I-O端口访问"><a href="#4-I-O端口访问" class="headerlink" title="4. I/O端口访问"></a>4. I/O端口访问</h3><p>在 PC机上，I/O寻址方式与内存寻址方式不同，所以处理方法也不同。I/O空间是一个64K字节的寻址空间，I/O寻址没有实模式与保护模式之分，在各种 模式下寻址方式相同。在Windows NT下，系统不允许处于Ring3级的用户程序和用户模式驱动程序直接使用I/O指令，对I/O端口进行访问，任何对I/O的操作都需要借助内核模式驱动 来完成。在访问I/O端口时，使用READ_PORT_XXX与WRITE_PORT_XXX函数来进行读写。I/O端口基地址使用从配置空间基址寄存器 PCI Base Address 1中返回的I/O端口基地址。</p><p>示例代码如下：<br>RegValue = READ_PORT_ULONG(pBaseAddr+RegOffSet);<br>WRITE_PORT_ULONG(pBaseAddr+ RegOffset, RegValue);</p><h3 id="5-设备内存访问"><a href="#5-设备内存访问" class="headerlink" title="5. 设备内存访问"></a>5. 设备内存访问</h3><p>Winsows 工作在32位保护模式下，保护模式与实模式的根本区别在于CPU寻址方式上的不同，这也是Windows驱动程序设计中需要着重解决的问题。 Windows采用了分段、分页机制，使得一个程序可以很容易地在物理内存容量不一样的、配置范围差别很大的计算机上运行，编程人员使用虚拟存储器可以写 出比任何实际配置的物理存储器都大得多的程序。每个虚拟地址由16位的段选择字和32位段偏移量组成。通过分段机制，系统由虚拟地址产生线性地址。再通过 分页机制，由线性地址产生物理地址。线性地址被分割成页目录(Page Directory)、页表(Page Table)和页偏移(Offset)三个部分。当建立一个新的Win32进程时，操作系统会为它分配一块内存，并建立它自己的页目录、页表，页目录的地 址也同时放入进程的现场信息中。当计算一个地址时，系统首先从CPU控制器CR3中读出页目录所在的地址，然后根据页目录得到页表所在的地址，再根据页表 得到实际代码／数据页的页帧，最后再根据页偏移访问特定的单元。硬件设备读写的是物理内存，但应用程序读写的是虚拟地址，所以存在着将物理内存地址映射到 用户程序线性地址的问题。</p><p>从物理内存到线性地址的转换是驱动程序需要完成的工作，可以在初始化驱动程序的进行。在已经获得设备的存 储器基地址后，首先调用HalTranslateBusAddress()函数将总线相关的内存地址转换成系统的物理地址，然后调用 MmMapIoSpace()函数将系统的物理地址映射到线性地址空间。在需要访问设备内存时，调用READ_REGISTER_XXX()与 WRITE_REGISTER_XXX ()函数来进行，基地址使用前面映射后的线性地址。在设备卸载时，调用MmUnmapIoSpace()断开设备内存与线性地址空间的映射。</p><p>示例代码如下：<br>HalTranslateBusAddress(InterfaceType,<br>BusNumber,<br>BaseAddress-&gt;RangeStart,<br>&amp;addressSpace,<br>&amp;cardAddress)</p><pre><code>BaseAddress-&gt;MappedRangeStart = MmMapIoSpace(cardAddress,
BaseAddress-&gt;RangeLength,
MmCached );
……
RegValue = READ_REGISTER_ULONG(pRegister);
WRITE_REGISTER_ULONG(pRegister, pInBuf-&gt;RegValue);
……
MmUnmapIoSpace(pBaseAddress-&gt;MappedRangeStart, pBaseAddress-&gt;RangeLength );
</code></pre><h3 id="6-中断处理"><a href="#6-中断处理" class="headerlink" title="6. 中断处理"></a>6. 中断处理</h3><p>中 断的设置、响应与调用在驱动程序中完成。设置中断应该在设备创建时完成，使用从CmResourceTypeInterrupt描述符中提取的参数，先调 用HalGetInterruptVector()将与总线有关的中断向量参数转换为系统的中断向量，然后调用IoConnectInterrupt() 指定中断服务，注册中断服务函数ISR（Interrupt Service Routine）的函数指针。</p><p>当硬件设备产生中断时，系统 会自动调用ISR函数来响应中断。ISR函数运行的中断请求级较高，主要完成对硬件设备中断的清除，不适合执行过多的代码。在传输大块数据时，需要使用延 迟过程调用（Delay Process Call，DPC）机制。例如，使用PCI设备进行DMA通信时，在ISR函数中完成对指定设备中断的判断以及清除中断，在退出ISR前，调用DPC函 数；在DPC函数中，完成DMA通信的过程，并将数据返回给用户程序。</p><p>示例代码如下：<br>DeviceExtension-&gt;InterruptLevel = partialData-&gt;u.Interrupt.Level;<br>DeviceExtension-&gt;InterruptVector = partialData-&gt;u.Interrupt.Vector;<br>DeviceExtension-&gt;InterruptAffinity = partialData-&gt;u.Interrupt.Affinity;<br>if (partialData-&gt;Flags &amp; CM_RESOURCE_INTERRUPT_LATCHED)<br>{<br>DeviceExtension-&gt;InterruptMode = Latched;<br>} else {<br>DeviceExtension-&gt;InterruptMode = LevelSensitive;<br>}<br>……<br>vector = HalGetInterruptVector(pDevExt-&gt;InterfaceType,<br>pDevExt-&gt;BusNumber,<br>pDevExt-&gt;InterruptLevel,<br>pDevExt-&gt;InterruptVector,<br>&amp;irql,<br>&amp;affinity );</p><pre><code>status = IoConnectInterrupt(&amp;pDevExt-&gt;InterruptObject,
(PKSERVICE_ROUTINE)PciDmaISR,
DeviceObject,
NULL,
vector,
irql,
irql,
pDevExt-&gt;InterruptMode,
TRUE,
affinity,
FALSE );
</code></pre><h3 id="7-DMA通信过程"><a href="#7-DMA通信过程" class="headerlink" title="7. DMA通信过程"></a>7. DMA通信过程</h3><p>DMA通信在驱动程序中实现，需要多个例程才能完成一次DMA通信。</p><p>1） DriverEntry例程<br>构造DEVICE_DESCRIPTION结构，并调用HalGetAdapter，找到与设备关联的Adapter对象，并将返回的Adapter对象的地址和映射寄存器的数目保存在设备扩展的数据结构中。</p><p>示例代码：<br>// 申请DMA的适配器对象<br>deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;<br>deviceDescription.Master = TRUE;<br>deviceDescription.ScatterGather = pDevExt-&gt;ScatterGather;<br>deviceDescription.DemandMode = FALSE;<br>deviceDescription.AutoInitialize = FALSE;<br>deviceDescription.Dma32BitAddresses = TRUE;<br>deviceDescription.BusNumber = pDevExt-&gt;BusNumber;<br>deviceDescription.InterfaceType = pDevExt-&gt;InterfaceType;<br>deviceDescription.MaximumLength = pDevExt-&gt;MaxTransferLength;<br>pDevExt-&gt;AdapterObject = HalGetAdapter(&amp;deviceDescription,<br>&amp;numberOfMapRegisters<br>);<br>……</p><p>2）Start I/O例程</p><p>该例程请求Adapter对象的拥有权，然后把其余的工作留给AdapterControl回调例程。</p><p>a) 调用KeFlushIoBuffers从CPU的Cache把数据清到物理内存，然后计算映射寄存器的数目和用户缓冲区的大小，及在第一次设备操作中传输的字节数。<br>b) 调用MmGetMdlVirtualAddress，从MDL中恢复用户缓冲区的虚地址，并存入设备扩展数据结构中。<br>c) 调用IoAllocateAdapterChannel请求Adapter对象的拥有权。如果调用成功，其余的设置工作由AdapterControl例程去做；如果失败了，则完成本次IRP包处理，开始处理下一个IRP。</p><p>3) AdapterControl例程<br>该例程完成初始化DMA控制器，并启动设备的工作。<br>a) 调用IoMapTransfer，装入Adapter对象的映射寄存器。<br>b) 向设备发送合适的命令开始传输操作。<br>c) 返回值KeepObject保留Adapter对象的拥有权。</p><p>4）中断服务（ISR）例程<br>在设备中断时，由系统调用。<br>a) 向硬件设备发出中断响应的指令。<br>b) 调用IoRequestDpc在驱动程序的DpcForIsr中继续处理该请求。<br>c) 返回TRUE，表示已经服务了本次中断。</p><p>5)DpcForIsr例程<br>由ISR在每个部分数据传输操作的结束时触发，完成当前IRP请求。<br>a) 调用IoFlushAdapterBuffers，清除Adapter对象的Cache中的任何剩余数据。<br>b) 调用IoFreeMapRegisters，释放所使用的映射寄存器。<br>c) 检查有未传完的剩余数据，如果有，则计算下次设备操作中需要传输的字节数，调用IoMapTransfer重设映射寄存器，并启动设备；如果没有剩余数据，则完成当前IRP请求，并开始下一个请求。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[initrd]]></title>
      <url>http://fengchao.github.io/2016/05/27/initrd/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>内存磁盘（RAM Disk)，就是把内存的一部分当成磁盘使用。作为一个临时文件系统，可以提高系统速度。而初始内存磁盘(initrd) 则在系统启动的时候提供了一个临时根文件系统，以支持内核的两步启动过程。这个内存磁盘包含了必要的可执行程序和驱动，以挂载硬盘上真正的文件系统。在桌面系统中，初始内存磁盘的寿命很短暂，仅仅是启动真正根文件系统的一个桥梁，挂载完根文件系统之后就会释放其所占内存；而在许多嵌入式系统中，不存在硬盘上的文件系统，所以 initrd 作为最终的系统一直使用。</p><h3 id="一-initrd-的意义"><a href="#一-initrd-的意义" class="headerlink" title="一. initrd 的意义"></a>一. initrd 的意义</h3><p>内核直接启动不就行了，为什么需要两步启动？</p><p>内核要挂载硬盘等存储设备，就需要这些设备的驱动程序。一种方式就是把已知硬件的驱动直接编译进内核，这在单个系统上是可行的。可以不需要 initrd 就启动系统。但是对于安装面广泛的发行版来说，就等于需要把所有有关存储的驱动都编译进内核，是无法接受的。所以就采取了安装系统后，根据检测到的硬件信 息自动生成 initrd 的方式，把需要的驱动放入，并提供加载驱动，挂载真实文件系统所需要的各个程序（常由 Busybox 提供）。</p><h3 id="二-initrd-工作原理"><a href="#二-initrd-工作原理" class="headerlink" title="二. initrd 工作原理"></a>二. initrd 工作原理</h3><p>既然内核没有驱动，读取不了硬盘，那么 initrd 又是怎么被加载的？<br>initrd 的加载，是由启动管理器 Grub 完成的。这时候的内核并未被启动，硬盘设备的初始化由 BIOS 初始化。Grub 把 initrd 和内核镜像文件载如到内存之后，就会通过 boot 命令启动内核，此时内核可能并无法识别硬盘，但是内存是没问题的，所以内核可以先挂载 initrd 这个精简系统，装入必要驱动然后挂载硬盘中的真实系统。</p><h3 id="三-initrd-的生成"><a href="#三-initrd-的生成" class="headerlink" title="三. initrd 的生成"></a>三. initrd 的生成</h3><p>大部分发行版都有 initrd 的工具，比如 mkinitrd, mkinitramfs 等。实际就是一个 Shell 脚本，可以直接利用这些脚本建立 initrd。 如果需要定制自己的 initrd ，则可以用文本编辑器打开这些程序查看并进行相应修改。</p><h3 id="四-内核通过-initrd-启动的机制"><a href="#四-内核通过-initrd-启动的机制" class="headerlink" title="四. 内核通过 initrd 启动的机制"></a>四. 内核通过 initrd 启动的机制</h3><p>内核启动的代码大都位于 init 子目录，其中 main.c 中的 init() 就是执行的入口地址。在执行了各个子系统的初始化工作之后，调用 do_mounts_initrd.c 中的 initrd_load() 函数，initrd_load 调用 rd_load_image() 将内存中的 initrd 镜像载入到内核的地址空间之中。这样就可以进行下一步的挂载。然后调用 do_mounts.c 的 mount_root() 函数将内存磁盘挂载到内核中，最终调用 fs/namespace.c 中的 sys_mount()挂载根文件系统。</p><p>根文件系统挂载完成之后，返回 init() 主程序，并调用 run_init_process() 函数，这个函数就一句话，通过 kernel_execve 调用系统初始文件比如 linuxrc ,开始应用程序的启动工作。</p><p>完整的函数调用流程：<br>init/main.c:init<br>init/do_mounts.c:prepare_namespace<br>init/do_mounts_initrd.c:initrd_load<br>init/do_mounts_rd.c:rd_load_image<br>init/do_mounts_rd.c:identify_ramdisk_image<br>init/do_mounts_rd.c:crd_load<br>lib/inflate.c:gunzip<br>init/do_mounts.c:mount_root<br>init/do_mounts.c:mount_block_root<br>init/do_mounts.c:do_mount_root<br>fs/namespace.c:sys_mount<br>init/main.c:run_init_process<br>kernel_execve</p><h3 id="五-解压查看"><a href="#五-解压查看" class="headerlink" title="五. 解压查看"></a>五. 解压查看</h3><p>以前的 initrd 是一个独立的文件系统，需要挂载到一个目录才能查看。现在的 initrd 基本都是由 cpio 生成，用如下方法查看：<br>$ gunzip -c /boot/initrd &gt; /tmp/my_initrd<br>$ mkdir ~/initrd_dir<br>$ cd ~/initd_dir<br>$ cpio -i &lt; /tmp/my_initrd参考：</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[编程之道]]></title>
      <url>http://fengchao.github.io/2016/05/27/Tao-of-programing/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>The Silent Void</p><p>Book One</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“When you have learned to snatch the error code from the trap frame, it will be time for you to leave.”</p><p>“当你从我手中夺走水晶球时，就是你离开的时候了。”</p><p>1.1</p><p>Something mysterious is formed, born in the silent void. Waiting alone and unmoving, it is at once still and</p><p>yet in constant motion. It is the source of all programs. I do not know its name, so I will call it the Tao of</p><p>Programming.</p><p>寂静的虚空里诞生了神秘的东西，这种东西恒久存在永不消失，它是所有程序的根源所在，我不知道怎么形容它，姑且称它为编程之道。</p><p>If the Tao is great, then the operating system is great. If the operating system is great, then the compiler is</p><p>great. If the compiler is greater, then the applications is great. The user is pleased and there is harmony in</p><p>the world.</p><p>如果道是完美的，那么操作系统就是完美的，如果操作系统是完美的，那么编译嚣就是完美的，如果编译嚣是完美的，那么应用程序</p><p>就是完美的，所以用户心满意足，整个世界因此和谐。</p><p>The Tao of Programming flows far away and returns on the wind of morning.</p><p>编程之道去如黄鹤来如晨风。</p><p>1.2</p><p>The Tao gave birth to machine language. Machine language gave birth to the assembler.</p><p>道生机器语言，机器语言生汇编嚣。</p><p>The assembler gave birth to the compiler. Now there are ten thousand languages.</p><p>汇编器生编译器，最后产生上万种高级语言。</p><p>Each language has its purpose, however humble. Each language expresses the Yin and Yang of software. Each</p><p>language has its place within the Tao.</p><p>不论多么的微不足道，每种语言都有它自己的目的，每种语言都表达了软件的阴阳两极。每种语言都各得其道。</p><p>But do not program in COBOL if you can avoid it.</p><p>但是尽量不要用COBOL语言。</p><p>1.3</p><p>In the beginning was the Tao. The Tao gave birth to Space and Time. Therefore, Space and Time are the Yin and Yang of</p><p>programming.</p><p>道之初，带来了空间和时间，所以，空间和时间是编程的阴阳两极。</p><p>Programmers that do not comprehend the Tao are always running out of time and space for their programs.</p><p>Programmers thatcomprehend the Tao always have enough time and space to accomplish their goals.</p><p>不懂编程之道的程序员常常把空间和时间消耗殆尽，得道的程序员则总是有足够的空间和时间去完成编程任务。</p><p>How could it be otherwise?</p><p>否则会是什么样呢？</p><p>1.4</p><p>The wise programmer is told about the Tao and follows it. The average programmer is told about the Tao and searches for it. The foolish programmer is told about the Tao and laughs at it.</p><p>上士闻道，从而行之。中士闻道，谨而寻之。下士闻道，大笑之。</p><p>If it were not for laughter, there would be no Tao.</p><p>大笑不足为道。</p><p>The highest sounds are the hardest to hear. Going forward is a way to retreat. Greater talent shows itself late in life.</p><p>Even a perfect program still has bugs.</p><p>希音不闻，进即是退，大嚣晚成。任何程序都有漏洞。</p><hr><p>The Ancient Masters</p><p>Book Two</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“After three days without programming, life becomes meaningless.”</p><p>三日不编程，食肉无味。</p><p>2.1</p><p>The programmers of old were mysterious and profound. We cannot fathom their thoughts, so all we do is describe their appearance.</p><p>远古时代的编程大师们高深莫测，我们不能揣测他们的所思所想，只能描述外表所见。</p><p>Aware, like a fox crossing the water. Alert, like a general on the battlefield. Kind, like a hostess greeting her guests. Simple, like uncarved blocks of wood. Opaque, like black pools in darkened caves.</p><p>他达明，如狐狸过水；机警，如战场上的将军；和善，如主妇款待客人；简单，呆若木鸡；混沌，如深渊之水。</p><p>Who can tell the secrets of their hearts and minds?</p><p>谁能道尽他们的所有？</p><p>The answer exists only in the Tao.</p><p>答案仅存于道。</p><p>2.2</p><p>Grand Master Turing once dreamed that he was a machine. When he awoke he exclaimed:</p><p>超级大师图灵曾梦见自己是一台机器，醒后他这样回忆：</p><p>“I don’t know whether I am Turing dreaming that I am a machine, or a machine dreaming that I am Turing!”</p><p>“我不知道是图灵梦见自己变成机器还是机器梦见自己变成图灵。”</p><p>2.3</p><p>A programmer from a very large computer company went to a software conference and then returned to report to his manager, saying: “What sort of programmers work for other companies? They behaved badly and were unconcerned with appearances. Their hair was long and unkempt and their clothes were wrinkled and old. They crashed out hospitality suites and they made rude noises during my presentation.”</p><p>一个大公司的程序员参加一个软件会议后向他的主管汇报：“那些别的公司的程序员都是些什么样的人呀？他们举止不雅，不修边幅，头发蓬乱，衣服破旧，根本不热情好客，还在我说话的时候乱嚷嚷。”</p><p>The manager said: “I should have never sent you to the conference. Those programmers live beyond the physical world. They consider life absurd, an accidental coincidence. They come and go without knowing limitations. Without a care, they live only for their programs. Why should they bother with social conventions?”</p><p>他的主管说：“我不应该让你参加这次会议，这些程序员生活在现实世界之外。他们认为生活是可笑的，一场意外的偶然而已。他们来去自由，无所牵挂，他们只为他们的程序生活。为什么要用世俗的烦扰去扰乱他们呢？”</p><p>“They are alive within the Tao.”</p><p>“他们生活在道中”。</p><p>2.4</p><p>A novice asked the Master: “Here is a programmer that never designs, documents, or tests his programs. Yet all who know him consider him one of the best programmers in the world. Why is this?”</p><p>一个初学者问主管经理：“有一个程序员，他从来不预先设计，也不写文档，甚至不测试他的程序，但是知道他的人都认为他是世界上最伟大的程序员，为什么呢？”</p><p>The Master replies: “That programmer has mastered the Tao. He has gone beyond the need for design; he does not become angry when the system crashes, but accepts the universe without concern. He has gone beyond the need for documentation; he no longer cares if anyone else sees his code. He has gone beyond the need for testing; each of his programs are perfect within themselves, serene and elegant, their purpose self-evident. Truly, he has entered the mystery of the Tao.”</p><p>经 理说：“那个程序员掌握了道。他不需要预先进行设计；系统崩溃时他也从不烦燥，只是接受发生的一切而不管发生的事是好是坏 。他不需要写文档，他从不顾及有没有人看他写的代码。他也不需要进行测试；他写的每个程序都有一个完美的自我，平静而优雅，它们的目的不言自明。他已经真 正掌握了道的精髓。”</p><hr><p>Design</p><p>Book Three</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“When program is being tested, it is too late to make design changes.”</p><p>“程序被测试时再去改变它的设计已经太晚了。”</p><p>3.1</p><p>There once was a man who went to a computer trade show. Each day as he entered, the man told the guard at the door:</p><p>曾经有一个人参加计算机展览，每天他进门时都对门卫说：</p><p>“I am a great thief, renowned for my feats of shoplifting. Be forewarned, for this trade show shall not escape unplundered.”</p><p>“先警告你，我是偷盗高手，我入室偷盗的本领闻名遐迩。这次展览会也再劫难逃。”</p><p>This speech disturbed the guard greatly, because there were millions of dollars of computer equipment inside, so he watched the man carefully. But the man merely wandered from booth to booth, humming quietly to himself.</p><p>警卫因此大动干戈，因为里面有价值百万的计算机设备，所以他牢牢盯紧了这个人，但是这个人只是从一个摊位逛到另一个摊位，一边平静地喃喃自语。</p><p>When the man left, the guard took him aside and searched his clothes, but nothing was to be found.</p><p>当这个人离开时，警卫搜了他的身，但是什么也没有发现。</p><p>On the next day of the trade show, the man returned and chided the guard saying: “I escaped with a vast booty yesterday, but today will be even better.” So the guard watched him ever more closely, but to no avail.</p><p>展览会的第二天，这个人又对警卫说：“昨天我满载而归，但是今天我会收获更大。”所以警卫更加小心地盯紧他，但是这样做完全于事无补。</p><p>On the final day of the trade show, the guard could restrain his curiosity no longer. “Sir Thief,” he said, “I am so perplexed, I cannot live in peace. Please enlighten me. What is it that you are stealing?”</p><p>展览会的最后一天，警卫再也不能忍住他的好奇心了。“小偷先生，”他说，“ 你说我惊慌不安，请告诉我，你到底偷了什么？”。</p><p>The man smiled. “I am stealing ideas,” he said.</p><p>这个人笑笑说：“我在偷想法。”</p><p>3.2</p><p>There once was a master programmer who wrote unstructured programs. A novice programmer, seeking to imitate him, also began to write unstructured programs. When the novice asked the master to evaluate his progress, the master criticized him for writing unstructured programs, saying: “What is appropriate for the master is not appropriate for the novice. You must understand the Tao before transcending structure.”</p><p>有一位编程大师，他写非结构化的程序，一位初学者刻意模仿他，也写非结构化的程序。当他让大师看他的进步时，大师批评了他的非结构化程序：“ 对一位编程大师合适的东西未必对一个初学者同样合适，在超越结构化之前，你必须理解编程之道。”</p><p>3.3</p><p>There was once a programmer who was attached to the court of the warlord of Wu. The warlord asked the programmer: “Which is easier to design: an accounting package or an operating system?”</p><p>###有人问一位程序员，“一个财务软件和一个操作系统哪个更容易设计？”</p><p>“An operating system,” replied the programmer.</p><p>“是操作系统”，这位程序员回答说。</p><p>The warlord uttered an exclamation of disbelief. “Surely an accounting package is trivial next to the complexity of an operating system,” he said.</p><p>此人大惑不解。他说：“显然一个财务软件比起操作系统来说其复杂性是微不足道的”。</p><p>“Not so,” said the programmer, “when designing an accounting package, the programmer operates as a mediator between people having different ideas: how it must operate, how its reports must appear, and how it must conform to the tax laws. By contrast, an operating system is not limited my outside appearances. When designing an operating system, the programmer seeks the simplest harmony between machine and ideas. This is why an operating system is easier to design.”</p><p>程 序员说：“不，设计财务软件时，一个程序员 必须成为持不同意见的用户与计算机的一个中介，他必须了解用户的操作习惯，报表要是什么形式，如何遵循税法。相反，一个操作系统完全与这些外部的东西无 关。设计操作系统，程序员只需要达到自己的设想与机器之间的简单的和谐。这就是为什么操作系统反而比财务软件更容易设计。”</p><p>The warlord of Wu nodded and smiled. “That is all good and well, but which is easier to debug?”</p><p>这些人笑着说。“不错，但是哪一个更容易调试呢？”</p><p>The programmer made no reply.</p><p>程序员没有回答。</p><p>3.4</p><p>A manager went to the master programmer and showed him the requirements document for a new application. The manager asked the master: “How long will it take to design this system if I assign five programmers to it?”</p><p>一个项目经理带给编程大师一个项目的需求，然后问大师：“如果我给你5个程序员，要多少时间设计这个项目？”</p><p>“It will take one year,” said the master promptly.</p><p>“一年”，大师说。</p><p>“But we need this system immediately or even sooner! How long will it take it I assign ten programmers to it?”</p><p>“但是我们等不了那么长时间，越快越好，如果10个程序员呢？”</p><p>The master programmer frowned. “In that case, it will take two years.”</p><p>大师皱了一下眉头说：“那就要花2年”。</p><p>“And what if I assign a hundred programmers to it?”</p><p>“那，100个程序员呢？”</p><p>The master programmer shrugged. “Then the design will never be completed,” he said.</p><p>大师耸了耸肩说：“那这个项目就永远完不成了。”</p><hr><p>Coding</p><p>Book Four</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“A well-written program is its own heaven;</p><p>a poorly-written program is its own hell.”</p><p>“写的好的程序是它自己的天堂，写的不好的程序是它自己的地狱”</p><p>4.1</p><p>A program should be light and agile, its subroutines connected like a strings of pearls. The spirit and intent of the program should be retained throughout. There should be neither too little nor too much, neither needless loops nor useless variables, neither lack of structure nor overwhelming rigidity.</p><p>一个程序应该是轻灵自由的，它的子过程就象串在一根线上的珍珠。自始至终，目标明确。增之一字节则太长，减之一字节则太短。既没有不必要的循环也没有没有被引用的变量，既不缺少结构化也不至于僵硬呆板。</p><p>A program should follow the Law of Least Astonishment. What is this law? It is simply that the program should always respond to the user in the way that astonishes him least.</p><p>一个程序应该遵循”最小惊讶原则’’，什么是”最小惊讶原则’’？就是说一个程序应该最小程度地引起用户的惊讶。</p><p>A program, no matter how complex, should act as a single unit. The program should be directed by the logic within rather than by outward appearances.</p><p>无论一个程序无论有多么复杂都应该是一个单一的整体。程序是被它的内部逻辑所指引而不是它的外观表现。</p><p>If the program fails in these requirements, it will be in a state of disorder and confusion. The only way to correct this is to rewrite the program.</p><p>如果一个程序不能满足所要的需求，它就会处于混乱无序的状态中。唯一的出路就是重写这个程序。</p><p>4.2</p><p>A novice asked the master: “I have a program that sometimes runs and sometimes aborts. I have followed the rules of programming, yet I am totally baffled. What is the reason for this?”</p><p>一个初学者问大师：“我的一个程序有时正常有时不正常。我已经完全遵循编程的规则，而且我完全被它弄糊涂了，到底是什么原因会导致这样呢？”</p><p>The master replied: “You are confused because you do not understand the Tao. Only a fool expects rational behavior from his fellow humans. Why do you expect it from a machine that humans have constructed? Computers simulate determinism; only the Tao is perfect.</p><p>大师说：“你困惑是因为你不了解道。只有傻瓜才会相信只要遵循别人所说就能得到想当然的结果。为什么你要从一个人类自己构造的机器中去得到想当然的结果呢？计算机只是决定论的产物；只有道才是唯一完美的。</p><p>The rules of programming are transitory; only the Tao is eternal. Therefore you must contemplate the Tao before you receive enlightenment.</p><p>任何编程的规则都只适合于特定的情况，只有道才是永恒不变的。所以在你受到指引之前要先去思考道。</p><p>“But how will I know when I have received enlightenment?” asked the novice.</p><p>“但是我怎么知道我何时受到指引呢？”</p><p>“Your program will then run correctly,” replied the master.</p><p>“当你的程序正确运行时”。大师说。</p><p>4.3</p><p>A master was explaining the nature of the Tao to one of his novices, “The Tao is embodied in all software – regardless of how insignificant,” said the master.</p><p>初学者请大师解释“道法自然”。大师说：“道存在于任何软件中－－无论是多么没有意义的软件”。</p><p>“Is the Tao in a hand-held calculator?” asked the novice.</p><p>“难道也存在于手持式的计算嚣里？”，初学者问。</p><p>“It is,” came the reply.</p><p>“是的，”</p><p>“Is the Tao in a video game?” continued the novice.</p><p>“也在游戏机里？”，初学者又问到。</p><p>“It is even in a video game,” said the master.</p><p>“是的，甚至也存在于游戏机里”。大师说。</p><p>“And is the Tao in the DOS for a personal computer?”</p><p>“也存在于个人计算机的DOS里吗？”</p><p>The master coughed and shifted his position slightly. “The lesson is over for today,” he said.</p><p>大师咳嗽了一声，稍微动了一下，说，“今天的课就到这里”。</p><p>4.4</p><p>Price Wang’s programmer was coding software. His fingers danced upon the keyboard. The program compiled without an error message, and the program ran like a gentle wind.</p><p>###编程大师编写软件时，手指在键盘上快速飞舞。程序编译时没有一条错误信息，程序运行起来就象一阵微风吹过。</p><p>Excellent!” the Price exclaimed, “Your technique is faultless!”</p><p>太精彩了！你的技巧已经无可挑剔了。</p><p>“Technique?” said the programmer, turning from his terminal, “What I follow is the Tao – beyond all technique. When I first began to program I would see before me the whole program in one mass. After three years I no longer saw this mass. Instead, I used subroutines. But now I see nothing. My whole being exists in a formless void. My senses are idle. My spirit, free to work without a plan, follows its own instinct. In short, my program writes itself. True, sometimes there are difficult problems. I see them coming, I slow down, I watch silently. Then I change a single line of code and the difficulties vanish like puffs of idle smoke. I then compile the program. I sit still and let the joy of the work fill my being. I close my eyes for a moment and then log off.”</p><p>“技巧？”，大师转过身说，“我所遵循的是道–它 超乎所有的技巧。当我开始编程时我看到的是整个一大块的程序，三年后我看到的是子过程。现在我什么也看不到了。我的整个存在是没有任何形式的虚无。我感觉 很悠闲，总之，事实上是我的程序自己在写，有时我看到一些问题，我看到它们，就停下来静静地观察它们，然后我改变了一行代码，难题就象一阵轻烟一样化为乌 有。然后我编译程序。坐在那里享受工作的喜悦。闭了一会眼睛然后退出系统。</p><p>Price Wang said, “Would that all of my programmers were as wise!”</p><p>“什么时候我的程序员才能都达到这样的境界!”</p><p>Mainteance</p><p>Book Five</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“Though a program be but three lines long, someday it will have to be maintained.”</p><p>“既使一个程序只有三行长，也总有一天需要去维护它”</p><p>5.1</p><p>A well-used door needs no oil on its hinges.</p><p>A swift-flowing steam does no grow stagnant.</p><p>Neither sound nor thoughts can travel through a vacuum.</p><p>Software rots if not used.</p><p>经常使用的门不需要往门轴里上油。</p><p>流动的东西就不会停滞不前。</p><p>流水不腐，户枢不蠹。–王磊</p><p>声音和思想都不能在真空里传播。</p><p>软件不用就会腐朽。</p><p>These are great mysteries.</p><p>5.2</p><p>A manager asked a programmer how long it would take him to finish the program on which he was working. “I will be finished tomorrow,” the programmer promptly replied.</p><p>经理问程序员要多长时间才能完成他的项目。“明天”</p><p>“I think you are being unrealistic,” said the manager. “Truthfully, how long will it take?”</p><p>“太不着边际了，老实说，要多久？”</p><p>The programmer thought for a moment. “I have some features that I wish to add. This will take at least two weeks,” he finally said.</p><p>程序员想了一想说。“还有一些新的功能要加进去，可能至少要两个星期吧。”</p><p>“Even that is too much to expect,” insisted the manager, “I will be satisfied if you simply tell me when the program is complete.”</p><p>“即使两个星期恐怕也太夸张了，什么时候你只要告诉我说程序已经完成就好了。”</p><p>The programmer agreed to this.</p><p>Several years slated, the manager retired. On the way to his retirement lunch, he discovered the programmer asleep at his terminal. He had been programming all night.</p><p>几年后，这个经理已经退休了，在他的离职午餐上，他发现这些程序员在他的终端前睡着了，他整夜都在编程。</p><p>5.3</p><p>A novice programmer was once assigned to code a simple financial package.</p><p>一个初学者被要求编写一个财务软件。</p><p>The novice worked furiously for many days, but when his master reviewed his program, he discovered that it contained a screen editor, a set of generalized graphics routines, and artificial intelligence interface, but not the slightest mention of anything financial.</p><p>他疯狂地工作了很多天，但他的主管检视他的程序时发现，它写了一个编辑嚣，一个图形程序集，和人工智能的界面，但是看不到任何跟财务有关的东西。</p><p>When the master asked about this, the novice became indignant. “Don’t be so impatient,” he said, “I’ll put the financial stuff in eventually.”</p><p>主管要求解释时，程序员被激怒了：“你太没耐心了，我会在最后写财务的部分。”</p><p>5.4</p><p>Does a good farmer neglect a crop he has planted?</p><p>Does a good teacher overlook even the most humble student?</p><p>Does a good father allow a single child to starve?</p><p>Does a good programmer refuse to maintain his code?</p><p>一个好的农民不会不管他的庄稼。</p><p>一个好的老师不会不管哪怕是最差的学生。</p><p>一个好的父亲不会让他的任何一个孩子挨饿。</p><p>一个好的程序员不应拒绝维护他的程序。</p><hr><p>Management</p><p>Book Six</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“Let the programmer be many and the managers few – then all will be productive.”</p><p>“增加程序员，减少经理–这样他们都可提高效率。”</p><p>6.1</p><p>When managers hold endless meetings, the programmers write games. When accountants talk of quarterly profits, the development budget is about to be cut. When senior scientists talk blue sky, the clouds are about to roll in.</p><p>经理们忙于无休无止的会议时，程序员们在写游戏。财务主管在谈论季度盈利时开发预算将会被削减。当老科学家在谈天空的蓝色时，云团蜂拥而至。</p><p>Truly, this is not the Tao of Programming.</p><p>这不是编程之道。</p><p>When managers make commitments, game programs are ignored. When accountants make long-range plans, harmony and order are about to be restored. When senior scientists address the problems at hand, the problems will soon be solved.</p><p>经理分配任务时不会包括游戏，会计师做长期计划时，应该做到面面俱到，皆大欢喜。科学家提出一个问题，就会很快得到解决。</p><p>Truly, this is the Tao of Programming.</p><p>这才是编程之道。</p><p>6.2</p><p>Why are programmers non-productive? Because their time is wasted in meetings.</p><p>为什么程序员没有效率，因为他们把时间都浪费在开会上了。</p><p>Why are programmers rebellious? Because the management interferes too much.</p><p>为什么程序员难于管理？因为管理者的干预太多了。</p><p>Why are the programmers resigning one by one? Because they are burnt out.</p><p>为什么程序员一个接一个地辞职，因为他们累坏了。</p><p>Having worked for poor management, they no longer value their jobs.</p><p>在糟糕的管理下工作，他们享受不到工作的乐趣。</p><p>6.3</p><p>A manager was about to be fired, but a programmer who worked for him invented a new program that became popular and sold well. As a result, the manager retained his job.</p><p>一个经理将被解雇，但他手下的一个程序员写了一个流行的软件并且销路很旺。所以经理保住了他的工作。</p><p>The manager tried to give the programmer a bonus, but the programmer refused it, saying, “I wrote the program because I though it was an interesting concept, and thus I expect no reward.”</p><p>经理为程序员分红，但程序员拒绝了，他说：“我写程序是因为写程序很有趣，所以我并没想过得资金”。</p><p>The manager, upon hearing this, remarked, “This programmer, though he holds a position of small esteem, understands well the proper duty of an employee. Lets promote him to the exalted position of management consultant!”</p><p>这位经理说，“这位程序员，不管他现在是什么位置，他都能理解一个雇员的职责所在。我们要把他提升为管理顾问”。</p><p>But when told this, the programmer once more refused, saying, “I exist so that I can program. If I were promoted, I would do nothing but waste everyone’s time. Can I go now? I have a program that I’m working one.”</p><p>这位程序员又一次拒绝了，他说：“我是一个程序员所以我可以编程，如果我被提升了，除了浪费别人的时间什么也做不了，现在我可以走了吗？我还有一个程序没写完。”</p><p>6.4</p><p>A manger went to his programmers and told them: “As regards to your work hours: you are going to have to come in at nine in the morning and leave at five in the afternoon.” At this, all of them became angry and several resigned on the spot.</p><p>经理对程序员说，“你们的工作时间是早上9点到正午点。”，所有的程序员都很不满。</p><p>So the manager said: “All right, in that case you may set your own working hours, as long as you finish your projects on schedule.” The programmers, now satisfied, began to come in a noon and work to the wee hours of the morning.</p><p>经理又说：“好吧，那随你们的便，只要能按时完成任务。”，程序员们这下满意了，他们中午上班，一直工作到凌晨。</p><hr><p>Corporate Wisdom</p><p>Book Seven</p><p>Thus spake the master programmer:</p><p>编程大师如是说：</p><p>“You can demonstrate a program for a corporate executive, but you can’t make him computer literate.”</p><p>###</p><p>“你可以向一位公司主管演示一套程序，但你不能让他的电脑变得象人一样。”</p><p>7.1</p><p>A novice asked the master: “In the east there is a great tree-structure that men call ‘Corporate Headquarters’. It is bloated out of shape with vice-presidents and accountants. It issues a multitude of memos, each saying ‘Go, Hence!’ or ‘Go, Hither!’ and nobody knows what is meant. Every year new names are put onto the branches, but all to no avail. How can such an unnatural entity exist?”</p><p>一 个新学问大师：“在东方，有一个庞大的机 构，人们称作总部。它由为数众多的大小领导。每天发出大量的备忘录，每个备忘录都说：‘干这个，干那个’，没有一个人知道它是什么意思。每年这个机构都会 有更多的人加进来而变得越来越大，但是去没有人去做事情。怎么烩样奇怪的东西还能存在呢？”</p><p>The master replies: “You perceive this immense structure and are disturbed that it has no rational purpose. Can you not take amusement from its endless gyrations? Do you not enjoy the untroubled ease of programming beneath its sheltering branches? Why are you bothered by its uselessness?”</p><p>大师说：“你已经知道这个巨大的机构并不合理，你就不能不管它为什么这样吗？你尽管享受它的好处就是了，干吗要去管它到底是没有效率呢？”</p><p>7.2</p><p>In the east there is a shark which is larger than all other fish. It changes into a bird whose winds are like clouds filling the sky. When this bird moves across the land, it brings a message from Corporate Headquarters. This message it drops into the midst of the program- mers, like a seagull making its mark upon the beach. Then the bird mounts on the wind and, with the blue sky at its back, returns home.</p><p>在遥远的东方，传说有一只巨大的鱼，叫鲲，它变成了一只大鸟，叫鹏，鹏的翅膀可以遮天蔽日，这只大鸟经过陆地的时候，它带来了一个消息，它把这个消息丢在程序员中，就象一只海鸥在海滩上做的记号，然后鹏背负蓝天，乘风而上，回家去了。</p><p>The novice programmer stares in wonder at the bird, for he understands it not. The average programmer dreads the coming of the bird, for he fears its message. The master programmer continues to work at his terminal, for he does not know that the bird has come and gone.</p><p>初学者惊恐地看着这只鸟，根本不敢相信，中级程序员担心这只鸟的到来，因为它害怕它带来的消息，编程大师则继续在他的终端前工作他根本不知道这只鸟曾经来过。</p><p>7.3</p><p>The Magician of the Ivory Tower brought his latest invention for the master programmer to examine. The magician wheeled a large black box into the master’s office while the master waited in silence.</p><p>一个学究带着他的最新发明去见编程大师，他把一个大黑盒子推进大师的办公室。</p><p>“This is an integrated, distributed, general-purpose workstation,” began the magician, “ergonomically designed with a proprietary operating system, sixth generation languages, and multiple state of the art user interfaces. It took my assistants several hundred man years to construct. Is it not amazing?”</p><p>“这是综合的、分布式的通用工作站，”，学究开始介绍了，“按人体工学设计的</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[The Cathedral and Bazaar - 大教堂和市集]]></title>
      <url>http://fengchao.github.io/2016/05/27/The-Cathedral-and-Bazaar/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h3 id="一-大教堂和市集"><a href="#一-大教堂和市集" class="headerlink" title="一. 大教堂和市集"></a>一. 大教堂和市集</h3><p>Linux的影响是非常巨大的。甚至在５年以前，有谁能够想象一个世界级的操作系统能够仅仅用细细的Internet连接起来的散布在全球的几千个开发人员有以业余时间来创造呢？</p><p>我 当然不会这么想。在１９９３年早期我开始注意Linux时，我已经参与Unix和自由软件开发达十年之久了。我是八十年代中期GNU最早的几个参与 者之一。我已经在网上发布了大量的自由软件，开发和协助开发了几个至今仍在广泛使用的程序（Nethack,Emacs VC和GND模式，xlife等等）。我想我知道该怎样做。</p><p>Linux推翻了许多我认为自己明白的事情。我已经宣扬小工具、快速原型和演 进式开发的Unix福音多年了。但是我也相信某些重要的复杂的事情需要更 集中化的，严密的方法。我相信多数重要的软件（操作系统和象Emacs一样的真正大型的工具）需要向建造大教堂一样来开发，需要一群于世隔绝的奇才的细心 工作，在成功之前没有beta版的发布。</p><p>Linus Torvalds的开发风格（尽早尽多的发布，委托所有可以委托的事，对所有的改动和融合开放）令人惊奇的降临了。这里没有安静的、虔诚的大教堂的建造工 作——相反，Linux团体看起来像一个巨大的有各种不同议程和方法的乱哄哄的集市（Linux归档站点接受任何人的建议和作品，并聪明的加以管理），一 个一致而稳定的系统就象奇迹一般从这个集市中产生了。</p><p>这种设计风格确实能工作，并且工作得很好，这个事实确实是一个冲击。在我的研究过程中，我不仅在单个工程中努力工作，而且试图理解为什么Linux世界不仅没有在一片混乱中分崩离析，反而以大教堂建造者们不可想象的速度变得越来越强大。</p><p>到 了１９９６年中，我想我开始理解了。我有一个极好的测试我的理论的机会，以一个自由软件计划的形式，我有意识的是用了市集风格。我这样做了，并取得了很 大的成功。在本文的余下部分，我将讲述这个计划的故事，我用它来明确一些自由软件高效开发的格言。并不是所有这些都是从Linux世界中学到的，但我们将 看到 Linux世界给予了它们一个什么样的位置。如果我是正确的，它们将使你理解是什么使Linux团体成为好软件的源泉，帮助你变得更加高效。</p><h3 id="二-邮件必须得通过"><a href="#二-邮件必须得通过" class="headerlink" title="二. 邮件必须得通过"></a>二. 邮件必须得通过</h3><p>１９９３ 年以前我在一个小的免费访问的名为Chester County InterLink的ISP的做技术工作，它位于Pennsylvania的West Chester。（我协助建立了CCIL，并写了我们独特的多用户BBS系统——你可以telnet到locke.ccil.org来检测一下。今天它在 十九条线上支持三千的用户）。这个工作使我可以一天二十四小时通过CCIL的56K专线连在网上，实际上，它要求我怎么做！</p><p>所以，我对 Internet email很熟悉。因为复杂的原因，很难在我家里的机器（snark.thyrsus.com）和CCIL之间用SLIP工作。最后我终于成功了，但我发 现不得不时常telnet到locke来检查我的邮件，这真是太烦了。我所需要的是我的邮件发送到snark,这样biff(1)会在它到达时通知我。</p><p>简 单地sendmail的转送功能是不够的，因为snark并不是总在网上而且没有一个静态地址。我需要一个程序通过我的SLIP连接把我的本地发送的邮 件拉过来。我知道这种东西是存在的，它们大多使用一个简单的协议POP（Post Office Protocol）。而且，locke的BSD/OS操作系统已经自带了一个POP3服务器。</p><p>我需要一个POP3客户。所以我到网上去找 到了一个。实际上，我发现了三、四个。我用了一会pop-perl，但它却少一个明显的特征：抽取收到的邮件的 地址以便正确回复。问题是这样的：假设locke上一个叫“joe”的人向我发了一封邮件。如果我把它取到snark上准备回复时,我的邮件程序会很高兴 地把它发送给一个不存在的snark上的“joe”。手工的在地址上加上“@ccil.org”变成了一个严酷的痛苦。这显然应是计算机替我做的事。（实 际上，依据RFC1123的5.2.18节，sendmail应该做这件事）。但是没有一个现存的POP客户知道怎样做！于是这就给我们上了第一课：</p><p>1.每个好的软件工作都开始于搔到了开发者本人的痒处。</p><p>也 许这应该是显而易见的（“需要是发明之母”长久以来就被证明是正确的），但是软件开发人员常常把他们的精力放在它们既不需要也不喜欢的程序，但在 Linux世界中却不是这样——这解释了为什么从Linux团体中产生的软件质量都如此之高。那么，我是否立即投入疯狂的工作中，要编出一个新的POP3 客户与现存的那些竞争呢？才不是哪！我仔细考察了手头上的POP工具，问自己“那一个最接近我的需要？”因为：</p><p>2.好程序员知道该写什么，伟大的程序员知道该重写（和重用）什么。</p><p>我 并没有声称自己是一个伟大的程序员，可是我试着效仿他们。伟大程序员的一个重要特点是建设性的懒惰。他们知道你是因为成绩而不是努力得到奖赏，而且从一 个好的实际的解决方案开始总是要比从头干起容易。例如，Linux并不是从头开始写Linux的。相反的它从重用Minix（一个386机型上的类似 Unix的微型操作系统）的代码和思想入手。最后所有的Minix代码都消失或被彻底的重写了，但是当它们在的时候它为最终成为Linux的雏形做了铺 垫。秉承同样的精神，我去寻找良好编码的现成的POP工具，用来作为基础。</p><p>Unix世界中的代码共享传统一直对代码重用很友好（这正是为 什么GNU计划不管Unix本身有多么保守而选取它作为基础操作系统的原因）。 Linux世界把这个传统推向技术极限：它有几个T字节的源代码可以用。所以在Linux世界中花时间寻找其他几乎足够好的东西，会比在别处带来更好的结 果。</p><p>这也适合我。加上我先前发现的，第二次寻找找到了9个候选者——fetchPOP，PopTart，get- mail，gwpop，pimp，pop- perl，popc，popmail 和 upop）。我首先选定的是“fetchpop”。我加入了头标重写功能，并且做了一些被作者加入他的1.9版中的改进。但是几个星期之后，我偶然发现了 Carl Harris写的“popclient”的代码，然后发现有个问题，虽然fetchpop有一些好的原始思想(比如它的守护进程模式)，它只能处理 pop3，而且编码的水平相当业余(Seung-Hong是个很聪明但是经验不足的程序员)，Carl的代码更好一些，相当专业和稳固，但他的程序缺少几 个重要的相当容易实现的fetchpop的特征(包括我自己写的那些)。</p><p>继续呢还是换一个? 如果换一个的话，作为得到一个更好开发基础的代价，我就要扔掉我已经有的那些代码。换一个的一个实际的动机是支持多协议，pop3是用的最广的邮局协议， 但并非唯一一个，Fetchpop和其余几个没有实现POP2.RPOP，或者APOP，而且我还有一个为了兴趣加入IMAP(Internet Message Access Protocol，最近设计的最强大的邮局协议)的模糊想法。但是我有一个更加理论化的原因认为换一下会是一个好主意，这是我在Linux很久以前学到 的：</p><p>3.“计划好抛弃，无论如何，你会的”(Fred Brooks,《人月神化》第11章)</p><p>或者换句话说，你常常在第一次实现一个解决方案之后才能理解问题所在，第二次你也许才足够清楚怎样做好它，因此如果你想做好，准备好推翻重来至少一次。好吧(我告诉自己)，对fetchpop的尝试是我第一次的尝试，因此我换了一下。</p><p>当 我在1996年6月25日把我第一套popclient的补丁程序寄给Carl Harris之后，我发现一段时间以前他已经对popclient基本上失去了兴趣，这些代码有些陈旧，有一些次要的错误，我有许多修改要做，我们很快达 成一致，我来接手这个程序。不知不觉的，这个计划扩大了，再也不是我原先打算的在已有的pop客户上加几个次要的补丁而已了，我得维护整个的工程，而且我 脑袋里涌动着一些念头要引起一个大的变化。在一个鼓励代码共享的软件文化里，这是一个工程进化的自然道路，我要指出：</p><ol><li>如果你有正确的态度，有趣的问题会找上你的，但是Carl Harris的态度甚至更加重要，他理解：</li></ol><p>5.当你对一个程序失去兴趣时，你最后的责任就是把它传给一个能干的后继者。</p><p>甚至没有商量，Carl和我知道我们有一个共同目标就是找到最好的解决方案，对我们来说唯一的问题是我能否证明我有一双坚强的手，他优雅而快速的写出了程序，我希望轮到我时我也能做到。</p><h3 id="三-拥有用户的重要性"><a href="#三-拥有用户的重要性" class="headerlink" title="三. 拥有用户的重要性"></a>三. 拥有用户的重要性</h3><p>于是我继承了popclient，同样重要的是，我继承了popclient的用户基础，用户是你所拥有的极好的东西，不仅仅是因为他们显示了你正在满足需要，你做了正确的事情，如果加以适当的培养，他们可以成为合作开发者。</p><p>Unix 传统另一有力之处是许多用户都是黑客，因为源优码是公开的，他们可以成为高效的黑客，这一点在Linux世界中也被推向了令人高兴的极致，这 对缩短调试时间是极端重要的，在一点鼓励之下，你的用户会诊断问题，提出修订建议，帮你以远比你期望快得多的速度的改进代码。</p><ol><li>把用户当做协作开发者是快速改进代码和高效调试的无可争辩的方式。</li></ol><p>这种效果的力量很容易被低估，实际上，几乎所有我们自由软件世界中的人都强烈低估了用户可以多么有效地对付系统复杂性，直到Linus让我们看到了这一点。</p><p>实 际上，我认为Linus最聪明最了不起的工作不是创建了Linux内核本身，而是发明了Linux开发模式，当我有一次当着他的面表达这种观点时， 他微笑了一下，重复了一句他经常说的话：“我基本上是一个懒惰的人，依靠他人的工作来获取成绩。”象狐狸一样懒惰，或者如Robert Heinlein所说，太懒了而不会失败。</p><p>回顾起来，在GNU Emacs Lisp库和Lisp代码集中可以看到Linux方法的成功，与Emacs的C内核和许多其他FSF的工具相比，Lisp代码库的演化是流动性的和用户驱 动的，思想和原型在达到最终的稳定形式之前往往要重写三或四次，而且经常利用Internet的松散合作。</p><p>实际上，我自己在 fetchmail之前最成功的作品要算Emacs VC模式，它是三个其他的人通过电子邮件进行的类似Linux的合作，至今我只见过其中一个人(Richard Stallman)，它是SCCS、RCS和后来的CVS的前端，为Emacs提供“one-touch”版本控制操作，它是从一个微型的、粗糙的别人写 好的sccs.el模式开始演化的，VC开发的成功不像Emacs本身，而是因为Emacs Lisp代码可以很快的通过发布／测试／改进的过程。</p><p>(FSF 的试图把代码放入GPL之下的策略有一个未曾预料到的副作用，它让FSF难以采取市集模式，因为他们认为每个想贡献二十行以上代码的人都必须 得到一个授权，以使受到GPL的代码免受版权法的侵扰，具有BSD和MITX协会的授权的用户不会有这个问题，因为他们并不试图保留那些会使人可能受到质 询的权力)。</p><h3 id="四-早发布、常发布"><a href="#四-早发布、常发布" class="headerlink" title="四. 早发布、常发布"></a>四. 早发布、常发布</h3><p>尽量早尽量频繁的发布是Linux开发模式的一个重要部分，多数开发人员(包括我)过去都相信这对大型工程来说是个不好的策略，因为早期版本都是些充满错误的版本，而你不想耗光用户的耐心。</p><p>这 种信仰强化了建造大教堂开发方式的必要性，如果目标是让用户尽可能少的见到错误，那你怎能不会仅仅每六个月发布一次(或更不经常)，而且在发布之间象一 只狗一样辛勤“捉虫”呢? Emacs C内核就是以这种方式开发的，Lisp库，实际上却相反，因为有一些有FSF控制之外的Lisp库，在那里你可以独立于Emacs发布周期地找寻新的和开 发代码版本。</p><p>这其中最重要的是Ohio州的elisp库，预示了今天的巨大的Linux库的许多特征的精神，但是我们很少真正仔细考虑我 们在做什么，或者这个库的 存在指出了FSF建造教堂式开发模式的什么问题，1992年我曾经做了一次严肃的尝试，想把Ohio的大量代码正式合并到Emacs的官方Lisp库中， 结果我陷入了政治斗争中，彻底失败了。</p><p>但是一年之后，在Linux广泛应用之后，很清楚，一些不同的更加健康的东西诞生了，Linus的开发模式正好与建造教堂方式相反，Sunsite和tsx-11的库开始成长，推动了许多发布。所有这些都是闻所未闻的频繁的内核系统的发布所推动的。</p><p>Linus以所有实际可能的方式把它的用户作为协作开发人员。</p><ol><li>早发布、常发布、听取客户的建议</li></ol><p>Linus 的创新并不是这个(这在Unix世界中是一个长期传统)，而是把它扩展到和他所开发的东西的复杂程度相匹配的地步，在早期一天一次发布对他 来说都不是罕见的!而且因为他培育了他的协作开发者基础，比其他任何人更努力地充分利用了Internet进行合作，所以这确实能行。</p><p>但是它是怎样进行的呢?它是我能模仿的吗?还是这依赖于Linus的独特天才?</p><p>我 不这样想，我承认Linus是一个极好的黑客(我们有多少人能够做出一个完整的高质量的操作系统内核?)，但是Linux并不是一个令人敬畏的概念 上的飞跃，Linus不是(至少还不曾是)象Richard stallman或James Gosling一样的创新天才，在我看来，Linus更象一个工程天才，具有避免错误和开发失败的第六感觉，掌握了发现从A点到B点代价最小的路径的决 窍，确实，Linux的整个设计受益于这个特质，并反映出Linus的本质上保守和简化设计的方法。</p><p>如果快速的发布和充分利用Internet不是偶然而是Linus的对代价最小的路径的洞察力的工程天才的内在部分，那么他极大增强了什么?他创建了什么样的方法?</p><p>问题回答了它自己，Linus保持他的黑客用户经常受到激励和奖赏：被行动的自我满足的希望所激励，而奖赏则是经常(甚至每天)都看到工作在进步。</p><p>Linus直接瞄准了争取最多的投入调试和开发的人时，甚至冒代码不稳定和一旦有非常棘手的错误而失去用户基础的险，Linus似乎相信下面这个：</p><ol><li>如果有一个足够大的beta测试人员和协作开发人员的基础，几乎所有的问题都可以被快速的找出并被一些人纠正。</li></ol><p>或者更不正式的讲：“如果有足够多的眼睛，所有的错误都是浅显的”(群众的眼睛是雪亮的)，我把这称为“Linus定律”。</p><p>我最初的表述是每个问题“对某些人是透明的”，Linus反对说，理解和修订问题的那个人不一定非是甚至往往不是首先发现它的人，“某个人发现了问题”，他说，“另一个理解它，我认为发现它是个更大的挑战”，但是要点是所有事都趋向于迅速发生。</p><p>我 认为这是建造教堂和集市模式的核心区别，在建造教堂模式的编程模式看来，错误和编程问题是狡猾的、阴险的、隐藏很深的现象，花费几个月的仔细检查， 也不能给你多大确保把它们都挑出来的信心，因此很长的发布周期，和在长期等待之后并没有得到完美的版本发布所引起的失望都是不可避免的。</p><p>以 市集模式观点来看，在另一方面，我们认为错误是浅显的现象，或者至少当暴露给上千个热切的协作开发人员，让他们来对每个新发布进行测试的时候，它们 很快变得浅显了，所以我们经常发布来获得更多的更正，作为一个有益的副作用，如果你偶尔做了一个笨拙的修改，也不会损失太多。也许我们本不应该这样的惊 奇，社会学家在几年前已经发现一群相同专业的(或相同无知的)观察者的平均观点比在其中随机挑选一个来得更加可靠，他们称此为“Delhpi效应”， Linus所显示的证明在调试一个操作系统时它也适用——Delphi效应甚至可以战胜操作系统内核一级的复杂度。</p><p>我受Jeff Dutky (dutky @ wam.umd.edu)的启发指出Linus定律可以重新表述为“调试可以并行”，Jeff观察到虽然调试工作需要调试人员和对应的开发人员相交流，但 它不需要在调试人员之间进行大量的协调，于是它就没有陷入开发时遇到的平方复杂度和管理开销。</p><p>在实际中，由于重复劳动而导致的理论上的丧失效率的现象在Linux世界中并不是一个大问题，“早发布、常发布策略”的一个效果就是利用快速的传播反馈修订来使重复劳动达到最小。</p><p>Brooks甚至做了一个与Jeff相关的更精确的观察：“维护一个广泛使用的程序的成本一般是其开发成本的40%，奇怪的是这个成本受到用户个数的强烈影响，更多的用户发现更多的错误”(我的强调)。</p><p>更 多的用户发现更多的错误是因为更多的用户提供了更多测试程序的方法，当用户是协作开发人员时这个效果被放大了，每个找寻错误的人都有自己稍微不同的 感觉和分析工具，从不同角度来看待问题。“Delphi效应”似乎因为这个变体工作变得更加精确，在调试的情况下，这个变体同时减小了重复劳动。</p><p>所以加入更多的beta测试人员虽不能从开发人员的P.O.V中减小“最深”的错误的复杂度，但是它增加了这样一种可能性，即某个人的工具和问题正好匹配，而这个错误对这个人来说是浅显的。</p><p>Linus 也做了一些改进，如果有一些严重的错误，Linux内核的版本在编号上做了些处理，让用户可以自己选择是运行上一个“稳定”的版本，还是冒 遇到错误的险而得到新特征，这个战略还没被大多数Linux黑客所仿效，但它应该被仿效，存在两个选择的事实让二者都很吸引　人。</p><h3 id="五-什么时候玫瑰不是玫瑰"><a href="#五-什么时候玫瑰不是玫瑰" class="headerlink" title="五. 什么时候玫瑰不是玫瑰?"></a>五. 什么时候玫瑰不是玫瑰?</h3><p>在研究了Linus的行为和形成了为什么它成功的理论之后，我决定在我的工程(显然没有那么复杂和雄心勃勃)里有意识的测试这个理论。</p><p>但 我首先做的事是熟悉和简化Popclient。 Carl Harris的实现非常好，但是有一种对许多C程序来说没有必要的复杂性。他把代码当作核心而把数据结构当作对代码的支持，结果是代码非常漂亮但是数据结 构设计得很特别，相当丑陋(至少对以这个老LISP黑客的标准来看)，然而除了提高代码和数据结构设计之外，重写它还有一个目的，就是要把它演化为我彻底 理解的东西，对修改你不理解的程序中的错误负责可不是一件有趣的事。</p><p>第一个月我只是在领会Carl’s的基本设计的含义，我所做的第一个 重大修改是加入了IMAP支持，我把协议机重新组织为一个通用驱动程序和三个方法 表(对应POP2、POP3和IMAP)，这个前面的修改指出一个需要程序员(特别是象C这种没有自然的动态类型支持的语言)记在脑中的一般原理：</p><ol><li>聪明的数据结构和笨拙的代码要比相反的搭配工作的更好</li></ol><p>Fred Brooks也在他第11章中讲道：“让我看你的［代码］，把你的[数据结构]隐藏起来，我还是会迷惑；让我看看你的[数据结构]，那我就不需要你的[代码]了，它是显而易见的”。</p><p>实际上，他说的是“流程图”和“表”，但是在三十年的术语／文化演进之后，事情还是一样的。</p><p>此时(1996年9月初，在从零开始六个月后)，我开始想接下来修改名字——毕竟，它已不仅仅是一个POP客户，但我犹豫了，因为还没有什么新的漂亮设计呢，我的popclient版本需要有自己的特色。</p><p>当fetehmail学会怎样把取到的邮件转送到SMTP端口时，事情就完全改变了，但是首先：上面我说过我决定使用这个工程来测试我关于Linus Torualds所做的行为的理论，(你可能会问)我怎样做到这点呢? 以下面的方式：</p><ol><li><p>我尽早尽量频繁的发布(几乎从未少于每十天发布一次；在密集开发的时候是每天一次)。</p></li><li><p>我把每一个和我讨论fetchmail的人加入一个beta表中。</p></li><li><p>每当我发布我都向beta表中的人发出通告，鼓励人们参与。</p></li><li><p>我听取beta测试员的意见，向他们询问设计决策，对他们寄来的补丁和反馈表示感谢。</p></li></ol><p>这些简单的手段立即收到的回报，在工程的开始，我收到了一些错误报告，其质量足以使开发者因此被杀掉，而且经常还附有补丁、我得到了理智的批评，有趣的邮件，和聪明的特征建议，这导致了：</p><ol><li>如果你象对待最宝贵的资源一样对待你的beta测试员，他们就会成为你最宝贵的资源。</li></ol><h3 id="六-popclient变成了Fetchmail"><a href="#六-popclient变成了Fetchmail" class="headerlink" title="六. popclient变成了Fetchmail"></a>六. popclient变成了Fetchmail</h3><p>这个工程的真正转折点是Harry Hochleiser寄给我他写的代码草稿，他把邮件转发到客户端机器的SMTP端口，我立即意识到这个特征的可靠实现将淘汰所有其他的递送模式。</p><p>几个星期以来我一直在修改而不是改进fetchmail，因为我觉得界面设计虽然有用但是太笨拙琐碎了，到处充满了太多的粗陋的细小选项。</p><p>当 我思考SMTP转发时我发现popclient试图做的事太多了，它被设计成既是一个邮件传输代理(MTA)也是一个本地递送代理(MDA)。使用 SMTP转发，它就可以从MDA的事务中解脱出来而成为一个纯MTA，而象sendmail一样把邮件交给本地递送程序来处理。</p><p>既然端口25在所有支撑TCP／IP的平台上早已被预留，为什么还要为一个邮件传输代理的配置或为一个邮箱设置加锁的附加功能而操心呢?尤其是当这意味着抽取的邮件就象一个正常的发送者发出的SMTP邮件一样，而这就是我们需要的。</p><p>这里有几个教益：第一，SMTP转发的想法是我有意识地模拟Linus的方法以来的最大的单个回报，一个用户告诉我这个非同寻常的想法——我所需做的只是理解它的含义。</p><ol><li>想出好主意是好事，从你的用户那里发现好主意也是好事，有时候后者更好。</li></ol><p>很 有趣的是，你很快将发现，如果你完全承认你从其他人那里得到多少教益的话，整个世界将会认为所有的发明都是你做出的，而你会对你的天才变得谦虚。我 们可以看到这在Linus身上体现得多明显!(当我在1997年8月的Perl会议上发表这个论文时，Larry Wall坐在前排，当我讲到上面的观点时，他激动的叫了出来：“对了!说对了!哥们!”所有的听众都哄堂大笑起来，因为他们知道同样的事情也发生在 Perl的发明者身上)。</p><p>于是在同样精神指导下工程进行了几个星期，我开始不光从我的用户那儿也从听说我的系统的人那儿得到类似的赞扬，我把一些这种邮件收藏起来，我将在我开始怀疑自己的生命是否有价值时重新读读这些信。:)但是有两个更基本的，非政治性的对所有设计都有普遍意义的教益。</p><ol><li>最重要和最有创新的解决方案常常来自于你认识到你对问题的概念是错误的。</li></ol><p>一个衡量fetchmail成功的有趣方式是工程的beta测试人员表(fegtchmail的朋友们)的长度，在创立它的时候已经有249个成员了，而且每个星期增加两到三个。</p><p>实 际上，当我在1997年5月校订它时，这张表开始因为一个有趣的原因而缩短了，有几个人请求我把他们从表中去掉，因为fetchmail已经工作的如此 之好，他们不需要看到这些邮件了!也许这是一个成熟的市集风格工程的生命周期的一部分。我以前一直在解决错误的问题，把popclient当作MTA和具 有许多本地递送模式的MDA的结合物，Fetchmail的设计需要从头考虑为一个纯的MTA，做为一个普通Internet邮件路径的一部分。</p><p>当你在开发中碰了壁时(当你发现自己很难想通下一步时)，那通常不是要问自己是否找到正确答案，而是要问是否问了正确问题，也许需要重新构造问题。</p><p>于是，我重新构造了我的问题，很清楚，要做的正确的事是(1)把SMTP转发支持放在通用驱动程序中，(2)把它做为缺省模式，(3)最终分离所有其他的递送模式，尤其是递送到文件和标准输出的选项。</p><p>我在第三步上犹豫了一下，担心会让popdiant的长期用户对新的递送方法感到烦心，在理论上，他们可以立即转而转发文件或者他们的非sendmail等价物来得到同样的效果，在实际中这种转换可能会很麻烦。</p><p>但是当我这么做之后，证明好处是巨大的，驱动程序代码的冗余的部分消失了，配置完全变得简单了——不用屈从于系统MDA和用户的邮箱，也不用为下层OS是否支持文件锁定而担心了。</p><p>而 且，丢失邮件的唯一漏洞也被堵死了，如果你选择了递送到一个文件而磁盘已满，你的邮件就会丢失，这在SMTP转发中不会发生，因为SMTP侦听器不会返 回OK的，除非邮件可以递送成功或至少被缓冲留待以后递送。还有，性能也改善了(虽然在单次执行中你不会注意到)，这个修改的另一个不可忽视的好处是手册 变得大大简单了。后来，为了允许处理一些罕见的情况，包括动态SLIP，我必须回到让用户定义本地MDA递送上来，但是我发现了一个更加简单的方法。</p><p>所有这些给了我们什么启发呢?如果可以不损失效率，就要毫不犹豫抛弃陈旧的特性，Antonine de Saint-Exupery(在他成为经典儿童书籍作家之前是一个飞行员和飞机设计师)曾说过：</p><ol><li>“最好的设计不是再也没有什么东西可以添加了，而是再也没有什么东西可以去掉。”</li></ol><p>当 你的代码变得更好和更简单时，这就是你知道它是正确的时候了，而且在这个过程中，fetehmail的设计具有了自己的特点，而区别于其前身 popclient。现在是改名的时候了，这个新的设计看起来比老popclient更象一个sendmail的复制品，它们都是MTA，但是 Senmail是推然后递送，而新的popclient是拉然后递送。于是，在两个月之后，我把它重新命名为fetehmail。</p><h3 id="七-Fetchmail成长起来"><a href="#七-Fetchmail成长起来" class="headerlink" title="七. Fetchmail成长起来"></a>七. Fetchmail成长起来</h3><p>现 在我有了一个简洁和富有创意的设计，工作得很好的代码，因为我每天都用它，和一直在增长的beta表，它让我渐渐明白我已经不是在从事只能对少数其他人 有用的工作中，我写了一个所有有一个Unix邮箱和SLIP／PPP邮件连接的人都真正需要的程序。通过SMTP转发功能，它成为一个潜在的“目录杀 手”，远远领先于它的竞争者，这个程序如此能干以至于其他的程序不但被放弃简直被忘记了。</p><p>我知道你不可以真得瞄准或计划出这样的结果，你只能努力去设计这些强大的思想，以后这些结果就好象是不可避免的、自然的、注定了的，得到这种思想的唯一办法是获取许多思想，或者用工程化的思考其他人的好主意而超过原来想到它的人的设想。</p><p>Andrew Tanenbanm原来设想建造一个适合386的简单的Unix用做教学，Linus Torvalels把Andrew的可能想到的Minix可以做什么的概念推进了一步，成长为一个极好的东西，同样的(虽然规模较小)，我接受了Card Harris和Harry Hochheiser的想法，把它们变得更强大，我们都不是人们所浪漫幻想的天才的创始人，但是大多数科学和工程和软件开发不是被天才的创始人完成的，这 和流传的神话恰恰相反。</p><p>结果总是执着的原因——实际上，它是每个黑客为之生存的成功!而且它们意味着我必须把自己的标准定高一点，为了把 fetchmail变得和我所能设想 的那样好，我必须不仅为我自己的需要写代码，而且也要包括对在我生活围主页外的人们的需求的支持，而且同时也要保证程序的简单和健壮。在实现它之后我首先 写的最重要的特征是支持多投——从集中一组用户的邮件的邮箱中取出邮件，然后把它路由到每个人手中。</p><p>我之所以加上多投功能部分是因为有些用户一直在闹着要它，更是因为我想它可以从单投的代码中揭露出错误来，让我完全一般地处理寻址，而且这被证明了。 正确解释RFC822花了我相当长的时间，不仅因为它的每个单独部分都很难，而且因为它有一大堆相互依赖的苛刻的细节。</p><p>但是多投寻址也成为一个极好的设计决策，由此我知道：</p><ol><li>任何工具都应该能以预想的方式使用，但是一个伟大的工具提供你没料到的功能。</li></ol><p>Fetchmant多投功能的一个没有料到的用途是在SLIP／PPP的客户端提供邮件列表、别名扩展。这意味着一个使用个人机器的人不必持续访问 ISP的别名文件就能通过一个ISP帐户管理一个邮件列表。我的beta测试员提出的另一个重要的改变是支持8位MIME操作，这很容易做，因为我已经仔 细的保证了8位代码的清晰，不仅因为我预见到了这个特性的需求，而且因为我忠实于另一准则：</p><p>15. 当写任何种类的网关型程序时，多费点力，尽量少干扰数据流，永远不要抛弃信息，除非接收方强迫这么作!</p><p>如果我不遵从这个准则，那么8位MIME支持将会变得困难和笨拙，现在我所需要做的，是只读一下RFC 1652，在产生信头的逻辑加上一点而已。</p><p>一些欧洲用户要求我加上一个选项来限制每次会话取得消息数(这样他们就可以从昂贵的电话网中控制花费了)，我很长一段时间拒绝这样做，而且我仍然对它不很高兴，但是如果你是为了世界而写代码，你必须听取顾客的意见——这并不随他们不付给你钱而改变。</p><h3 id="八-从Fetchmail得来的另一些教益"><a href="#八-从Fetchmail得来的另一些教益" class="headerlink" title="八. 从Fetchmail得来的另一些教益"></a>八. 从Fetchmail得来的另一些教益</h3><p>在他们回到一般的软件工程问题以前，还有几个从fetchmail得到的教益需要思考。</p><p>rc文件语法包括可选的“noise”关键字，它被扫描器完全忽略了，当你把它们全抽取出的时候，关键字／值对 更具可读性。当我注意到rc文件的声明在多大程度上开始象一个微型命令语言时，这是一个Late-night的体验(这也是我为什么把popclient 原来的“server”关键字改成了“poll”)。</p><p>对我来说似乎把这个微型命令语言变得更象英语可能会使它更容易使用。现在，虽然我对经过Emacs和HTML及 许多数据库引擎所证实的“把它做成一个语言”的设计方式确信不疑，但是我并不是一个通常的“类英语”语法的狂热拥护者。传统程序员容易控制语法使它尽量精 确和紧凑，完全没有冗余，这是计算机资源还很昂贵时遗留下的一种文化传统，所以扫描策略需要尽可能的廉价和简单，而具有50%冗余度的英语，看来好象是一 个非常不合适的模型。</p><p>这并不是我不用类英语语法的原因，我提到这一点是为了推翻它，在更廉价的时钟周期与核心的时代，简洁并没有走到尽头，今天对一个语言来说，对人更方便比对机器更廉价来的更加重要。</p><p>然而，有几个原因提醒我们小心一点，一个是扫描策略的复杂度开销——你并不想把它变成一个巨大的错误来源和让用户困惑，另一个是试图使语言表面上的类似可以和传统语言一样令人困惑(你可以在许多4GL和商业数据库查询语言上看到这一点)。</p><p>Fetchmail的控制语法避免了这些问题，因为语言的领域是极其有限的。它一点也不象一个一般性的语言，它很简单地描述的东西并不复杂，所以很少可能在英语的一个小子集与实际的控制语言之间发生混淆，我想这有一个更广泛的教益：</p><p>16. 如果你的语言一点也不象是图灵完备的，严格的语法会有好处。</p><p>另一个教益是关于安全的，一些fetchmail用户要求我修改软件把口令加密存贮在rc文件里，这样觑探者就 不能看到它们了。我没有这样做，因为这实际上起不到任何保护作用，任何有权读取你的rc文件的人都可以以你的名义运行fetchmail——如果他们要破 你的口令，它们可以从fetchmail的代码中找到制作解码器的方法。</p><p>所以fetchmail口令的加密都会给那些不慎重思考的人一种安全的错觉，这里一般性的准则是：</p><p>17. 一个安全系统只能和它的秘密一样安全，当心伪安全。</p><h3 id="九-集市风格的必要的先决条件"><a href="#九-集市风格的必要的先决条件" class="headerlink" title="九. 集市风格的必要的先决条件"></a>九. 集市风格的必要的先决条件</h3><p>本文的早期评审人员和测试人员坚持提出成功的市集模式开发的先决条件，包括工程领导人的资格问题和在把项目公开和开始建造一个协作开发人员的社团的时候代码的状态。</p><p>相当清楚，不能以一个市集模式从头开发一个软件，我们可以以市集模式、测试、调试和改进，但是以市集模式从头开始一个项目将是非常困难的，Linus没有这样做，我也没有，初期的开发人员的社团应该有一此可以运行和测试的东西来玩。</p><p>当你开始创建社团时，你需要演示的是一个诺言，你的程序不需要工作的很好，它可以很粗糙、很笨拙、不完整和缺少文档、它不能忽略的东西是要吸引哪些人卷入一个整洁的项目。</p><p>Linux和fetchmail都是以一个吸引人的基本设计进入公共领域的，许多和我一样在思考市集模式的人已经正确的认为这是非常关键的，然后得出了一个结论，工程领导者的高度的设计直觉和聪颖是必不可少的。</p><p>但是Linus是从Unix得到他的设计的，我最初是从先前的popmail得到启发的(虽然相对Linux而言，它最后改变巨大)，所以市集风格的领导人／协调人需要有出众的设计才能，或者他可以利用别人的设计才能?</p><p>我认为能够提出卓越的原始设计思想对协调人来说不是最关键的，但是对他／她来说绝对关键的是要能把从他人那里得到的好的设计重新组织起来。</p><p>Linux和fetchmail项目都显示了这些证据，Linus(如同前面所说)并不是惊人的原始设计者，但他显示了发现好的设计并把它集成到 Linux内核中的强大决窍。还有我也描述了怎样从别人那里得到了fetchmail中最强大的设计思想(SMTP转发)。</p><p>本文的早期读者称赞我，说因为我做了许多关于原始设计的事，所以倾向于低估原始设计在市集项目中的价值，也许有些是对的吧，但是设计(而不是编码或调试)本来就是我最强的能力。</p><p>变得聪明和软件设计的原始创作的问题是它会变成一个习惯，当需要保持事物健壮和简洁的时候，你却开始把事情变得漂亮但却复杂。我曾经犯过错误，使得一些项目因我而崩溃了，但我努力不让它发生在fetchmail身上。</p><p>所以我相信fetchmail项目的成功部分是因为我抑制自己不要变得太聪明，这说明(至少)对市集模式而言原 始设计并不是本质的，请考察一下Linux假设Linus Torvalds在开发时试图彻底革新操作系统设计，它还会象今天我们所拥有的内核那样稳定和成功吗?</p><p>当然基本的设计和编码技巧还是必需的，但我希望每个严肃考虑发起一个市集计划的人都已至少具备这些能力，自由软件社团的内部市场对人们有某些微妙的压力，让他们不要发起自由不能搞定的开发，目前为止，这工作得仍然相当好。</p><p>对市集项目来说，我认为还有另一种通常与软件开发无关的技能和设计能力同样重要——或者更加重要，市集项目的协调人或领导人必须有良好的人际和交流能力。</p><p>这是很显然的，为了建造一个开发社团，你需要吸引人，你所做的东西要让他们感到有趣，而且要保持他们对他们正在做的工作感到有趣，而且要保持他们对他们正在做的工作感到高兴，技术方面对达成这些目标有一定帮助，但这远远不是全部，你的个人素质也有关系。</p><p>并不是说Linus是一个好小伙子，让人们喜爱并乐于帮助他，也并不是说我是个积极外向的，喜欢扎堆儿工作，有出众的幽默感的人，对市集模式的工作而言，至少有一点吸引人的技巧是非常有帮助的。</p><p>十. 自由软件的社会学语境</p><p>下述如实：最好的开发是从作者解决每天工作中的个人问题开始的，因为它对一大类用户来说是一个典型问题，所以它就推广开来了，这把我们带回到准则1，也许是用一个更有用的方式来描述：</p><p>18. 要解决一个有趣的问题，请从发现让你感兴趣的问题开始。</p><p>这 是Carl Harris和原先的popclient的情形，也是我和fetchmail的情形，但这已在很长一段时间被大家知晓了，Linux和fetchmail 的历史要求我们注意的有趣之处是下一个阶段——软件在一个庞大的活跃的用户和协作开发人员的社团中的进化。</p><p>在《人月神话》一书 中，Fred Brooks观察到程序员的工作时间是不可替代的：在一个误了工期的软件项目中增加开发人员只会让它拖得更久，他声称项目的复杂度和通讯开销以开发人员的 平方增长，而工作成绩只是以线性增长，这个说法被称为“Brooks定律”，被普遍当作真理，但如果Brooks定律就是全部，那Linux就不可能成 功。</p><p>几年之后，Gerald Weinbeng的经典之作“The Psychology Of Computer Progromming”为我们更正了Brooks的看法，在他的“忘我(egoless)的编程”中，Weinberg观察到在开发人员不顽固保守自己 的代码，鼓励其他人寻找错误和发展潜力的地方，软件的改进的速度会比其他地方有戏剧性的提高。</p><p>Weinberg的用词可阻止了他的分析得到应有的接受，人们对把Internet黑客称为“忘我”的想法微笑，但是我想今天他的想法比以往任何时候都要引人注目。</p><p>Unix 的历史已经为我们准备好了我们正在从Linux学到的(和我在更小规模上模仿Linus的方法所验证的)东西，这就是，虽然编码仍是一个人干 的活，真正伟大的工作来自于利用整个社团的注意和脑力，在一个封闭的项目中只利用他自己的脑力的人会落在知道怎样创建一个开放的、进化的，成百上千的人在 其中查找错误和进行修改的环境的开发人员之后。</p><p>但是Unix的传统中有几个因素阻止把这种方法推到极致。一个是各种授权的法律约束、商业机密和商业利益，另一个(事后来看)是Internet还不够好。</p><p>在Internet变得便宜之前，有一些在地理上紧密的社团，它们的文化鼓励Weingberg的“忘我”编程，一个开发人员很容易吸引许多熟练的人和协 作开发人员，贝尔实验室，MIT A1实验室，UC Berkeley，都成为传统的、今天仍然是革新的源泉。</p><p>Linux 是第一个有意识的成功的利用整个世界做为它的头脑库的项目，我不认为Linux的孕育和万维网的诞生相一致是一个巧合，而且Linux在 1993-1994的一段ISP工业大发展和对Internet的兴趣爆炸式增长的时期中成长起来，Linus是第一个学会怎样利用Internet的新 规的人。</p><p>廉价的Internet对Linux模式的演化来说是一个必要条件，但它并不充分，另一个关键因素是领导风格的开发和一套协作的氛围使开发人员可以吸引协作开发人员和最大限度地利用媒体。</p><p>但 是这种领导风格与氛围到底是什么呢?它不能建立在权力关系之上——甚至如果它们可以，高压的领导权力不能产生我们所看到的结果，Weinberg引用了 19世纪俄国的无政府主义者Kropotkin的“Memoris of a Revolutionist”来证明这个观点：</p><p>“我从小生 活在一个农奴主的家庭中，我有一个活跃的生活，象我们时代的所有年轻人一样，我深信命令、强制、责骂、惩罚等等的必要性。但是当我(在早 期)必须管理一个企业，和(自由)人打交道时，当每一个错误都会产生严重后果时，我开始接受以命令和纪律为准则来行动和以普通理解为准则来行动的区别。前 者在军事阅兵中工作的很好，但是它在现实生活中一文不值，目标达成只是靠许多愿望的聚合的简单后果。”“许多聚合在一起的愿望的直接后果”精确地指出了象 Linux的项目所需要的东西。“命令的准则”在Internet这种无政府主义的天堂中一群自愿者之中是没有市场的，为了更有效的操作和竞争，想领导协 作项目的黑客们必须学会怎样以Kropotkins含糊指出的“理解的准则”模式来恢复和激活社团的力量，他们必须学会使用Linus定律。</p><p>前 面我引用“Delhpi效应”来作为Linus定律的一个可能的解释，但是来自生物学和经常学的自适应系统的更强大的分析也提出了自己的解释， Linus世界的行为更象一个自由市场或生态系统，由一大群自私的个体组成，它们试图取得(自己)最大的实效，在这个过程中产生了比任何一种中央计划都细 致和高效的自发的改进的结果，所以，这里就是寻找“理解的准则”的地方。</p><p>Linux黑客取得的最大化的“实际利益”不是经典的经济利益， 而是无形的他们的自我满足和在其他黑客中的声望，(有人会说他们的动机是“利他的”， 但这忽略了这样的事实：利他主义本身是利他主义者的一种自我满足的形式)，自愿的文化以这种方式工作的实际上并非不寻常，我已参与一个科幻迷团体很长时间 了，它不象黑客团体一样，显式地识别出“egoboo”(一个人在其他爱好者之中的声望的增长)作为自愿者活动背后的基础驱动力)。</p><p>Linus成功地把自己置于项目的守门人的位置，在项目中开发大部分是别人做的，他只是在项目中培养兴趣直到它可以自己发展下去，这为我们展示了对 Kropokin的“共同理解原则”的敏锐把握，对Linux这种类似经济学的观点让我们看到这种理解是怎样应用的。</p><p>我 们可以把Linus的方法视为创建一个高效的关于“egoboo”(而不是钱)的市场，来把自私的黑客个体尽可能紧密的联系起来，达成只能通过高度 协作才能得到的困难的结果，在fetchmail项目中我展示了(在较小规模上)这种模式可以复制，得到良好的结果，也许我比他更有意识一点、更加系统一 点。</p><p>许多人(尤其是哪些由于政治原因不信任自由市场的人)会盼望自我导向的自我主义者的文化破碎、报废、秘密和敌对，但这种盼望很明显地 被Linux的文 档的多样性、质量和深度打破了，程序员讨厌写文档似乎已是圣训，但Linux的黑客们怎么产生了这么多?显然Linux的egoboo自由市场比有大量资 金的商业软件产品的文档部在产生有品德的、他人导向的行为方面工作的更好。</p><p>Fetchmail和Linux内核项目都表明，通过恰当的表彰许多其他黑客，一个强大的开发者／协调者可以用Internet得到许多协同开发人员而不是让项目分崩离析为一片混乱，所以关于Brooks定律我得到了下面的想法：</p><ol><li>如果开发协调人员有至少和Internet一样好的媒介，而且知道怎样不通过强迫来领导，许多头脑将不可避免地比一个好。</li></ol><p>我认为自由软件的将来将属于那些知道怎样玩Linus的游戏的人，把大教堂抛之脑后拥抱市集的人，这并不是说个人的观点与才气不再重要，而是，我认为自由软件的前沿将属于从个人观点和才气出发的人，然后通过共同兴趣自愿社团的高效建造来扩展。</p><p>可能不只是自由软件的将来，在解决问题方面，没有任何商业性开发者可以与Linux社团的头脑库相匹敌，很少有人能负担起雇佣200多个为fetchmail出过力的人! 　　也许最终自由软件文化将胜利，不是因为协作在道德上是正确的或软件“囤积居奇”在道德上是错的(假设你相信后者，Linus和我都不)，而仅仅是因为商业世界在进化的军备竞赛中不能战胜自由软件社团，因为后者可以把更大更好的开发资源放在解决问题上。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Master-boot-record]]></title>
      <url>http://fengchao.github.io/2016/05/27/Master-boot-record/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>硬盘的0磁道的第一个扇区称为MBR，它的大小是512字节，而这个区域可以分为三个部分。第一部分为pre-boot区（预启动区），占446字节；第 二部分是分区表（Partition Table），占64个字节，硬盘中分区有多少以及每一分区的大小都记在其中。第三部分是magic<br>number，占2个字节，固定为55AA。</p><p>MBR 通常由 fdisk 等类似命令创建，系统上电自检之后，会调用 INT 19 中断(CTRL+ALT+Delete 同样引发这个中断) 。INT 19 会查找活动分区(用第一个字符为 80标记) 载入并跳转到 0000:7C00 开始执行程序。若未找到活动分区，则自动执行启动硬盘的 MBR 0000:7C00 地址程序。因为每个操作系统的启动区格式都不相同，所以这里的这段程序会查找操作系统的启动代码或者启动管理器例如 Grub 等。</p><p>以下是一个 MBR 的十六进制和ASCII码，后面会分段介绍具体内容。</p><pre><code>OFFSET 0 1 2 3 4 5 6 7 8 9 A B C D E F *0123456789ABCDEF*
000000 fa33c08e d0bc007c 8bf45007 501ffbfc *.3.....|..P.P...*
000010 bf0006b9 0001f2a5 ea1d0600 00bebe07 *................*
000020 b304803c 80740e80 3c00751c 83c610fe *...&lt;.t..&lt;.u.....*
000030 cb75efcd 188b148b 4c028bee 83c610fe *.u......L.......*
000040 cb741a80 3c0074f4 be8b06ac 3c00740b *.t..&lt;.t.....&lt;.t.*
000050 56bb0700 b40ecd10 5eebf0eb febf0500 *V.......^.......*
000060 bb007cb8 010257cd 135f730c 33c0cd13 *..|...W.._s.3...*
000070 4f75edbe a306ebd3 bec206bf fe7d813d *Ou...........}.=*
000080 55aa75c7 8bf5ea00 7c000049 6e76616c *U.u.....|..Inval*
000090 69642070 61727469 74696f6e 20746162 *id partition tab*
0000a0 6c650045 72726f72 206c6f61 64696e67 *le.Error loading*
0000b0 206f7065 72617469 6e672073 79737465 * operating syste*
0000c0 6d004d69 7373696e 67206f70 65726174 *m.Missing operat*
0000d0 696e6720 73797374 656d0000 00000000 *ing system......*
0000e0 00000000 00000000 00000000 00000000 *................*
0000f0 TO 0001af SAME AS ABOVE
0001b0 00000000 00000000 00000000 00008001 *................*
0001c0 0100060d fef83e00 00000678 0d000000 *......&gt;....x....*
0001d0 00000000 00000000 00000000 00000000 *................*
0001e0 00000000 00000000 00000000 00000000 *................*
0001f0 00000000 00000000 00000000 000055aa *..............U.*
</code></pre><p>上面代码反汇编的结果如下：1. 首先，代码会把自己复制到 0000:0600BEGIN: NOW AT 0000:7C00, RELOCATE</p><pre><code>0000:7C00 FA CLI disable int&apos;s
0000:7C01 33C0 XOR AX,AX set stack seg to 0000
0000:7C03 8ED0 MOV SS,AX
0000:7C05 BC007C MOV SP,7C00 set stack ptr to 7c00
0000:7C08 8BF4 MOV SI,SP SI now 7c00
0000:7C0A 50 PUSH AX
0000:7C0B 07 POP ES ES now 0000:7c00
0000:7C0C 50 PUSH AX
0000:7C0D 1F POP DS DS now 0000:7c00
0000:7C0E FB STI allow int&apos;s
0000:7C0F FC CLD clear direction
0000:7C10 BF0006 MOV DI,0600 DI now 0600
0000:7C13 B90001 MOV CX,0100 move 256 words (512 bytes)
0000:7C16 F2 REPNZ move MBR from 0000:7c00
0000:7C17 A5 MOVSW to 0000:0600
0000:7C18 EA1D060000 JMP 0000:061D jmp to NEW_LOCATION
</code></pre><ol><li>从分区表中查找活动分区</li></ol><p>设置表指针</p><pre><code>NEW_LOCATION: NOW AT 0000:0600
0000:061D BEBE07 MOV SI,07BE point to first table entry
0000:0620 B304 MOV BL,04 there are 4 table entries
</code></pre><p>第一遍查找</p><pre><code>SEARCH_LOOP1: SEARCH FOR AN ACTIVE ENTRY

0000:0622 803C80 CMP BYTE PTR [SI],80 is this the active entry?
0000:0625 740E JZ FOUND_ACTIVE yes
0000:0627 803C00 CMP BYTE PTR [SI],00 is this an inactive entry?
0000:062A 751C JNZ NOT_ACTIVE no
0000:062C 83C610 ADD SI,+10 incr table ptr by 16
0000:062F FECB DEC BL decr count
0000:0631 75EF JNZ SEARCH_LOOP1 jmp if not end of table
0000:0633 CD18 INT 18 GO TO ROM BASIC
</code></pre><p>找到活动分区</p><pre><code>FOUND_ACTIVE: FOUND THE ACTIVE ENTRY

0000:0635 8B14 MOV DX,[SI] set DH/DL for INT 13 call
0000:0637 8B4C02 MOV CX,[SI+02] set CH/CL for INT 13 call
0000:063A 8BEE MOV BP,SI save table ptr
</code></pre><p>第二遍查找以保证只有一个活动分区</p><pre><code>SEARCH_LOOP2: MAKE SURE ONLY ONE ACTIVE ENTRY

0000:063C 83C610 ADD SI,+10 incr table ptr by 16
0000:063F FECB DEC BL decr count
0000:0641 741A JZ READ_BOOT jmp if end of table
0000:0643 803C00 CMP BYTE PTR [SI],00 is this an inactive entry?
0000:0646 74F4 JZ SEARCH_LOOP2 yes
</code></pre><p>无活动分区，则打印信息，挂起系统</p><pre><code>NOT_ACTIVE: MORE THAN ONE ACTIVE ENTRY FOUND

0000:0648 BE8B06 MOV SI,068B display &quot;Invld prttn tbl&quot;

DISPLAY_MSG: DISPLAY MESSAGE LOOP

0000:064B AC LODSB get char of message
0000:064C 3C00 CMP AL,00 end of message
0000:064E 740B JZ HANG yes
0000:0650 56 PUSH SI save SI
0000:0651 BB0700 MOV BX,0007 screen attributes
0000:0654 B40E MOV AH,0E output 1 char of message
0000:0656 CD10 INT 10 to the display
0000:0658 5E POP SI restore SI
0000:0659 EBF0 JMP DISPLAY_MSG do it again

HANG: HANG THE SYSTEM LOOP

0000:065B EBFE JMP HANG sit and stay!
</code></pre><ol><li><p>找到活动分区之后，会读取启动信息</p><pre><code>READ_BOOT: READ ACTIVE PARITION BOOT RECORD

0000:065D BF0500 MOV DI,0005 INT 13 retry count

INT13RTRY: INT 13 RETRY LOOP

0000:0660 BB007C MOV BX,7C00
0000:0663 B80102 MOV AX,0201 read 1 sector
0000:0666 57 PUSH DI save DI
0000:0667 CD13 INT 13 read sector into 0000:7c00
0000:0669 5F POP DI restore DI
0000:066A 730C JNB INT13OK jmp if no INT 13
0000:066C 33C0 XOR AX,AX call INT 13 and
0000:066E CD13 INT 13 do disk reset
0000:0670 4F DEC DI decr DI
0000:0671 75ED JNZ INT13RTRY if not zero, try again
0000:0673 BEA306 MOV SI,06A3 display &quot;Errr ldng systm&quot;
0000:0676 EBD3 JMP DISPLAY_MSG jmp to display loop

INT13OK: INT 13 ERROR

0000:0678 BEC206 MOV SI,06C2 &quot;missing op sys&quot;
0000:067B BFFE7D MOV DI,7DFE point to signature
0000:067E 813D55AA CMP WORD PTR [DI],AA55 is signature correct?
0000:0682 75C7 JNZ DISPLAY_MSG no
0000:0684 8BF5 MOV SI,BP set SI
0000:0686 EA007C0000 JMP 0000:7C00 JUMP TO THE BOOT SECTOR
WITH SI POINTING TO
PART TABLE ENTRY
</code></pre></li><li><p>后面是一些显示字符</p><pre><code>0000:0680 ........ ........ ......49 6e76616c * Inval*
0000:0690 69642070 61727469 74696f6e 20746162 *id partition tab*
0000:06a0 6c650045 72726f72 206c6f61 64696e67 *le.Error loading*
0000:06b0 206f7065 72617469 6e672073 79737465 * operating syste*
0000:06c0 6d004d69 7373696e 67206f70 65726174 *m.Missing operat*
0000:06d0 696e6720 73797374 656d00.. ........ *ing system. *
</code></pre></li><li><p>接着是一段没有用的空区域</p><pre><code>0000:06d0 ........ ........ ......00 00000000 * .....*
0000:06e0 00000000 00000000 00000000 00000000 *................*
0000:06f0 00000000 00000000 00000000 00000000 *................*
0000:0700 00000000 00000000 00000000 00000000 *................*
0000:0710 00000000 00000000 00000000 00000000 *................*
0000:0720 00000000 00000000 00000000 00000000 *................*
0000:0730 00000000 00000000 00000000 00000000 *................*
0000:0740 00000000 00000000 00000000 00000000 *................*
0000:0750 00000000 00000000 00000000 00000000 *................*
0000:0760 00000000 00000000 00000000 00000000 *................*
0000:0770 00000000 00000000 00000000 00000000 *................*
0000:0780 00000000 00000000 00000000 00000000 *................*
0000:0790 00000000 00000000 00000000 00000000 *................*
0000:07a0 00000000 00000000 00000000 00000000 *................*
0000:07b0 00000000 00000000 00000000 0000.... *............ *
</code></pre></li><li><p>后面是分区表信息，启示位置为 0000:07be，每个分区表占16字节，这里只有一个主分区，开头的 80 表明这是一个启动分区。</p><pre><code>0000:07b0 ........ ........ ........ ....8001 * ....*
0000:07c0 0100060d fef83e00 00000678 0d000000 *......&gt;....x....*
0000:07d0 00000000 00000000 00000000 00000000 *................*
0000:07e0 00000000 00000000 00000000 00000000 *................*
0000:07f0 00000000 00000000 00000000 0000.... *............ *
</code></pre></li><li><p>最后是 55AA 标记</p><pre><code>0000:07f0 ........ ........ ........ ....55aa *..............U.*
</code></pre></li></ol><p>如果奇怪为什么用 55AA 这个值，写成二进制就清楚了：</p><pre><code>0x55aa=(0101010110101010)2
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux From Scratch]]></title>
      <url>http://fengchao.github.io/2016/05/27/Linux-From-Scratch/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>2007-05-11 15:34</p><p>花了两天半的时间，搞完了 Linux from Scratch ，对编译器、系统、编译器之间的鸡生蛋、蛋生鸡的问题有了实际的认识。</p><p>基本按步骤一步一步来的，更多的时间是等待编译，只不过在最后的时候 Grub 没有重写 MBR，而是直接在 现有系统上加了一个启动项。</p><p>手动添加</p><pre><code>Wincat &gt;&gt; /boot/grub/menu.lst &lt;&lt; &quot;EOF&quot;
title Windows
rootnoverify (hd0,0)
chainloader +1
EOF
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用命令讲故事]]></title>
      <url>http://fengchao.github.io/2016/05/27/cmd-story/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><img src="/images/command_Story.jpg" alt="picture alt" title="Title is optional"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[pkgconfig]]></title>
      <url>http://fengchao.github.io/2016/05/27/pkgconfig/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>2008-06-20 09:59<br>你在Unix下开发过软件吗？写完一个程序，编译运行完全正常，在你本机上工作得好好的，你放到源代码管理系统中。然后，告诉你的同事说，你可以取下来用了。这时，你长长的出了一口气，几天的工作没有白费，多么清新的空气啊，你开始飘飘然了。</p><p>“Hi，怎么编译不过去？”你还沉浸在那种美妙的感觉之中，双臂充满着力量，似乎没有什么问题能难倒你的。正在此时，那个笨蛋已经冲着你嚷开了。</p><p>“不会吧，我这边好好的！”表面上你说得很客气，其实，你心里已经骂开了，真笨，不知道脑子干嘛用的。也许，你想的没错，上次，他犯了一个简单的错误，不是你一去就解决了吗。</p><p>他喊三次之后，你不得不放下你手上的工作，刚才那种美妙的感觉已经消失得无影无踪了，要不是你把情绪控制得很好，一肚子气就要撒在他身上了。你走到他的电脑前，键入make，优雅的按下回车。怎么可能出错呢？你信心十足。然而，屏幕上的结果多少有点让人脸红，该死的，libxxx.so怎么会让不到呢？</p><p>你在/usr目录中查找libxxx.so，一切都逃不过你的眼睛。奇怪，libxxx.so怎么在/usr/local/lib下，不是应该在/usr/lib下的吗？这你可不能怪别人，别人想安装在哪里都行，下次还可能安装到/lib目录下呢。</p><p>以 上的场景并非虚构，我都经历过好几次，明明在本机上好好的，在别人的机器上连编译都过不去。可能两人的操作系统一模一样，需要的库都安装上，只是由于个人 喜好不同，安装在不同的目录而已。遇到这种情况，每次都技巧性的绕过去了，用的补丁型的方法，心里老惦记其它地方能不能工作。</p><p>今天我们要介绍的pkgconfig，为解决以上问题提供了一个优美方案。从此，你再也不为此担忧了。Pkgconfig提供了下面几个功能：</p><ul><li>检查库的版本号。如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件。</li><li>获得编译预处理参数，如宏定义，头文件的位置。</li><li>获得链接参数，如库及依赖的其它库的位置，文件名及其它一些连接参数。</li><li>自动加入所依赖的其它库的设置。</li></ul><p>这一切都自动的，库文件安装在哪里都没关系！</p><p>在使用前，我们说说pkgconfig的原理，pkgconfig并非精灵，可以凭空得到以上信息。事实上，为了让pkgconfig可以得到这些信息，要求库的提供者，提供一个.pc文件。比如gtk+-2.0的pc文件内容如下：</p><pre><code>prefix=/usr

exec_prefix=/usr

libdir=/usr/lib

includedir=/usr/include

target=x11

gtk_binary_version=2.4.0

gtk_host=i386-redhat-linux-gnu

Name: GTK+

Description: GIMP Tool Kit (${target} target)

Version: 2.6.7

Requires: gdk-${target}-2.0 atk

Libs: -L${libdir} -lgtk-${target}-2.0

Cflags: -I${includedir}/gtk-2.0
</code></pre><p>这个文件一般放在/usr/lib/pkgconfig/或者/usr/local/lib/pkgconfig/里，当然也可以放在其它任何地方，如像X11相关的pc文件是放在/usr/X11R6/lib/pkgconfig下的。为了让pkgconfig可以找到你的pc文件，你要把pc文件所在的路径，设置在环境变量PKG_CONFIG_PATH里。</p><p>使用方法很简单，比如，我们要使用gtk+的库编译一个程序：</p><pre><code>gcc -g arrow.c -o arrow `pkg-config &quot;gtk+-2.0 &gt; 2.0.0&quot; --cflags --libs`
</code></pre><p>只要安装了gtk+2.0，不管它在哪里，编译都是正常的。这是不是简单很多了？</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[.designated_initializers = 指派初始化]]></title>
      <url>http://fengchao.github.io/2016/05/27/designated-initializers/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>2008-06-16 11:00 在设备驱动中常见下面这种语法格式，首先定义一堆函数指针，并根据不同的设备初始化为不同的实现函数，很像 C++ 里面的成员函数。</p><pre><code>struct file_operations scull_fops = {
          .owner = THIS_MODULE,
          .llseek = scull_llseek,
          .read = scull_read,
          .write = scull_write,
          .ioctl = scull_ioctl,
          .open = scull_open,
          .release = scull_release,
};
</code></pre><p>这种语法使用了指派初始化（designated_initializers ），使程序可以使不同的结构定义间的移植更加容易，代码更加精简易读。而且编译器可以根据需要改变结构成员的顺序，提升程序的性能。</p><p>以下内容摘自 gcc 手册</p><pre><code>In a structure initializer, specify the name of a field to initialize with `.fieldname =&apos; before the element value. For example, given the following structure,

struct point { int x, y; };
</code></pre><p>The following initialization</p><pre><code>struct point p = { 
    .y = yvalue, 
    .x = xvalue
};
</code></pre><p>is equivalent to</p><pre><code>struct point p = { xvalue, yvalue };
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vim 键盘图]]></title>
      <url>http://fengchao.github.io/2016/05/27/Vim-keyboard/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><img src="/images/vim.png" alt="picture alt" title="Vim cheetsheet"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[主板诊断卡]]></title>
      <url>http://fengchao.github.io/2016/05/27/Mother-board-debug-card/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>主板诊断卡也叫POST卡（Power On Self Test加电自检），其工作原理是利用主板中BIOS内部程序的检测结果，通过主板诊断卡代码一一显示出来，结合诊断卡的代码含义速查表就能很快地知道电 脑故障所在。尤其在PC机不能引导操作系统、黑屏、喇叭不叫时，使用本卡更能体现其便利，事半功倍。</p><p>主板上的BIOS在每次开机时，会对系统的电路、存储器、键盘、视 频部分、硬盘、软驱等各个组件时行严格测试，并分析硬盘系统配置，对已配置的基本I/O设置进行初始化，一切正常后，再引导操作系统。当计算机出现关键性 故障，屏幕上无显示时，很难判断计算机故障所在，此时可以将本卡插入扩充槽 内，根据卡上显示的代码，参照计算机所所属的BIOS种类，再通过主板诊断卡的代码含义速查表查出该代码所表示的故障原因和部位，就可清楚地知道故障所 在。</p><h2 id="DEBUG卡的工作原理"><a href="#DEBUG卡的工作原理" class="headerlink" title="DEBUG卡的工作原理"></a>DEBUG卡的工作原理</h2><p>DEBUG 卡的工作原理其实很简单，每个厂家的BIOS，无论是AWARD、AMI还是PHOENIX的，都有所谓的POST CODE，即开机自我侦测代码，当BIOS要进行某项测试动作时，首先将该POST CODE写入80h地址，如果测试顺利完成，再写入下一个POST CODE，因此，如果发生错误或死机，根据80H地址的POST CODE值，就可以了解问题出在什么地方。DEBUG 卡的作用就是读取80H地址内的POST CODE，并经译码器译码，最后由数码管显示出来。这样就可以通过DEBUG卡上显示的16进制代码判断问题出在硬件的那一部分，而不用仅依靠计算机主板 那几声单调的警告声来粗略判断硬件错误了。通过它可知道硬件检测没有通过的是内存还是CPU，或者是其他硬件，方便直观地解决棘手的主板问题。以此类推， 还可以判断超频的限制硬件是哪一个，做到有的放矢，查障无忧。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HelloWDM]]></title>
      <url>http://fengchao.github.io/2016/05/27/HelloWDM/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>2008-08-14 13:47<br>人生真是会开玩笑啊，作为自由软件的信徒，居然要研究 Windows 的驱动了。不过对比一下还是挺好的，<br>和 Linux 下面的驱动比起来，还是有许多相似的地方。不过这种函数缩进形式也太难看了，一个参数一行，<br>看了两天都没反应过来，头晕。</p><hr><p>WDM驱动程序是一种很新的东西，相信很多人都跟我一样，对它很感兴趣，但是又找不到学习的切入 点。究其原因，还是因为WDM是一种非常“死板板”的程 序，它一运行就是工作在系统的底层RING 0处，提供各种接口给应用程序调用。也正因为如此，它不像普通的应用程序一样，可以很快地上手——更多的时候，你是在阅读它的技术资料和各种接口信息，你 还要非常地熟悉系统底层的工作原理，否则一个不小心，就“蓝屏”了，呵呵——话说回来，写驱动程序的时候，死机是家常便饭。</p><p>因 此很多人都对WDM望而生畏了。回想一下，我刚开始学WDM的情形还历历在目——看书看了整整3天，但是看完之后好像跟没看也差不了多少，还是不知道怎么入门，甚至连怎么写一个“Hello World”都不知道——后来才知道其实WDM是没有所谓的“Hello World”程序的，唉，真是痛苦啊，这主要还是因为网络上的WDM资料太少造成的。为了不让大家重蹈我的覆辙并对WDM有个感性的认识，在此我给出一个 最简单的完整的WDM框架，并附有注释，姑且可以算是一个入门的“Hello World”吧。</p><p>废话少说，让我们马上开始研究，要求读者已安装DDK 2000。</p><pre><code>/***************************************************************
程序名称：Hello World for WDM
文件名称：HelloWDM.cpp
作者：罗聪
日期：2002-8-16
***************************************************************/

//一定要的头文件，声明了函数模块和变量：
#include &quot;HelloWDM.h&quot;

/***************************************************************
函数名称：DriverEntry()
功能描述：WDM程序入口
***************************************************************/
//extern &quot;C&quot;是必须的，表示“用C链接”。如果你的文件名是HelloWDM.c的话，这句可以省略。
extern &quot;C&quot;
NTSTATUS DriverEntry(     IN PDRIVER_OBJECT DriverObject,
                         IN PUNICODE_STRING RegistryPath)
{
    //指定“添加设备”消息由函数“HelloWDMAddDevice()”来处理：
     DriverObject-&gt;DriverExtension-&gt;AddDevice = HelloWDMAddDevice;
    //指定“即插即用”消息由函数“HelloWDMPnp()”来处理：
     DriverObject-&gt;MajorFunction[IRP_MJ_PNP] = HelloWDMPnp;

    //返回一个NTSTATUS值STATUS_SUCCESS。几乎所有的驱动程序例程都必须返回一个NTSTATUS值，这些值在NTSTATUS.H DDK头文件中有详细的定义。
    return STATUS_SUCCESS;
}

/***************************************************************
函数名称：HelloWDMAddDevice()
功能描述：处理“添加设备”消息
***************************************************************/
NTSTATUS HelloWDMAddDevice(IN PDRIVER_OBJECT DriverObject,
                           IN PDEVICE_OBJECT PhysicalDeviceObject)
{
    //定义一个NTSTATUS类型的返回值：
     NTSTATUS status;
    //定义一个功能设备对象（Functional Device Object）：
     PDEVICE_OBJECT fdo;

    //创建我们的功能设备对象，并储存到fdo中：
     status = IoCreateDevice(
         DriverObject,                //驱动程序对象
        sizeof(DEVICE_EXTENSION),    //要求的设备扩展的大小
         NULL,                        //设备名称，这里为NULL
         FILE_DEVICE_UNKNOWN,        //设备的类型，在标准头文件WDM.H或NTDDK.H中列出的FILE_DEVICE_xxx值之一
        0,                            //各种常量用OR组合在一起，指示可删除介质、只读等。
         FALSE,                        //如果一次只有一个线程可以访问该设备，为TRUE，否则为FALSE
        &amp;fdo);                        //返回的设备对象

    //NT_SUCCESS宏用于测试IoCreateDevice内核是否成功完成。不要忘记检查对内核的所有调用是否成功。NT_ERROR宏不等同于!NT_SUCCESS，最好使用!NT_SUCCESS，因为除了错误外，它还截获警告信息。
    if( !NT_SUCCESS(status))
        return status;

    //创建一个设备扩展对象dx，用于存储指向fdo的指针：
     PDEVICE_EXTENSION dx = (PDEVICE_EXTENSION)fdo-&gt;DeviceExtension;
     dx-&gt;fdo = fdo;

    //用IoAttachDeviceToDeviceStack函数把HelloWDM设备挂接到设备栈：
     dx-&gt;NextStackDevice = IoAttachDeviceToDeviceStack(fdo, PhysicalDeviceObject);

    // 设置fdo的flags。有两个“位”是必须改变的，一个是必须清除DO_DEVICE_INITIALIZING标志，如果在DriverEntry例 程中调用IoCreateDevice()，就不需要清除这个标志位。还有一个是必须设置DO_BUFFER_IO标志位：
     fdo-&gt;Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
     fdo-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;

    //返回值：
    return STATUS_SUCCESS;
}

/***************************************************************
函数名称：HelloWDMPnp()
功能描述：处理“即插即用”消息
***************************************************************/
NTSTATUS HelloWDMPnp(IN PDEVICE_OBJECT fdo, IN PIRP Irp)
{
    //创建一个设备扩展对象dx，用于存储指向fdo的指针：
     PDEVICE_EXTENSION dx=(PDEVICE_EXTENSION)fdo-&gt;DeviceExtension;

    //首先要通过函数IoGetCurrentIrpStackLocation()得到当前的IRP，并由此得到Minor Function：
     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
     ULONG MinorFunction = IrpStack-&gt;MinorFunction;

    //然后把这个Minor Function传递给下一个设备栈：
     IoSkipCurrentIrpStackLocation(Irp);
     NTSTATUS status = IoCallDriver( dx-&gt;NextStackDevice, Irp);

    //处理“即插即用”次功能代码：
    //当Minor Function等于IRP_MN_REMOVE_DEVICE时，说明有设备被拔出或卸下，这时要取消资源分配并删除设备：
    if( MinorFunction==IRP_MN_REMOVE_DEVICE)
    {
        //取消设备接口：
         IoSetDeviceInterfaceState(&amp;dx-&gt;ifSymLinkName, FALSE);
         RtlFreeUnicodeString(&amp;dx-&gt;ifSymLinkName);

        //调用IoDetachDevice()把fdo从设备栈中脱开：
        if (dx-&gt;NextStackDevice)
             IoDetachDevice(dx-&gt;NextStackDevice);
        //删除fdo：
         IoDeleteDevice(fdo);
    }

    //返回值：
    return status;
}

/***************************************************************
程序名称：Hello World for WDM
文件名称：HelloWDM.h
作者：罗聪
日期：2002-8-16
***************************************************************/

//头文件，只是声明一些函数和变量，比较简单就不多说了，请读者自行研究：

#ifdef __cplusplus

extern &quot;C&quot;
{
#endif

#include &quot;ntddk.h&quot;

#ifdef __cplusplus
}
#endif

typedef struct _DEVICE_EXTENSION
{
     PDEVICE_OBJECT     fdo;
     PDEVICE_OBJECT     NextStackDevice;
     UNICODE_STRING     ifSymLinkName;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

NTSTATUS HelloWDMAddDevice(IN PDRIVER_OBJECT DriverObject,
                           IN PDEVICE_OBJECT PhysicalDeviceObject);

NTSTATUS HelloWDMPnp(IN PDEVICE_OBJECT fdo,
                         IN PIRP Irp);
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[提交代码到上游内核的好处]]></title>
      <url>http://fengchao.github.io/2016/05/27/submit-code-to-upstream-kernel/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><ol><li><p>所有Linux用户都可以使用加入主内核的代码，在不同的发行版中自动启用。所以就没有必要发布驱动盘，免去了支持不同发行版及其不同版本的痛苦（亲身感受，非常痛苦）。解决了大量的发布和支持问题。</p></li><li><p>尽管开发者尽量保持内核空间与用户空间的接口稳定性，内核内部的调用接口却经常变化。这是有意而为之，使得任何时间都可以对内核进行基础修正，以获得更加高质量的代码。但是这一策略的另一个结果就是独立分支必须经常进行大量的修改以跟的上内核前进的脚步。</p></li></ol><p>而内核主树中的代码则不必担心这个问题，因为改变调用接口的开发者必须修正由此引发的问题。所以主树中代码的维护成本很低。</p><ol><li><p>除此之外，其他开发者会经常对内核中的代码进行提升。</p></li><li><p>只有经过审阅的代码才会进入内核。不管代码开发者有多牛，这个审阅过程总会提高代码的质量。</p></li></ol><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[function-call-convention]]></title>
      <url>http://fengchao.github.io/2016/05/22/Function-call-convention/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>在C语言中，假设我们有这样的一个函数：</p><pre><code>int function(int a,int b)
</code></pre><p>调用时只要用result = function(1,2)这样的方式就可以使用这个函数。但是，当高级语言被编译成计算机可以识别的机器码时，有一个问题就凸现出来：在CPU中，计算 机没有办法知道一个函数调用需要多少个、什么样的参数，也没有硬件可以保存这些参数。也就是说，计算机不知道怎么给这个函数传递参数，传递参数的工作必须 由函数调用者和函数本身来协调。为此，计算机提供了一种被称为栈的数据结构来支持参数传递。</p><p>栈是一种先进后出的数据结构，栈有一个存储区、一个栈顶指针。栈顶指针指向堆栈中第一个可用的数据项（被称为栈顶）。用户可以在栈顶上方向栈中加入 数据，这个操作被称为压栈(Push)，压栈以后，栈顶自动变成新加入数据项的位置，栈顶指针也随之修改。用户也可以从堆栈中取走栈顶，称为弹出栈 (pop)，弹出栈后，栈顶下的一个元素变成栈顶，栈顶指针随之修改。</p><p>函数调用时，调用者依次把参数压栈，然后调用函数，函数被调用以后，在堆栈中取得数据，并进行计算。函数计算结束以后，或者调用者、或者函数本身修改堆栈，使堆栈恢复原装。</p><p>在参数传递中，有两个很重要的问题必须得到明确说明：</p><ol><li>当参数个数多于一个时，按照什么顺序把参数压入堆栈</li><li>函数调用后，由谁来把堆栈恢复原装</li></ol><p>在高级语言中，通过函数调用约定来说明这两个问题。常见的调用约定有：</p><ul><li>stdcall</li><li>cdecl</li><li>fastcall</li><li>thiscall</li><li>naked call</li></ul><h2 id="stdcall调用约定"><a href="#stdcall调用约定" class="headerlink" title="stdcall调用约定"></a>stdcall调用约定</h2><p>stdcall很多时候被称为pascal调用约定，因为pascal是早期很常见的一种教学用计算机程序设计语言，其语法严谨，使用的函数调用约 定就是stdcall。在Microsoft C++系列的C/C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK。</p><p>stdcall调用约定声明的语法为(以前文的那个函数为例）：</p><pre><code>int __stdcall function(int a,int b)
</code></pre><p>stdcall的调用约定意味着：</p><ol><li>参数从右向左压入堆栈</li><li>函数自身修改堆栈</li><li>函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸</li></ol><p>以上述这个函数为例，参数b首先被压栈，然后是参数a，函数调用function(1,2)调用处翻译成汇编语言将变成：</p><pre><code>push 2 第二个参数入栈
push 1 第一个参数入栈
call function 调用参数，注意此时自动把cs:eip入栈
</code></pre><p>而对于函数自身，则可以翻译为：</p><pre><code>push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复
mov ebp,esp 保存堆栈指针
mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a
add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b
mov esp,ebp 恢复esp
pop ebp
ret 8
</code></pre><p>而在编译时，这个函数的名字被翻译成_function@8</p><p>注意不同编译器会插入自己的汇编代码以提供编译的通用性，但是大体代码如此。其中在函数开始处保留esp到ebp中，在函数结束恢复是编译器常用的方法。</p><p>从函数调用看，2和1依次被push进堆栈，而在函数中又通过相对于ebp(即刚进函数时的堆栈指针）的偏移量存取参数。函数结束后，ret 8表示清理8个字节的堆栈，函数自己恢复了堆栈。</p><h2 id="cdecl调用约定"><a href="#cdecl调用约定" class="headerlink" title="cdecl调用约定"></a>cdecl调用约定</h2><p>cdecl调用约定又称为C调用约定，是C语言缺省的调用约定，它的定义语法是：</p><pre><code>int function (int a ,int b) //不加修饰就是C调用约定
int __cdecl function(int a,int b)//明确指出C调用约定
</code></pre><p>在写本文时，出乎我的意料，发现cdecl调用约定的参数压栈顺序是和stdcall是一样的，参数首先由有向左压入堆栈。所不同的是，函数本身不 清理堆栈，调用者负责清理堆栈。由于这种变化，C调用约定允许函数的参数的个数是不固定的，这也是C语言的一大特色。对于前面的function函数，使 用cdecl后的汇编码变成：</p><p>调用处<br>push 1<br>push 2<br>call _function<br>add esp,8 注意：这里调用者在恢复堆栈</p><p>被调用函数_function处</p><pre><code>push ebp 保存ebp寄存器，该寄存器将用来保存堆栈的栈顶指针，可以在函数退出时恢复
mov ebp,esp 保存堆栈指针
mov eax,[ebp + 8H] 堆栈中ebp指向位置之前依次保存有ebp,cs:eip,a,b,ebp +8指向a
add eax,[ebp + 0CH] 堆栈中ebp + 12处保存了b
mov esp,ebp 恢复esp
pop ebp
ret 注意，这里没有修改堆栈
</code></pre><p>由于参数按照从右向左顺序压栈，因此最开始的参数在最接近栈顶的位置，因此当采用不定个数参数时，第一个参数在栈中的位置肯定能知道，只要不定的参数个数能够根据第一个后者后续的明确的参数确定下来，就可以使用不定参数，例如对于CRT中的sprintf函数，定义为：</p><pre><code>int sprintf(char* buffer,const char* format,...)
</code></pre><p>由于所有的不定参数都可以通过format确定，因此使用不定个数的参数是没有问题的。</p><pre><code>fastcall
fastcall调用约定和stdcall类似，它意味着：
</code></pre><p>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈<br>被调用函数清理堆栈<br>函数名修改规则同stdcall<br>其声明语法为：int fastcall function(int a,int b)</p><h2 id="thiscall"><a href="#thiscall" class="headerlink" title="thiscall"></a>thiscall</h2><p>thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着：</p><p>参数从右向左入栈<br>如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。<br>对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈<br>为了说明这个调用约定，定义如下类和使用代码：</p><pre><code>class A 
{ 
public:    
    int function1(int a,int b);    
    int function2(int a,...); 
}; 

int A::function1 (int a,int b) 
{    
    return a+b; 
}

#include
</code></pre><p>callee函数被翻译成汇编后就变成：</p><pre><code>//函数function1调用
0401C1D    push        2
00401C1F   push        1
00401C21   lea         ecx,[ebp-8]
00401C24   call function1           注意，这里this没有被入栈
//函数function2调用
00401C29   push        3
00401C2B   push        2
00401C2D   push        1
00401C2F   push        3
00401C31   lea         eax,[ebp-8]   这里引入this指针
00401C34   push        eax
00401C35   call function2
00401C3A   add         esp,14h
</code></pre><p>可见，对于参数个数固定情况下，它类似于stdcall，不定时则类似cdecl</p><h2 id="naked-call"><a href="#naked-call" class="headerlink" title="naked call"></a>naked call</h2><p>这是一个很少见的调用约定，一般程序设计者建议不要使用。编译器不会给这种函数增加初始化和清理代码，更特殊的是，你不能用return返回返回值，只能用插入汇编返回结果。这一般用于实模式驱动程序设计，假设定义一个求和的加法程序，可以定义为：</p><pre><code>__declspec(naked) int add(int a,int b)
{
  __asm mov eax,a
   __asm add eax,b
   __asm ret 
}
</code></pre><p>注意，这个函数没有显式的return返回值，返回通过修改eax寄存器实现，而且连退出函数的ret指令都必须显式插入。上面代码被翻译成汇编以后变成：</p><pre><code>mov eax,[ebp+8]
add eax,[ebp+12]
ret 8
</code></pre><p>注意这个修饰是和 __stdcall及cdecl结合使用的，前面是它和cdecl结合使用的代码，对于和stdcall结合的代码，则变成：</p><pre><code>__declspec(naked) int __stdcall function(int a,int b)
{
    __asm mov eax,a
    __asm add eax,b
    __asm ret 8        //注意后面的8
}
</code></pre><p>至于这种函数被调用，则和普通的cdecl及stdcall调用函数一致。</p><p>函数调用约定导致的常见问题<br>如果定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题，下面是两种常见的问题：</p><p>函数原型声明和函数体定义不一致<br>DLL导入函数时声明了不同的函数约定<br>以后者为例，假设我们在dll种声明了一种函数为：</p><pre><code>__declspec(dllexport) int func(int a,int b);//注意，这里没有stdcall，使用的是cdecl
</code></pre><p>使用时代码为：</p><pre><code>typedef int (*WINAPI DLLFUNC)func(int a,int b);
hLib = LoadLibrary(...);
DLLFUNC func = (DLLFUNC)GetProcAddress(...)//这里修改了调用约定
result = func(1,2);//导致错误
</code></pre><p>由于调用者没有理解WINAPI的含义错误的增加了这个修饰，上述代码必然导致堆栈被破坏，MFC在编译时插入的checkesp函数将告诉你，堆栈被破坏了。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序员发展路线图]]></title>
      <url>http://fengchao.github.io/2016/05/21/programer-roadmap/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>高中</p><pre><code>10 PRINT &quot;HELLO WORLD&quot;
 20 END
</code></pre><p>大一</p><pre><code>rogram Hello(input, output)
   begin
    writeln(&apos;Hello World&apos;)
   end.
</code></pre><p>大二</p><pre><code>(defun hello
       (print 
        (cons &apos;Hello 
            (list &apos;World))))
</code></pre><p>新手</p><pre><code>#include &lt;stdio.h&gt;
void main(void)
{
      char *message[] = {&quot;Hello &quot;, &quot;World&quot;};
      int i;

      for(i = 0; i &lt; 2; ++i)
        printf(&quot;%s&quot;, message[i]);

   printf(&quot;\n&quot;);
}
</code></pre><p>熟练程序员</p><pre><code> #include &lt;iostream.h&gt;
#include &lt;string.h&gt;
class string {
private:
     int size;
     char *ptr;

     string() : size(0), ptr(new char[1]) { ptr[0] = 0; }

    string(const string &amp;s) : size(s.size)
    {
        ptr = new char[size + 1];
        strcpy(ptr, s.ptr);
    }

    ~string()
    {
        delete [] ptr;
    }

       friend ostream &amp;operator &lt;&lt;(ostream &amp;, const string &amp;);
       string &amp;operator=(const char *);
 };

 ostream &amp;operator&lt;&lt;(ostream &amp;stream, const string &amp;s)
 {
   return(stream &lt;&lt; s.ptr);
 }

 string &amp;string::operator=(const char *chrs)
 {
   if (this != &amp;chrs)
   {
     delete [] ptr;
    size = strlen(chrs);
     ptr = new char[size + 1];
     strcpy(ptr, chrs);
   }
   return(*this);
 }

 int main()
 {
   string str;

   str = &quot;Hello World&quot;;
   cout &lt;&lt; str &lt;&lt; endl;

   return(0);
 }
</code></pre><p>专家</p><pre><code>[
 uuid(2573F8F4-CFEE-101A-9A9F-00AA00342820)
 ]
 library LHello
 {
     // bring in the master library
     importlib(&quot;actimp.tlb&quot;);
     importlib(&quot;actexp.tlb&quot;);

     // bring in my interfaces
     #include &quot;pshlo.idl&quot;

     [
     uuid(2573F8F5-CFEE-101A-9A9F-00AA00342820)
     ]
     cotype THello
  {
  interface IHello;
  interface IPersistFile;
  };
 };

 [
 exe,
 uuid(2573F890-CFEE-101A-9A9F-00AA00342820)
 ]
 module CHelloLib
 {

     // some code related header files
     importheader(&lt;windows.h&gt;);
     importheader(&lt;ole2.h&gt;);
     importheader(&lt;except.hxx&gt;);
     importheader(&quot;pshlo.h&quot;);
     importheader(&quot;shlo.hxx&quot;);
     importheader(&quot;mycls.hxx&quot;);

     // needed typelibs
     importlib(&quot;actimp.tlb&quot;);
     importlib(&quot;actexp.tlb&quot;);
     importlib(&quot;thlo.tlb&quot;);

     [
     uuid(2573F891-CFEE-101A-9A9F-00AA00342820),
     aggregatable
     ]
     coclass CHello
  {
  cotype THello;
  };
 };


 #include &quot;ipfix.hxx&quot;

 extern HANDLE hEvent;

 class CHello : public CHelloBase
 {
 public:
     IPFIX(CLSID_CHello);

     CHello(IUnknown *pUnk);
     ~CHello();

     HRESULT  __stdcall PrintSz(LPWSTR pwszString);

 private:
     static int cObjRef;
 };


 #include &lt;windows.h&gt;
 #include &lt;ole2.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &quot;thlo.h&quot;
 #include &quot;pshlo.h&quot;
 #include &quot;shlo.hxx&quot;
 #include &quot;mycls.hxx&quot;

 int CHello::cObjRef = 0;

 CHello::CHello(IUnknown *pUnk) : CHelloBase(pUnk)
 {
     cObjRef++;
     return;
 }

 HRESULT  __stdcall  CHello::PrintSz(LPWSTR pwszString)
 {
     printf(&quot;%ws
&quot;, pwszString);
     return(ResultFromScode(S_OK));
 }


 CHello::~CHello(void)
 {

 // when the object count goes to zero, stop the server
 cObjRef--;
 if( cObjRef == 0 )
     PulseEvent(hEvent);

 return;
 }

 #include &lt;windows.h&gt;
 #include &lt;ole2.h&gt;
 #include &quot;pshlo.h&quot;
 #include &quot;shlo.hxx&quot;
 #include &quot;mycls.hxx&quot;

 HANDLE hEvent;

  int _cdecl main(
 int argc,
 char * argv[]
 ) {
 ULONG ulRef;
 DWORD dwRegistration;
 CHelloCF *pCF = new CHelloCF();

 hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

 // Initialize the OLE libraries
 CoInitializeEx(NULL, COINIT_MULTITHREADED);

 CoRegisterClassObject(CLSID_CHello, pCF, CLSCTX_LOCAL_SERVER,
     REGCLS_MULTIPLEUSE, &amp;dwRegistration);

 // wait on an event to stop
 WaitForSingleObject(hEvent, INFINITE);

 // revoke and release the class object
 CoRevokeClassObject(dwRegistration);
 ulRef = pCF-&gt;Release();

 // Tell OLE we are going away.
 CoUninitialize();

 return(0); }

 extern CLSID CLSID_CHello;
 extern UUID LIBID_CHelloLib;

 CLSID CLSID_CHello = { /* 2573F891-CFEE-101A-9A9F-00AA00342820 */
     0x2573F891,
     0xCFEE,
     0x101A,
     { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
 };

 UUID LIBID_CHelloLib = { /* 2573F890-CFEE-101A-9A9F-00AA00342820 */
     0x2573F890,
     0xCFEE,
     0x101A,
     { 0x9A, 0x9F, 0x00, 0xAA, 0x00, 0x34, 0x28, 0x20 }
 };

 #include &lt;windows.h&gt;
 #include &lt;ole2.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdio.h&gt;
 #include &quot;pshlo.h&quot;
 #include &quot;shlo.hxx&quot;
 #include &quot;clsid.h&quot;

 int _cdecl main(
 int argc,
 char * argv[]
 ) {
 HRESULT  hRslt;
 IHello        *pHello;
 ULONG  ulCnt;
 IMoniker * pmk;
 WCHAR  wcsT[_MAX_PATH];
 WCHAR  wcsPath[2 * _MAX_PATH];

 // get object path
 wcsPath[0] = &apos;\0&apos;;
 wcsT[0] = &apos;\0&apos;;
 if( argc &gt; 1) {
     mbstowcs(wcsPath, argv[1], strlen(argv[1]) + 1);
     wcsupr(wcsPath);
     }
 else {
     fprintf(stderr, &quot;Object path must be specified\n&quot;);
     return(1);
     }

 // get print string
 if(argc &gt; 2)
     mbstowcs(wcsT, argv[2], strlen(argv[2]) + 1);
 else
     wcscpy(wcsT, L&quot;Hello World&quot;);

 printf(&quot;Linking to object %ws\n&quot;, wcsPath);
 printf(&quot;Text String %ws\n&quot;, wcsT);

 // Initialize the OLE libraries
 hRslt = CoInitializeEx(NULL, COINIT_MULTITHREADED);

 if(SUCCEEDED(hRslt)) {


     hRslt = CreateFileMoniker(wcsPath, &amp;pmk);
     if(SUCCEEDED(hRslt))
  hRslt = BindMoniker(pmk, 0, IID_IHello, (void **)&amp;pHello);

     if(SUCCEEDED(hRslt)) {

  // print a string out
  pHello-&gt;PrintSz(wcsT);

  Sleep(2000);
  ulCnt = pHello-&gt;Release();
  }
     else
  printf(&quot;Failure to connect, status: %lx&quot;, hRslt);

     // Tell OLE we are going away.
     CoUninitialize();
     }

 return(0);
 }
</code></pre><p>见习黑客</p><pre><code>#!/usr/local/bin/perl
 $msg=&quot;Hello, world.\n&quot;;
 if ($#ARGV &gt;= 0) {
   while(defined($arg=shift(@ARGV))) {
     $outfilename = $arg;
     open(FILE, &quot;&gt;&quot; . $outfilename) || die &quot;Can&apos;t write $arg: $!\n&quot;;
     print (FILE $msg);
     close(FILE) || die &quot;Can&apos;t close $arg: $!\n&quot;;
   }
 } else {
   print ($msg);
 }
 1;
</code></pre><p>有经验黑客</p><pre><code>#include &lt;stdio.h&gt;
 #define S &quot;Hello, World\n&quot;
 main(){exit(printf(S) == strlen(S) ? 0 : 1);}
</code></pre><p>熟练黑客</p><pre><code>% cc -o a.out ~/src/misc/hw/hw.c
 % a.out
</code></pre><p>黑客领袖</p><pre><code>% echo &quot;Hello, world.&quot;初级主管10 PRINT &quot;HELLO WORLD&quot;
 20 END
</code></pre><p>中级主管</p><pre><code>mail -s &quot;Hello, world.&quot; bob@b12
 Bob, could you please write me a program that prints &quot;Hello, world.&quot;?
 I need it by tomorrow.
 ^D
</code></pre><p>高级主管</p><pre><code>% zmail jim
 I need a &quot;Hello, world.&quot; program by this afternoon.
</code></pre><p>首席执行官</p><pre><code>% letter
 letter: Command not found.
 % mail
 To: ^X ^F ^C
 % help mail
 help: Command not found.
 % damn!
 !: Event unrecognized
 % logout
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[dbus 进程间通信]]></title>
      <url>http://fengchao.github.io/2016/05/21/dbus/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常一个桌面中会有几个不同的程序同时运行，而且它们之间需要相互间进行通讯。在操作系统层，这些不同的程序用不同的进程来实现。而为了安全起见，不同进 程间是不能直接相互调用和内存访问的，也就是一个进程对另外的进程是不可见的。这就需要一个机制来定义一个接口，一个进程通过接口访问另外一个进程，对于 发起访问的进程来说，调用 IPC 接口中的函数与调用自己进程内的函数是没有区别的这就是进程间通讯。进程间通讯有许多不同的实现：D-bus，CORBA，KDE 中的 DCOP 和 Gnome 中的 Bonobo 等。</p><p>实践证明， D-bus 是未来一段时间的桌面程序间进行通讯的主要方式。 D-BUS 的目标是将 DCOP 和 Bonobo 替换为简单的 IPC，并集成这两种桌面环境。由于尽可能地减少了 D-BUS 所需的依赖，所以其他可能会使用 D-BUS 的应用程序不用担心引入过多依赖。</p><h2 id="与其它通讯方式的对比"><a href="#与其它通讯方式的对比" class="headerlink" title="与其它通讯方式的对比"></a>与其它通讯方式的对比</h2><p>其他方式的缺点概括起来就是：</p><p>CORBA： 非常复杂，难于实现。看起来接口定义得相当完善，所以 Gnome 和 KDE 都曾经试图用它作为 进程间通讯的方式。但是因为此方式的接口复杂难用，速度慢，耗内存等缺点，结果都以失败告终。<br>DCOP：轻量级，依赖于 QT，曾经是 KDE 中的默认进程间通信方式，而目前KDE4 已经完全转移到 Dbus；</p><p>Bonobo：基于CORBA，实现复杂，依赖于GObject。目前Gnome 除了极个别的复杂情况下仍然使用 Bonobo 外，大部分已经转移到 D-Bus。</p><p>XML-RPC 和 SOAP：所有消息都以复杂的 XML 格式封包，用文本模式发送，接收后再转换回二进制模式。两次转换低效而耗时、</p><p>COM/DCOM: 微软早期版本使用，而且只能在微软的视窗系统中使用。众所周知，微软的设计通常包含安全问题，曾经风靡一时的冲击波病毒就是利用了远程进程间调用的漏洞。 COM 当然也不例外，ActiveX 依然是大部分网页病毒的源泉。COM+解决了部分问题，不过也实在好不到哪里去。</p><p>综合起来，大部分的缺点包括：</p><p>(1)有些过于复杂，不适合桌面使用</p><p>(2)有些严重依赖桌面环境，只能在 Gnome 中通讯或只能在 KDE 中通讯。这就造成 Gnome 和 KDE 间的程序难以相互通讯，扩大了 Linux 桌面的分裂。</p><h2 id="Dbus-的特点"><a href="#Dbus-的特点" class="headerlink" title="Dbus 的特点"></a>Dbus 的特点</h2><p>Dbus 的设计重复考虑了以上缺点,其主要特点包括：</p><p>（1）基于消息的通讯方式，使用二进制传输数据，使得实现起来相对简单，效率高</p><p>（2) 独立于 Gnome 和 KDE，在 freedesktop.org 的维护下发展。这样 Gnome 和 KDE 的程序之间就可以进行良好的通讯。</p><p>（3）正如其名字显示的那样，Dbus 使用总线系统，这样一个进程就可以同时和一组进程进行通讯。Dbus 中可以使用系统级总线，操作系统可以像总线中发送消息，供用户空间的程序使用。将整个桌面系统更好的整合起来。</p><p>（4）典型的 D-BUS 设置将由几个总线构成,经常使用系统总线和会话总线。一个持久系统总线在引导时就会启动，由操作系统和后台进程使用，安全性非常好，应用程序无法欺骗系统事件。会话总线在用户登录后启动，为用户私有，供用户的自己的应用程序进行通信。</p><h2 id="dbus-的调用方式"><a href="#dbus-的调用方式" class="headerlink" title="dbus 的调用方式"></a>dbus 的调用方式</h2><p>下面这个例子来自 Dbus 的官方教程，使用了 D-Bus 的 GLib 绑定，展示了如何通过 dbus 调用函数，更详细的例子请参考 <a href="http://dbus.freedesktop.org/doc/dbus/libdbus-tutorial.html" target="_blank" rel="external">http://dbus.freedesktop.org/doc/dbus/libdbus-tutorial.html</a> 。</p><pre><code>int main (int argc, char **argv)
{
    DBusGConnection *connection;
    GError *error;
    DBusGProxy *proxy;
    char **name_list;
    char **name_list_ptr;

    g_type_init ();

    error = NULL;

    /* 首先连接到总线 */
    connection = dbus_g_bus_get (DBUS_BUS_SESSION, &amp;error);
    if (connection == NULL){
        g_printerr (&quot;Failed to open connection to bus: %s\n&quot;,
        error-&gt;message);
        g_error_free (error);
        exit (1);
    }

    /* 创建代理对象 &quot;bus driver&quot; (name &quot;org.freedesktop.DBus&quot;) */

    proxy = dbus_g_proxy_new_for_name (connection,
        DBUS_SERVICE_DBUS,
        DBUS_PATH_DBUS,
        DBUS_INTERFACE_DBUS);

    /* 跨进程调用 ListNames 方法 并等待相应 */
    error = NULL;
    if (!dbus_g_proxy_call (proxy, &quot;ListNames&quot;, &amp;error, G_TYPE_INVALID,
    G_TYPE_STRV, &amp;name_list, G_TYPE_INVALID)){
    /* 演示远程异常与本地错误的处理 */
        if (error-&gt;domain == DBUS_GERROR &amp;&amp; error-&gt;code ==  BUS_GERROR_REMOTE_EXCEPTION)
            g_printerr (&quot;Caught remote method exception %s: %s&quot;,             dbus_g_error_get_name (error), error-&gt;message);
        else {
            g_printerr (&quot;Error: %s\n&quot;, error-&gt;message);

        g_error_free (error);
        exit (1);
    }

    /* 打印结果 */

    g_print (&quot;Names on the message bus:\n&quot;);

    for (name_list_ptr = name_list; *name_list_ptr; name_list_ptr++){
        g_print (&quot; %s\n&quot;, *name_list_ptr);
    }
    g_strfreev (name_list);

    /* 释放接口 */
    g_object_unref (proxy);

    return 0;
}
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[testdisk]]></title>
      <url>http://fengchao.github.io/2016/05/21/testdisk/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>Testdisk 是修复分区表，恢复误删数据的好工具。</p><h4 id="Install（Ubuntu）"><a href="#Install（Ubuntu）" class="headerlink" title="Install（Ubuntu）"></a>Install（Ubuntu）</h4><pre><code>$ sudo apt-get install testdisk
</code></pre><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><pre><code>$ sudo testdisk
</code></pre><h4 id="重新扫描分区表"><a href="#重新扫描分区表" class="headerlink" title="重新扫描分区表"></a>重新扫描分区表</h4><p>依次选择</p><pre><code>[Create] --&gt; 需要修复的硬盘 --&gt; 
[Proceed] --&gt; 
[Intel ] Intel/PC partition --&gt; 
[Analyse] --&gt; 
[Proceed] --&gt;
[Write]
</code></pre><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[生成和使用代码补丁]]></title>
      <url>http://fengchao.github.io/2016/05/21/patch/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><pre><code>$ diff -Nur old new &gt; patchfile
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>$ cd old 
$ patch -p1 &lt; ../patchfile
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python >>> import this]]></title>
      <url>http://fengchao.github.io/2016/05/21/Python-import-this/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>The Zen of Python, by Tim Peters</p><pre><code>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&apos;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&apos;re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it&apos;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&apos;s do more of those!
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java, .NET ,Mono]]></title>
      <url>http://fengchao.github.io/2016/05/09/Java-NET-Mono/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>Java 是 Sun 开发的跨平台语言，Java 编译出的程序运行在与平台无关的虚拟机 JVM 上，只要在各个操作系统之上实现了虚拟机，Java 就可以在其上运行。因为这一特性， Java 成为跨平台网络开发的首选语言。</p><p>这一点，显然是微软最不愿意看到的。微软希望所有的软件都只能在它的Windows操作系统中运行，这样就可以牢牢拴住用户，即使生产 Vista 这样的垃圾系统也能赚钱。所以，微软自己也发布一个所谓的“扩展” Java 虚拟机，但是这个 Java 版本只能用在微软自己的系统之上，不能用在其它平台，只能用于 IE 浏览器，无法用于其它浏览器。微软希望通过特意的设计，逐步消减 Java 的跨平台特征。</p><p>Sun 并没有束手就擒，面对这种卑劣的手段，只好于 1997 年提起诉讼，认为微软利用自己的垄断地位，破环 Java 的设计原则：</p><p>“Microsoft feared and sought to impede the development of network effects that cross-platform technology like Netscape Navigator and Java might enjoy and use to challenge Microsoft’s monopoly. Another internal Microsoft document indicates that the plan was not simply to blunt Java/browser cross-platform momentum, but to destroy the cross-platform threat entirely, with the ‘Strategic Objective’ described as to ‘Kill cross-platform Java by grow(ing) the polluted Java market.’”</p><p>微软败诉，只得放弃自己的 Java。并通过退出 .NET 来抗衡 Java。.NET 和 Java 都是中间层，但是和 Java 不同，.NET 并不提供跨操作系统的虚拟机，而是提供与语言关的环境。在 .NET 之上，可以使用 VB，VC 和 C# 进行开发，结果会编译成中间语言，实现与语言无关的特性。总体来说，.NET 还是十分出色的一个开发环境，具有许多优秀的功能。其最重要的目的，就是与 Java 在争抢网络开发上的地盘。</p><p>Mono 是 Linux 下的 .NET 开发工具，目的是使 Windows 下的程序更容易移植到 Linux，开发人员更快开始 Linux 下的开发。MonoDevelop 很好用，而且开发出了一些优秀的程序，例如Beagle, Tomboy, Banshee 和F-Spot 等。但是由于 Mono 和 .NET 的关系，很多人都害怕微软又会出什么招数，或者利用专利手段一下釜底抽薪，导致所有基于 Mono 的程序陷入困境。正如 Richard Stallman 所说：基于自由软件开发 C# 实现是值得鼓励的一件事，但是把 Gnome，把许多优秀的桌面程序建立在 C# 之上是一件危险的事情。</p><p>但是有一个公司并不用担心这个事情，那就是 Novell。因为 Novell 与微软达成的协议，即使 Mono 侵犯了微软的版权，微软也不会起诉这公司。这也就是 Mono 的开发者 de Icaza 受雇于 Novell，而且 Novell 大力支持 Mono 开发的原因。</p><p>也许有一天，微软会认识到开源是大势所趋，自由软件是软件这一生产形势的必然要求。但是在获得微软的完全授权之前，Mono 的命运总是不靠谱的。</p><h4 id="2016-5-update"><a href="#2016-5-update" class="headerlink" title="2016-5 update"></a>2016-5 update</h4><p>故事和预想的类似，微软最终将 Mono 纳入自己的手中。我们应该高兴，微软在这么多年中，终于有所改变，开始了很多开源的项目。</p><p>但是，还是那句话，任何严肃的开源开发者，都不应该将自己的工作建立在一个不稳固的基础之上。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何确定内核模块的维护者]]></title>
      <url>http://fengchao.github.io/2016/04/16/How-to-get-kernel-module-maintainers/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><ol><li><p>查看 MAINTAINERS 文件</p></li><li><p>使用脚本 scripts/get_maintainer.pl</p><pre><code>$ scripts/get_maintainer.pl -f drivers/usb/serial/ftdi_sio.c
  Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
  Alan Cox &lt;alan@linux.intel.com&gt;
  linux-usb@vger.kernel.org
  linux-kernel@vger.kernel.org
</code></pre></li></ol><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bash 脚本里面的旋转]]></title>
      <url>http://fengchao.github.io/2016/04/16/Bash-rotation-code/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><pre><code>while(true); do 
    for a in \\ \| \/ -; do 
        echo -n $a
        sleep 1
        echo -n -e \\r
    done
done
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 中的 Flash 文件系统]]></title>
      <url>http://fengchao.github.io/2016/04/06/Flash-storage-in-Linux/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>作者： 华清远见嵌入式培训中心</p><p>嵌入式系统与通用PC机不同，一般没有硬盘这样的存储设备而是使用Flash闪存芯片、小型闪存卡等专为嵌入式系统设计的存储装置，本文分析了嵌入式系统中常用的存储设备及其管理机制，介绍了常用的基于FLASH的文件系统类型。</p><h1 id="1．嵌入式系统存储设备及其管理机制分析"><a href="#1．嵌入式系统存储设备及其管理机制分析" class="headerlink" title="1．嵌入式系统存储设备及其管理机制分析"></a>1．嵌入式系统存储设备及其管理机制分析</h1><p>构建适用于嵌入式系统的Linux文件系统，必然会涉及到两个关键点，一是文件系统类型的选择，它关系到文件系统的读写性能、尺寸大小;另一个就是根文件系统内容的选择，它关系到根文件系统所能提供的功能及尺寸大小。</p><p>嵌 入式设备中使用的存储器是像Flash闪存芯片、小型闪存卡等专为嵌入式系统设计的存储装置。Flash是目前嵌入式 系统中广泛采用的主流存储器，它的 主要特点是按整体/扇区擦除和按字节编程，具有低功耗、高密度、小体积等优点。目前，Flash分为NOR, NAND两种类型。</p><p>NOR型闪存可以直接读取芯片内储存的数据，因而速度比较快，但是价格较高。NOR型芯 片，地址线与数据线分开，所以 NOR型芯片可以像SRAM一样连在 数据线上，对NOR芯片可以“字”为基本单位操作，因此传输效率很高，应用程序可以直接在Flash内运行，不必再把代码读到系统RAM中运行。它与 SRAM的最大不同在于写操作需要经过擦除和写入两个过程。</p><p>NAND型闪存芯片共用地址线与数据线，内部数据 以块为单位进行存储，直接将NAND芯片做启动芯片比较难。NAND闪 存是连续存储介质，适合放大文件。 擦除NOR器件时是以64-128KB的块进行的，执行一个写入/擦除操作的时间为5s；擦除NAND器件是以8-32KB的块进行的，执行相同的操作最 多只需要4ms。NAND Rash的单元尺寸几乎是NOR器件的一半，由于生产过程更为简单，NAND结构可以在给定的模具尺寸内提供更高的容量，也就相应地降低了价格。NOR flash占据了容量为1―16MB闪存市场的大部分，而NAND flash只是用在8―128MB的产品当中，这也说明NOR主要应用在代码存储介质中，NAND适合于数据存储。寿命(耐用性)，在NAND闪存中每个 块的最大擦写次数是一百万次，而NOR的擦写次数是十万次。NAND存储器除了具有10比1的块擦除周期优势，典型的NAND块尺寸要比NOR器件小8 倍，每个NAND存储器块在给定的时间内的删除次数要少一些。</p><p>所有嵌入式系统的启动都至少需要使用某种形式的永久性存储设备，它们需要合适的驱动程序，当前在嵌入式Linux中有三种常用的块驱动程序可以选择。</p><ul><li>Blkmem驱动层</li></ul><p>Blkmem 驱动是为uclinux专门设计的，也是最早的一种块驱动程序之一，现在仍然有很多嵌入式Linux操作系 统选用它作为块驱动程，尤其是在 uClinux中。它相对来说是最简单的，而且只支持建立在NOR型Flash和RAM中的根文件系统。使用Blkmem驱动，建立Flash分区配置比 较困难，这种驱动程序为Flash提供了一些基本擦除/写操作。</p><ul><li>RAMdisk驱动层</li></ul><p>RAMdisk 驱动层通常应用在标准Linux中无盘工作站的启动，对Flash存储器并不提供任何的直接支持， RAM disk就是在开机时，把一部分的内存虚拟成块设备，并且把之前所准备好的档案系统映像解压缩到该RAM disk环境中。当在Flash中放置一个压缩的文件系统，可以将文件系统解压到RAM，使用RAM disk驱动层支持一个保持在RAM中的文件系统。</p><ul><li>MTD驱动层</li></ul><p>为 了尽可能避免针对不同的技术使用不同的工具，以及为不同的的技术提供共同的能力，Linux内核纳入了MTD子系统 (memory Technology Device)。它提供了一致且统一的接口，让底层的MTD芯片驱动程序无缝地与较高层接口组合在一起。JFFS2, Cramfs, YAFFS等文件系统都可以被安装成MTD块设备。MTD驱动也可以为那些支持CFI接口的NOR型Flash提供支持。虽然MTD可以建立在RAM上， 但它是专为基于Flash的设备而设计的。MTD包含特定Flash芯片的驱动程序，开发者要选择适合自己系统的Flash芯片驱动。Flash芯片驱动 向上层提供读、写、擦除等基本的操作，MTD对这些操作进行封装后向用户层提供MTD char和MTD block类型的设备。MTD char类型的设备包括/dev/mtd0, /dev/mtdl等，它们提供对Flash原始字符的访问。MTD block类型的设备包括/dev/mtdblock0,/dev/mtdblock1等，MTD block设备是将Flash模拟成块设备，这样可以在这些模拟的块设备上创建像Cramfs, JFFS2等格式的文件系统。</p><p>MTD 驱动层也支持在一块Flash上建立多个Flash分区，每一个分区作为了一个MTD block设备，可以把系统软件和数据等分配到不同的分区上，同时可以在不同的分区采用不用的文件系统格式。这一点非常重要，正是由于这一点才为嵌入式系 统多文件系统的建立提供了灵活性。</p><h1 id="2．-基于Flash的文件系统"><a href="#2．-基于Flash的文件系统" class="headerlink" title="2． 基于Flash的文件系统"></a>2． 基于Flash的文件系统</h1><p>鉴 于Flash存储介质的读写特点，传统的Linux文件系统己经不适合应用在嵌入式系统中，像Ext2fs文件系统是 为像IDE那样的块设备设计的，这 些设备的逻辑块是512字节、1024字节等大小，没有提供很好的扇区擦写支持，不支持损耗平衡，没有掉电保护，也没有特别完美的扇区管理，这不太适合于 扇区大小因设备类型而划分的闪存设备。基于这样的原因，产生了很多专为Flash设备而设计的文件系统，常见的专用于闪存设备的文件系统如下：</p><ul><li>Romfs</li></ul><p>传 统型的Romfs文件系统是最常使用的一种文件系统，它是一种简单的、紧凑的、只读的文件系统，不支持动态擦写保存; 它按顺序存放所有的文件数据，所以 这种文件系统格式支持应用程序以XIP方式运行，在系统运行时，可以获得可观的RAM节省空间。uClinux系统通常采用Romfs文件系统。</p><ul><li>Cramfs</li></ul><p>Cramfs 是Linux的创始人Linus Torvalds开发的一种可压缩只读文件系统在Cramfs文件系统中，每一页被单独压缩，可以随机页访问，其压缩比高达2:1,为嵌入式系统节省大量 的Flash存储空间。Cramfs文件系统以压缩方式存储，在运行时解压缩，所以不支持应用程序以XIP方式运行，所有的应用程序要求被拷到RAM里去 运行，但这并不代表比Ramfs需求的RAM 空间要大一点，因为Cramfs是采用分页压缩的方式存放档案，在读取档案时，不会一下子就耗用过多的内存空间，只针对目前实际读取的部分分配内存，尚没 有读取的部分不分配内存空间，当我们读取的档案不在内存时， Cramfs文件系统自动计算压缩后的资料所存的位置，再即时解压缩到RAM中。另外，它的速度快，效率高，其只读的特点有利于保护文件系统免受破坏，提 高了系统的可靠性;但是它的只读属性同时又是它的一大缺陷，使得用户无法对其内容对进扩充。Cramfs映像通常是放在Flash中，但是也能放在别的文 件系统里，使用loopback设备可以把它安装别的文件系统里。使用mkcramfs工具可以创建Cramfs映像。</p><ul><li>Ramfs/Tmpfs</li></ul><p>Ramfs 也是Linus Torvalds开发的，Ramfs文件系统把所有的文件都放在RAM里运行，通常是Flash系统用来存储一些临时性或经常要修改的数据，相对于 ramdisk来说，Ramfs的大小可以随着所含文件内容大小变化，不像ramdisk的大小是固定的。Tmpfs是基于内存的文件系统，因为 tmpfs驻留在RAM 中，所以写/读操作发生在RAM 中。tmpfs文件系统大小可随所含文件内容大小变化，使得能够最理想地使用内存;tmpfs驻留在RAM，所以读和写几乎都是瞬时的。tmpfs的一个 缺点是当系统重新引导时会丢失所有数据。</p><ul><li>JFFS2</li></ul><p>JFFS2 是RedHat公司基于JFFS开发的闪存文件系统，最初是针对RedHat公司的嵌入式产品eCos开发的 嵌入式文件系统，所以JFFS2也 可以用在Linux,uCLinux中。JFFS文件系统最早是由瑞典Axis Communications公司基于Linux2.0的内核为嵌入式系统开发的文件系统。JFFS2是一个可读写的、压缩的、日志型文件系统，并提供了 崩溃/掉电安全保护，克服了JFFS的一些缺点:使用了基于哈希表的日志节点结构，大大加快了对节点的操作速度;支持数据压缩；提供了“写平衡”支持;支 持多种节点类型；提高了对闪存的利用率，降低了内存的消耗。这些特点使JFFS2文件系统成为目前Flash设备上最流行的文件系统格式，它的缺点就是当 文件系统已满或接近满时，JFFS2运行会变慢，这主要是因为碎片收集的问题。</p><ul><li>YAFFS</li></ul><p>YAFFS/YAFFS2 是一种和JFFSx类似的闪存文件系统，它是专为嵌入式系统使用NAND型闪存而设计的一种日 志型文件系统。和JFFS2相比它 减少了一些功能，所以速度更快，而且对内存的占用比较小。此外，YAFFS自带NAND芯片的驱动，并且为嵌入式系统提供了直接访问文件系统的API，用 户可以不使用Linux中的MTD与VFS，直接对文件系统操作。YAFFS2支持大页面的NAND设备，并且对大页面的NAND设备做了优化。 JFFS2在NAND闪存上表现并不稳定，更适合于NOR闪存，所以相对大容量的NAND闪存，YAFFS是更好的选择。</p><p>具体的嵌入式系统设计中可根据不同目录存放的内容不同以及存放的文件属性，确定使用何种文件系统。</p><ul><li>UBIFS</li></ul><p>诺基亚开发的新文件系统，意在取代 JFFS2.</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kill software patents]]></title>
      <url>http://fengchao.github.io/2016/04/06/Kill-software-patents/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>By Pieter Hintjens</p><p>Online on: 31/10/2006</p><p>I know that many people come to the FFII—as I did—because they feel a deep sense of injustice at how the smaller players in IT are consistently squashed by special interests and monopolists. But I’m going to look at our core concern—software patents—from a different angle, one based more on economics and less on emotions.</p><p>The simple question “what’s wrong with software patents?” stirs up controversy and divides the IT industry into two camps like no other. Every group has their own ideology about software patents. Those who don’t like them claim that they are anti-competitive, that they are tools used by industry giants to crush free and open software, that they are bad for innovation, that they are monopolies, etc. Those who like them claim that they are simply units of intellectual property, to be traded like any other commodity.</p><p>What is property?<br>All property is a monopoly. All property can be traded, bought and sold, and can make money for its owners. The state can declare any resource it likes to be “property”. We are, as citizens, property of the state, and in some countries we can still be traded, bought, and sold, and make money for our owners.</p><p>But these are useless truisms. I can make tenuous comparisons between patents and slavery, and stir up all kinds of emotions. I’m not going to do that. Instead, I’m going to look at the very meaning of property, and explore the dynamics that drive the basic notions of “private property”.</p><p>Property, of any kind, consists of a definition and a system of enforcement. All the rest is subjective. There is no intrinsic reason that land or potatoes should be different from ideas, time, or air. Anyone who argues that it is “right” or “wrong” to define and enforce certain types of property must prove this using more than just rhetoric and dogma.</p><p>The case for private property<br>Let’s look at a well-understood form of property: land rights. Most countries are divided up into plots large and small. The very concept of “country” is property, but a thousand years ago, only a small part of the world’s surface, in and around human habitations, was considered property. The rest was common lands, belonging to all and none. The process of turning common lands into shared property, and then into private domains (the “tragedy of the commons”) was driven by discussions very similar to the ones we hear today. The process was driven by greed to some extent, but also by real needs of evolving economies driven by new technologies in agriculture and industry.</p><p>A farmer who owns his land is far more likely to look after it than a farmer working on a collective. Similarly, it is clear that private home ownership is a healthier model in a modern money-based economy than state-ownership of homes. Private ownership of some things works very well.</p><p>The case for common property<br>However, this is not the whole story. Private ownership is not a panacea, and for every example where private ownership is “right”, I can find one where it is “wrong”. The roads and streets that connect those farms and houses are owned and managed collectively. The rain, air, and sun is owned by no-one. The wild animals and insects that form an important part of the ecology are collectively owned.</p><p>The five principles of property<br>There are actually good economic reasons for choosing a private property model for some resources, and not for others. There are five key rules to consider (there may be more, these are the most obvious ones to me):</p><p>Is the resource mobile, or fixed? This criteria defines whether it is possible to accurately define the resource, or not. A mobile resource—such as migrating birds or fish—does not fit the private property model. Fixed resources, such as lobsters, do.<br>Does the resource have clear boundaries, or not? This criteria defines whether it is possible to accurately enforce the monopoly, or not. Land can be well-defined. Art cannot be well-defined.<br>What generates more wealth—exclusive ownership or sharing? This criteria defines whether it is useful to consider this resource as property at all. Exclusive ownership of a house generates wealth, but exclusive ownership of roads does not (which is why we removed toll bridges on our roads).<br>Is the property system economical? In other words, is the definition and enforcement of the property cheap? If so, it is accessible to all. If not, it becomes a priviledge of the rich, and the system itself stops being economically neutral.<br>Is the property system well-bounded? In other words, is the definition of the property clear and unnegotiable? If the definition can be manipulated and changed, then the system that manages it will grow in an unsafe manner.<br>All forms of property can be tested against these five rules. The rules are, ultimately, self-enforcing because any society that ignores them will find itself paying the cost, and competition between societies punishes those that choose inefficient economic models.</p><p>The dangers of bad property systems<br>A well-defined property system can be incredibly powerful, and badly-defined property systems can be very damaging. I’d argue that what brought down the Soviet Union was not the political system, nor military spending, but simply the fact that private ownership of farms and houses was impossible. There is a direct relationship between house prices (which mainly depend on availability of land) and economic growth, in many countries. Home ownership creates a middle class, which is the main driver of modern economies.</p><p>Let’s see what happens when we break the rules. If we try to create monopolies on mobile resources, we over-exploit those resources. If we try to enforce monopolies that don’t have clear boundaries, we spend a lot on lawyers. If we create monopolies on resources that should be shared, we lose competitive advantage. If we create expensive property systems, we unleash special interests. And if we create unbounded property systems, those special interests will grow out of control.</p><p>Property systems for the software business<br>So I’ve defined five economic rules that we can apply to any form of property to measure whether it is a good, or bad, concept. Let’s now apply these to the main forms of property that are used in the IT sector, and see what we get. The four main property forms are: copyright, trademark, patent, and trade secret (which though not defined as IPR, is a real and useful form of property):</p><p>Copyright: it applies to a fixed resource: a self-defining written expression. It has clear boundaries (the document or work). Exclusive ownership does produce wealth, but sharing seems to be a stronger driver, and models such as the GPL that encourage both appear to be the most efficient at producing value. The copyright system is cheap and well-bounded, except when it comes to lifespans, and we’ve seen copyright terms extended to life+70, which is extraordinary in today’s digital era.<br>Trademark: it applies to a fixed resource: a name, logo, or phrase. It has clear boundaries (the mark). Exclusive ownership produces the most value—sharing of marks just weakens them. The trademark system is very well-bounded, though it could be cheaper.<br>Software patent: it applies to mobile resources: new ways of doing things, or methods. It has unclear boundaries (methods are difficult to define absolutely, and they overlap in horribly complex ways). It uses exclusive ownership for resources (new ideas) that produce much more value when shared. It is poorly bounded (it depends on a set of negotiable definitions such as “technical effect”), and it is very expensive.<br>Trade secret: it is fixed (in your firm). It has clear boundaries (individuals may not pass secrets outside the defined group). It depends on exclusive ownership. It is a well-defined system that is easy to apply, and cheap (based on simple contract).<br>The conclusions are clear: copyright, trademark, and trade secret are good forms of property for the software business, though copyright terms are a problem. Patents are a bad form of property for the software business, because they amplify the general weaknesses of the patent system:</p><p>Patents claim to own ideas, which are highly mobile resources, and in software, more mobile than most other industries.<br>Patents have unclear boundaries, and in software these boundaries are even less clear than in other industries.<br>Patents reduce the sharing of new ideas, and software depends on a higher volume of sharing of ideas than other industries.<br>Patents are an expensive property system, and most software innovation is driven by unfunded grass-roots work.<br>Patents are not a well-bounded property system, and in software a boundary between “good” and “bad” patents cannot be drawn.<br>It is significant, in my opinion, that patent industry has focussed almost exclusively on weakening the definition of software patents, and on strengthening their enforcement. There has been little or no discussion about the basic justification for creating this form of property, apart from the uselessly broad claim that “ownership of [certain classes of] ideas promotes investment in innovation [in certain sectors]”. This claim, which has always underpinned the patent system has been used to justify a gold rush, a land-grab of ideas in sectors where innovation actually depends on sharing, not exclusion.</p><p>Software patents are a new toll barrier<br>Many industries find that poor quality patents are a problem. But no other industry that has relied extensively on copyright has been subjected to patenting. The use of patents in software looks a lot more like the errection of a massive new system of private tolls and taxes, than the enablement of a new properties class.</p><p>Software patents were enabled in the USA in 1982 by a Supreme Court decision. After almost twenty-five years, we would expect to see this new form of property either proven, or disproven. The bulk of the software sector should, by now, be using patents as their primary tool for justifying new investments. There should be software patent success stories, to match the many success stories that were and are driven by other forms of intellectual property.</p><p>These success stories are just not there. Instead, we see a sorry parade of lawsuits. IBM—who has the largest software portfolio, and who has claimed that it is against business method patents—has just sued Amazon for infringing on several business process patents.</p><p>Conclusion<br>In this article I’ve examined software patents from the fundamentalist view point of how well a property system functions. This is not art, but science. We can document and measure, and we can prove or disprove property systems.</p><p>No sane person can claim that all private property is good, or that all private property is bad. Would it make sense to sell off all our streets to private owners? Would it make sense to allow individuals to collect tolls on bridges, borders, crossings, and rivers? All these property systems have been tried. There is no firmer believer in private property and punitive enforcement than a warlord.</p><p>No honest person can claim that it’s a choice between “privatising everything” and “an anti-property communist state”. The choices are between models that work, and models that do not. History is filled with examples and experiences, and we must recognise and learn from those models, or we will make stupid and avoidable mistakes. There is, behind our iMatix building in Brussels, a street that was privatised some decades ago. I’ve no idea what the intention was, but today we can see the results via Google Maps. The privatised street has become a wasted area, a car park, filled with weeds.</p><p>This is what’s wrong with software patents.</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Free as in Freedom]]></title>
      <url>http://fengchao.github.io/2016/04/06/Free-as-in-Freedom/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p><img src="/images/GNU_Richard_Stallman.jpg" alt="Richard" title="Title is optional"></p><p>Richard Matthew Stallman, the father of the GNU movement once gave a talk at the Australian National University where he explained his stand on the name GNU/Linux, the Digital Millennium Act, DRM which Stallman chooses to call Digital Restriction Management and software idea patents. He talked for over one hour explaining and throwing light on these and many other topics of interest to GNU and all freedom loving people.</p><h3 id="RMS-on-why-people-should-call-it-GNU-Linux-instead-of-just-Linux"><a href="#RMS-on-why-people-should-call-it-GNU-Linux-instead-of-just-Linux" class="headerlink" title="RMS on why people should call it GNU/Linux instead of just Linux"></a>RMS on why people should call it GNU/Linux instead of just Linux</h3><p>… So the goal we had set out to reach in 1984 had been reached (with the development of the Linux kernel). But at the same time, a confusion developed, we started thinking that the entire operating system was Linux. And this confusion was a serious blow to the free software movement. Because, before that time, the people who saw various pieces of GNU knew that they were doing so and they became GNU fans. And so when they came across the articles written about the philosophy of GNU, they wouldn’t guarantee to agree with us but at least they would pay serious attention and say we are fans of GNU and this is the philosophy of GNU.</p><p>After there was a complete GNU system with Linux that you could get to run, people started thinking that it was Linux. But before that point, our software spread the philosophy and our philosophy help spread the software because when the people read this, if they agree, they will be motivated to develop more free software and add to GNU.</p><p>However after people started using essentially the GNU system with Linux added, and called it Linux, it no longer led then to the philosophy associated with GNU - the philosophy of free software. Instead of that, the people read the philosophy that was associated with the name Linux. The apolitical philosophy of Linus Torvalds who thinks that all software licences are legitimate and it is wrong ever to violate them. So his views on this are more or less the same as Microsoft’s. Now he of course has the right to promote his views but I object to our work becoming the main basis for promoting his views because it is attributed to him directly by labeling the GNU system as Linux. And that is why I ask people to call the system as GNU/Linux.</p><p>Give us equal mention. We need it. We need it not just because it is fair but because it will help people recognize what we have done so they will think about what we are asking them help us do. Our work is not finished. People will sometimes give me advice which in other circumstances might have been wise. They would say, it looks bad to ask for credit. And so they say, when the people call the system Linux, smile to yourself and take pride in a job well done. This would be very wise advice if it were true that the job is done. We made a great beginning. We have developed more than one free operating system in our community and many free application programs. But there are many application programs we still have to develop. We have developed free operating systems used by 10’s of millions of users. But there are 100’s of millions of users of proprietary operating systems and even the people using free operating systems often use proprietary programs on top of that. So we have a tremendous amount of work to do.</p><h3 id="RMS-on-Digital-Millennium-Copyright-Act-and-DRM"><a href="#RMS-on-Digital-Millennium-Copyright-Act-and-DRM" class="headerlink" title="RMS on Digital Millennium Copyright Act and DRM"></a>RMS on Digital Millennium Copyright Act and DRM</h3><p>…</p><p>Today the main question is whether we would be allowed to develop the software that the users want. In the US, there are already two laws forbidding the development of various kinds of free software. One of these laws is the Digital Millennium Copyright Act - The law that forbids free software to access encrypted or some how blocked off data. This law was used to prohibit the free software from playing a DVD. If you buy a DVD in the US, it is legal for you to watch the movie. But the free software that would enable you to do this on your free GNU/Linux system has been censored completely. There is in fact no lawfully available software in the US that you could use to watch a DVD.</p><p>But I am afraid, they have carried this even further. There is a certain computer game that is accompanied by a network server that allows people to play against each other and they communicate with some kind of cryptic protocol. And people figured this out and implemented their own server and they have their own free game which is some what similar. They wrote it themselves and is not a modified work within modified proprietary game that won’t have been illegal anyway. So they wrote their own game and they have their own server. And you could use either game and talk to either server. And they were sued. A court ruled that these free alternatives are illegal ones under the digital millennium copyright act. Now please note that using either one of these free alternatives doesn’t enable one to use the proprietary one without paying. We have here two separate products being tied together through the use of this law.</p><p>The Digital Millennium Copyright Act is used to impose DRM (Digital Restriction Management) on the public. So they are not satisfied with prohibiting people from sharing with their neighbours. They want to redesign your computer system to stop you from sharing and this is wrong. DRM is fundamentally wrong in itself because it stops people from cooperating with their neighbours. And a government of the people, by the people and for the people will not enact laws that support DRM in any way. So that is one law which prohibits certain kinds of free software.</p><h3 id="RMS-on-Software-Idea-Patents"><a href="#RMS-on-Software-Idea-Patents" class="headerlink" title="RMS on Software Idea Patents"></a>RMS on Software Idea Patents</h3><p>Another law in the US which prohibits free software from any progress of any kind is the patent law. In the US, any kind of software idea for use in any kind of software can be patented by some one. Which means that when you implement that idea, you could get sued. Now large programs combine many ideas. A program can combine easily 100’s or 1000’s of different ideas. And if any one of these ideas is patented, your chances of developing a large program without infringing many patents is absurdly small. So software patents are obstacles to all software development. And they threaten users as well. The users can also get sued for the software they are using, for the way they have configured their machines and so on.</p><p>And this is advertised as a scheme to promote progress. But economic research shows just the opposite. Now I used to ask people to imagine how many different patents one program could be implemented by at once. I would say dozens, may be 50. Well now we do not have to imagine. Somebody did a study, must have been a lot of work. He took one particular program named Linux - the kernel of the GNU/Linux system. And he checked for all the US patents that covers something that could be found somewhere in Linux. He found 286 different US patents that covers parts of Linux. And Linux is just one part of the system. I saw an estimate somewhere else that it was 25 % of the system.</p><p>So if we note, we can get a rough estimate of around a 100,000 or so different software idea patents in the US that would cover ideas used some where in GNU/Linux system of today. Of course, it is a rough estimate and it wouldn’t surprise me if it were only 30,000 or as much as 300,000. So now you see the danger. And since this danger is not only for free software developers but for all software developers aside perhaps from the mega corporations, there is actually a very broad movement against the software idea patents. This movement which I am led to say I played a major role in starting about 40 years ago has actually persuaded the European Parliament which voted to reject software idea patents. Now European Union is set out to have only a little democracy in it. … The process is not over yet and we are still fighting it but there is a good chance that we can win at the level of the European Union. Of course Microsoft wants software idea patents. Microsoft has stated that it intends to use software idea patents to kill off GNU/Linux.</p><h3 id="RMS-on-developing-a-free-Java-platform-and-on-Flash-and-MS-Word-file-formats"><a href="#RMS-on-developing-a-free-Java-platform-and-on-Flash-and-MS-Word-file-formats" class="headerlink" title="RMS on developing a free Java platform and on Flash and MS Word file formats"></a>RMS on developing a free Java platform and on Flash and MS Word file formats</h3><p>(This is not a problem since Sun opens Java,maybe we make Flash our next target. )</p><p>One of the big dangers in our community is that people start putting non-free software into the system and they call it bonus. They say it is a nice addition, it gives more features. Yes it gives you more features at the cost of your freedom. When these things are distributed separately, they call it value added packages. And that term makes it stick about your values. It says it values your convenience only, don’t value your freedom. So I prefer to call them freedom subtracted packages. That makes a statement about my values.</p><p>But they also include them, incorporate them in various distributions of GNU/Linux system. For instance, Sun has a version of the GNU/Linux system which they call the Java Desktop. Now they are not giving credit either to Linux or GNU but that is not an important issue when we look at what they are doing which is really bad that is, including several non-free programs including Sun’s Java platform. Sun’s Java platform is not free software. You shouldn’t install. If you do install it, you are putting yourself at risk of creating other problems for other people. There are people who are so attracted to java - they think this idea that will run on all platforms is so exciting - that they stop paying attention to things like what to pay attention to. They will write programs in java, they will write free programs in java and offer to people and it turns out it doesn’t run on all platforms, it doesn’t run on a free platform.</p><p>You see, we have free java platforms. But they don’t implement all features yet. Sun keeps on adding features and our efforts are speeding up but they are still behind. So many of the java libraries or the newer language features, we don’t have yet. So if you use them in your free program, it would run on a free platform and you will find that your program is actually an inducement to people to install non-free software. The same thing is happening when websites use java or websites use flash.</p><p>The use of flash websites is a major problem for our community. People are working in free software for playing flash. And now it more or less handles just the display of things but it doesn’t handle reading input. If you see a website using flash, complain. Complain to the site developer saying you are excluding people who believe in maintaining their freedom. Please get rid of the flash from your site.</p><p>A similar problem occurs when people distribute files in word format. And peoples approach to this used to be find some way to arrange to read it. And I pointed out that this is actually not a right response in the long run. You see, people worked on figuring out the details of the secret of word format. And figured out a lot of them. So there is free software today like openoffice that can read word files. But it is still short term thinking just to address this problem as right because Microsoft can keep changing the word format. And every time they make word files in this new format and they send to other people and other people can’t read them. And so they feel like have to upgrade word as well and the result is a large number of these windows users are using new version of word and they send us these word files in a different format which our software can’t read. And maybe it is patented and we will get sued if we make our free software read.</p><p>To solve this office problem, we have to remove Microsoft’s control over the language that people use to communicate with each other and with themselves - like saving your files so you could read your files later. We have to refuse to use word format for this. When people send you a word file, therefore don’t cope with the situation by reading it. Instead it is much better to send back a message saying - please don’t ever send me word files. This is contributing to a serious social problem. But send it in public documented formats which everyone is free to implement so you are not giving a particular company any power it shouldn’t have.</p><p>Fundamentally, the use of non-free software program gives somebody power of the kind that nobody should have. And therefore software should be free. Computer users should always have the freedom to control their computers. And they should be free to cooperate with each other in doing so.</p><h3 id="RMS-on-Free-software-Vs-Opensource"><a href="#RMS-on-Free-software-Vs-Opensource" class="headerlink" title="RMS on Free software Vs Opensource"></a>RMS on Free software Vs Opensource</h3><p>… In 1998, some of them started another way of talking about free software where they call it opensource. And with this different name, they have associated a different set of ideas. They don’t say that this is a matter of the freedom that every user should have. In fact, they would often say that they recommend a development methodology which they say will generally produce more powerful and reliable software. And that may be true. I hope it is true. It would be nice if freedom provides as a byproduct, security of software. But it is a terrible mistake, I think, to focus all the attention on these short term practical benefits and ignore freedom itself. The danger is, then people would fail to defend their freedom when it is threatened as they wouldn’t recognize what it is.</p><p>So if you imagine two people, one who is convinced by the opensource philosophy and another who is convinced by the free software philosophy. And you show these people a powerful, reliable, convenient, non-free program. What are they going to say ?</p><p>The opensource guy would say - “I am surprised you were able to do such a good job without letting the users study the code and find the bugs for you. But I can argue with the facts. It seems a powerful and reliable program”. And he will probably use it. Where as the free software person will say - “I don’t care how powerful and convenient it is if it takes away my freedom. I wouldn’t pay such a high price for that convenience. I am going to get to work on a free replacement for this program right away before anybody else get tempted to use that program”.</p><p>One person would give up his freedom when ever you can offer him convenience in its return and the other would fight for his freedom. And if enough of you fight for your freedom, freedom may prevail.</p><h3 id="RMS-on-RMS"><a href="#RMS-on-RMS" class="headerlink" title="RMS on RMS"></a>RMS on RMS</h3><p><img src="/images/GPL_Richard.png" alt="GPL" title="Title is optional"></p><p>Now people sometimes have accused me of having a holier than thou attitude. I think that is not actually true. I don’t criticise and condemn people just because they don’t stand up for free software strongly as I do. As long as what they are doing is good, I will say what they are doing is good and I might suggest somethings they could do.</p><p>However, I do have a holy attitude because I am a saint. It is my job to be holy. I am saint iGNUcius of the church of Emacs. I bless your computer my child. Emacs started out as a text editor which became a way of life for many users because it could do almost everything without exiting Emacs. And ultimately a religion. We even have a great schism between two rival versions of Emacs. And now we have a saint too. Fortunately no gods. In this church, instead of gods, we have an editor.</p><p>To be a member of the church of Emacs, you must recite the confession of the faith. You must say, there is no system but GNU and Linux is one of its kernels. The church of Emacs has certain advantages compared with some other churches. To become a saint in the church of Emacs does not require celibacy. However, it does require living a life of moral purity. You must exorcise the evil proprietary operating systems that posses what ever of the computers under your control and install in all of them a holy free operating system instead. And then, only install free software on top of that. If you make this commitment to live by it, then you too would be a saint and you may eventually have a halo if you can find one because they don’t make them any more.</p><p>Sometimes, people ask me if it is a sin in the church of Emacs to use the editor Vi. It is true that Vi-Vi-Vi is the editor of the beast. But using a free version of Vi is not a sin but a penance. And sometimes, people ask me if my halo is really an old computer disc. This is not a computer disc. It is my halo. But it was a computer disc in a previous existence.</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Firefox 的意义]]></title>
      <url>http://fengchao.github.io/2016/04/06/Why-Firefox/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>1、Firefox的出现促进了竞争，使用户得到了好处很多人也许没有体会到，他们虽然是IE的用户，但是他们却是Firefox出现的最大受益者。从 99年前后IE3、IE4通过捆绑战术打败Netscape之后到2004年Firefox大流行之前，IE发布了三个版本，但是没有任何的实质性改进。 没有改进是因为IE没有缺点么？当然不是，这数年间多少病毒通过IE漏洞传播，多少恶意插件通过IE横行。以恶意插件为例，其实解决恶意插件技术上难度很 大么？IE上面提供一个插件管理器功能，就可以完全解决这个问题。然而这个技术问题前不久才在XpSp2版本中得到解决，为什么？原因很简单，没有竞争， 你不喜欢IE也没有办法，只有用。IE7目前宣布的特性中，最引人注意的标签浏览，Rss支持，增强的安全性，都是Firefox比IE老版本强的地方。这也让我们发现，IE用户之所以有新版本新特性可用，正是因为Firefox的出现给IE的垄断地位造成了威胁。所以IE用户是Firefox流行的最大受益者。</p><p>2、Firefox的出现有利于推广W3c Web标准化的网站设计</p><p>W3c web标准化设计思想要求把网页中的内容和样式分开，不使用Table进行布局。这样的好处是节约网络带宽，提高网页渲染的速度，降低浏览器的内存占用， 提高网站设计的效率，利于在不同设备里面浏览等等。这些我们这里不展开讲了，不然再写两三篇文章也说不完。大家可以去看《网站重构》 一书。然而这种设计思想和W3c标准长期被网站设计师们忽视，甚至故意的违反。这是因为市场上长期IE占有绝对多数的市场分额，而IE对W3c标准的支持 很差。在IE和Netscape的大战期间，微软为了得到垄断地位，也为了给潜在竞争者设置障碍，给IE增加了很多专有Html标记。这些标记很多都违反 了内容和样式分开的原则，还有些有专利和其他法律上的壁垒。这样就给其他 的浏览器发展造成了障碍。这形成了 一个恶性循环，使用这些非标准元素的网站越多，那么IE的垄断地位就会越稳固，而IE的垄断地位越稳固，使用这些非标准元素的网站也就会越多。然而正如前 面说的IE的垄断地位一旦固若金汤，微软就会不在乎用户需求，一意孤行。用户的合理要求就会被忽视。很多人埋怨手机上面的Wap页面太简单，网站太少。然 而大部分Web网站在手机上面也会变得支离破碎，甚至完全无法浏览。但是他们可能不知道的是，如果网站比较严格的遵守了W3c标准，那么在大多数手机里面 网站是可以正常浏览的（当然尺寸受到限制，显示的样子会有些差异），现在大部分智能手机是可以直接浏览XHtml网站的。然而，那些使用了IE非标准扩展 的网站在手机和其他移动设备一般都是无法浏览的，甚至可能会造成浏览器死机。也就是说，如果Firefox或者其他的比较符合W3c标准的浏览器更早的流 行的话，那么更多的网站就会支持W3c标准，我们早就可以在移动设备上面随意冲浪了。</p><p>3、Firefox的出现有利于提高网络安全恶意插件方面有一种对Firefox安全性的误解说，”Firefox的安全性来自用的人比较少，所有没有针对Firefox的恶意插件”。我经常听人提到这种误解，不光是不喜欢Firefox的人有这种误解，我发现很多非常喜欢Firefox的人也有这种误解，甚至因为这个误解他们说不要推广Firefox以免Firefox被恶人盯住。 这种误解来自于对恶意插件猖獗现状的误解，实际上恶意插件并不是一种技术上很难防止的东西。前面我们也提到了，微软如果做一个插件管理器就可以解决99% 的恶意插件了。现在恶意插件猖獗是微软因为没有竞争而不愿意投入人力和财力在IE安全性提高上面造成的。Xp2 sp2在Firefox的压力下，推出了插件管理器，虽然不能彻底解决问题，但是微软为了避免IE失去优势，必然会在IE7对这个功能进行增强。现在 Firefox上面没有一个恶意插件流行的主要原因是， Firefox在插件安装方面要检查用户确认网站安全，随时可以删除插件，以及比较完善的插件安全模型。Firefox比较完善的插件安全模型这点也很重 要。实际上Firefox的插件运行在Firefox的环境之中，他无法对Firefox以外的存储空间和用户信息进行破坏。这个IE的插件模型迥异，微 软的IE插件模型实际上是ActiveX是COM，COM是运行在整个操作系统范围内的，如果插件愿意甚至可以直接格式化用户硬盘。当然微软也有安全模型 来限制IE插件，比如插件不能自动安装等等，不能操作用户硬盘等等。但是3721等等非常强硬的恶意插件的泛滥证明微软的安全模型的脆弱（3721可以不 经用户允许就安装，还好他只是个恶意插件，他是病毒用户又会怎么样？）软件漏洞造成的安全问题方面前 些日子Firefox发现第一个漏洞的时候，许多美国媒体如获至宝大肆宣扬。这也反衬出来IE的安全性有多差，现在IE出现漏洞已经不算新闻了。据说刘蝶 雨在IE身上曾经连着7天找到7个漏洞。我们说软件有Bug，有漏洞是难免的，这没有办法。微软家大业大，IE程序非常复杂，有些漏洞不是什么不能原谅的 问题。但是问题在于对漏洞的反应：<br>根据安全公司Secunia的统计，2003年至2005年，Secunia针对Firefox1.x发布了22个安全警告，基本都是低危级；而同期针对IE6.x的警告有85个，高危级不在少数。Nitot将这种情况比作手指受伤与掉脑袋的区别。<br>Firefox对发现的漏洞都是很快的解决和发布，当然这不光光是因为Firefox的开发者勤奋，这也跟开源软件的组织方式和管理方式有关。<br>Mozilla欧洲总裁Tristan Nitot周一表示，一旦Firefox出现漏洞，Mozilla会迅速作出反应，在最短的时间里为用户提供解决方案，而微软在这一点上要差很多。</p><p>Nitot举例说：”9月6日，Mozilla接到了一个IDN缓冲问题报告；8日，该问题被意外公开；9日，我们通过改变设置暂时解决了这个问题，用户可以手动作出改变后者打上补丁；十天之内，我们发布了新版本，问题完全解决。”<br>然而IE的漏洞被发现以后，微软公司极少在短期内就作出解决的。</p><p>4、Firefox其实更简单更好用很 多人凭着随便一用就下结论说 Firefox不好用，或者说Firefox不适于普通用户。然而我们遇到了很多的反例，今天霍炬就给我讲了一个反例，他的一个朋友经营灯具的，前两天用 木马检查工具一检查机器发现木马成堆，所以开始用Firefox。霍炬帮他安装了几个插件，他立刻喜欢上了Firefox。这个家伙以前一直骂 Firefox难用的，说这个功能没有，那个功能没有的。这次才知道，原来他自己下载过Firefox，但是不会安装插件，很多好玩好用的插件都没见过，所以觉得Firefox太差劲。开源软件的推广中经常遇到这样的问题，因为开源的哲学是尊重用户的选择， 所以一个具有超级强大扩展功能的软件发行的时候，都不包含扩展包，让用户自己选择扩展。这样高端用户可以完全定制这个软件。Firefox也是这样的，所 以很多对开源哲学不了解的朋友，常常会被那些功能其实非常强大的软件的平凡外表所欺骗。这里的一个典型例子就是Linux，如果你直接下载Linux核心 的话，你甚至不知道怎么把它安装到电脑上去，所以产生了很多的Linux 安装版发行商，来帮用户把 Linux和好的开源软件打包并提供安装和配置工具。目前这种打包服务在Firefox社区中还比较少，所以很多初级用户对Firefox有这样那样的误 解。这也说明，我们国内的开源爱好者应该考虑多进行这方面的工作（国外的已经比较不错了，Firefox1.5刚刚发行BSD port里面就出现了）。</p><p>5、只有想不到的，没有Firefox做不到的</p><p>Firefox是一个高度可扩展的浏览器（同时很安全，前面讲过了），Firefox比IE出现要晚得多，但是各种各样的扩展数目比IE多得多。据说让keso一直忍受Firefox不断膨胀内存占用的主因是他放不下那些贴心的Firefox扩展。今年6-7月的时候，Firefox中文网做了一个10佳Firefox扩展的评选，被选中的有屏蔽广告的Adblock，有拓展标签浏览的Tab Mix，有提供拖动打开新网页功能的SuperDragAndGo，方便下载的FlashGot，有关联各种应用程序的Launchy，有鼠标花样玩法的All-in-One Gestures Extension，有可以方便的看天气预报的ForecastFox，有Rss浏览器Sage，有超级收藏工具ScrapBook，有帮你输入BBCODE/XHTML/HTML的BBcode。关于这些扩展的详细说明和下载地址，请看我的文章“Firefox中文网评选的10佳Firefox扩展”。以上说的拓展并不是全部，优秀拓展还有很多很多，简而言之，只有你想不到的拓展，没有Firefox做不到的功能。</p><p>如果你还没开始使用Firefox，为什么不从今天开始试试呢？不需要花一分钱，下载安装即可，也许你也可以发现一个新的世界。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo: Hello World]]></title>
      <url>http://fengchao.github.io/2016/04/06/hello-world/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Hexo-hey-admin"><a href="#Hexo-hey-admin" class="headerlink" title="Hexo-hey admin"></a>Hexo-hey admin</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ npm install -save hexo-hey</div></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p><h3 id="Hexo-image-generate"><a href="#Hexo-image-generate" class="headerlink" title="Hexo image generate"></a>Hexo image generate</h3><p>主页： <a href="https://github.com/akfish/hexo-migrator-image" target="_blank" rel="external">hexo-migrator-image</a><br>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-migrator-image --save</div></pre></td></tr></table></figure><p>使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo migrate image</div></pre></td></tr></table></figure><p>How Does It Work</p><p>This migrator scans all .md files in a hexo blog folder for Markdown’s image tags. Then downloads (remote) or copies (local) files to source/images folder and updates all urls in the posts. The images’ file names are SHA1 digest of its original url. A backup file named .md.#timestamp#.bak file will be created for each .md files every time. However it is better to use version control or make a copy just in case.</p><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><ul><li>hexo next - <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a></li></ul><h3 id="Plunins"><a href="#Plunins" class="headerlink" title="Plunins"></a>Plunins</h3><ul><li>hexo-all-minifier</li></ul><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Songbird -- Play music play the web]]></title>
      <url>http://fengchao.github.io/2016/04/06/Songbird-Play-music-play-the-web/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><img src="/images/songbird.png" alt="Songbird picture" title="Songbird"></p><p>“Songbird promises to be the Firefox of media players.”</p><p>—Aaron Boodman, Greasemonkey　　Songbird ( <a href="http://www.songbirdnest.com" target="_blank" rel="external">http://www.songbirdnest.com</a> ) :一个开源桌面网络播放器，除了具有一般播放器的功能外，还可以不用离开网页就播放其中的MP3. 它把网页当成一个可以播放,保存和订阅的动态播放列表。从 Songbird 自身来讲，它已经在媒体播放和网络浏览之间找到了一个恰当的平衡点。这就是 Songbird 显得与众不同的地方。它的核心开发人员曾经开发songbird.png过 Winmap 和 Yahoo!Music Engine.</p><p>详细使用情况，请观看使用简介。 　　<a href="http://www.songbirdnest.com/screencast/" target="_blank" rel="external">http://www.songbirdnest.com/screencast/</a></p><p>Songbird 建构在 XUL 框架之上，这点与 Firefox 类似，能够在 Windows、Mac OS X、Linux 之上运行。本身也支持扩展和皮肤，这使 Songbird 具有很好的开放性和延展性。虽然刚推出不久，但具有无限的潜力，很有可能改变人们听音乐的方式。成为下一代浏览器的代表。</p><p>当然，作为一个版本0.2的开发者预览版，bug 还是很多的,距离日常使用，还有一段距离。但是，其对待网络音乐的创新想法，已经一起了越来越多的人的注意。来自世界各地的软件爱好者正在积极的改进和完善它。相信不久的将来，这只唱歌的小鸟一定会变成飞舞的凤凰。</p><h2 id="2015-05-19-更新"><a href="#2015-05-19-更新" class="headerlink" title="2015-05-19 更新"></a>2015-05-19 更新</h2><p>Songbird1.0 已经正式发布了。Songbird 最独特的功能就是把浏览器与媒体播放器融合起来，在浏览网络的同时就可以方便的播放网页中的音乐。在这个在线播放逐渐成为主流的时代，Songbird 绝对有很大的发展潜力。作为 Mozilla 家族的一员，它和火狐、雷鸟一样，具有跨平台（Windows，Linux ，Mac）的特点，同样也遗传了耗费内存的缺点。个人比较喜欢简洁的风格，所以相对于 Songbird，我更喜欢使用 Audacious。</p><p>Songbird 是我参加的第一个开源项目。最早的时候，0.2 版大概，在尝鲜的时候发现播放器的界面是乱码。看代码之后发现是资源文件错误，虽然预留了国际化文件，但是并没有真正的汉化。于是花了两天的时间把程序汉 化了一遍，打包寄给了作者。看着一个程序在自己的工作下变得稍微有点完善，是一件很令人兴奋的事情：世界（中一个小软件的一个版本）在自己的作用下，发生 了切切实实的改变，而这个改变，会让世界更接近完美。</p><p>后来，Songbird 的翻译转移到网页上，Web2.0 的界面让翻译变得傻瓜化。而因为很少使用 Songbird，后面的许多新词条的翻译已经不是我做的了。但是从某种意义上说，Songbird 改变了我的人生轨迹。如果没有 Songbird，我还会做软件么？还会做 Linux 么？也许吧，但是概率至少也要打六折。在我看来，Songbird 不仅是唱歌的小鸟，更是扇动翅膀的蝴蝶。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络安全工具汇总]]></title>
      <url>http://fengchao.github.io/2016/04/06/Top-100-Network-security-tools/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>转自硅谷动力，天天安全网tulip翻译，原文在<a href="http://sectools.org/。" target="_blank" rel="external">http://sectools.org/。</a></p><p>在 2000和2003年非常成功的推出了安全工具调查后，Insecure.Org 非常高兴为大家带来2006年度的安全工具调查。我-Fyodor对nmap-hackers 邮件列表中的用户进行了调查，让大家来分享他们最喜欢用的工具，结果有3243名用户提供了反馈信息。我从反馈信息中选取了大家最喜欢的前100种工具， 并将它们进行了分类。建议安全界人士仔细阅读这份列表，并对不熟悉或未听说过的工具进行研究，相信会有很大帮助。我自己就从中发现了很多以前没有使用过但 非常好用的工具。当很多菜鸟问我“我不知道当一个黑客该从何开始”时，我就让他们来读读这篇文章。</p><p>受访者被要求列出各种平台上的开源和商业工具。商业工具会在列表中进行标注。Nmap Security Scanner 没有参与投票，因为调查是在Nmap的邮件列表中进行的。因为受访者多为黑客的原因，所以此列表中攻击型的工具偏多一些，防守型的则少一些。</p><p>列 表中每个工具都含有以下一种或几种属性：2003年调查列表中未出现的工具；相对于2003年调查列表排名升或降；需要花钱购买。但可以免 费获得限制、演示、试用版本软件；可以工作于Linux平台之上；可以工作于OpenBSD、FreeBSD、Solaris 或其它UNIX平台之上；可以工作于苹果Mac OS X平台之上；可以工作于微软Windows平台之上；提供命令行操作方式；提供图形化用户界面；在互联网上可以找到源代码。</p><p>如果您发现列表中的工具有更新或者有其它建议–或者有更好的工具图标 可以发送邮件给我。如果您的工具入选此列表了，或者您认为您网站的访客也许会对此列表感兴趣，欢迎您通过link banners把本文链接到您网站上。以下开始为正式列表，按受欢迎程度降序排列：</p><p>#1 Nessus：最好的UNIX漏洞扫描工具</p><p>Nessus 是最好的免费网络漏洞扫描器，它可以运行于几乎所有的UNIX平台之上。它不止永久升级，还免费提供多达11000种插件（但需要注册并接受EULA- acceptance–终端用户授权协议）。它的主要功能是远程或本地（已授权的）安全检查，客户端/服务器架构，GTK（Linux下的一种图形界 面）图形界面，内置脚本语言编译器，可以用其编写自定义插件，或用来阅读别人写的插件。Nessus 3 已经开发完成（now closed source），其现阶段仍然免费，除非您想获得最新的插件。</p><p>#2 Wireshark：网络嗅探工具</p><p>Wireshark （2006年夏天之前叫做 Ethereal）是一款非常棒的Unix和Windows上的开源网络协议分析器。它可以实时检测网络通讯数据，也可以检测其抓取的网络通讯数据快照文 件。可以通过图形界面浏览这些数据，可以查看网络通讯数据包中每一层的详细内容。Wireshark拥有许多强大的特性：包含有强显示过滤器语言 （rich display filter language）和查看TCP会话重构流的能力；它更支持上百种协议和媒体类型； 拥有一个类似tcpdump（一个Linux下的网络协议分析工具）的名为tethereal的的命令行版本。不得不说一句，Ethereal已经饱受许 多可远程利用的漏洞折磨，所以请经常对其进行升级，并在不安全网络或敌方网络（例如安全会议的网络）中谨慎使用之。</p><p>#3 Snort：一款广受欢迎的开源IDS（Intrusion Detection System）（入侵检测系统）工具</p><p>这 款小型的入侵检测和预防系统擅长于通讯分析和IP数据包登录（packet logging）。Snort除了能够进行协议分析、内容搜索和包含其它许多预处理程序，还可以检测上千种蠕虫病毒、漏洞、端口扫描以及其它可疑行为检 测。Snort使用一种简单的基于规则的语言来描述网络通讯，以及判断对于网络数据是放行还是拦截，其检测引擎是模块化的。 用于分析Snort警报的网页形式的引擎 Basic Analysis and Security Engine (BASE)可免费获得。</p><p>开源的Snort为个人、小企业、集团用户提供良好的服务。其母公司SourceFire提供丰富的企业级特性和定期升级以丰富其产品线。提供（必须注册）5天免费的规则试用，您也可以在Bleeding Edge Snort找到很多免费规则。</p><p>#4 Netcat：网络瑞士军刀</p><p>这 个简单的小工具可以读和写经过TCP或UDP网络连接的数据。它被设计成一个可靠的可以被其它程序或脚本直接和简单使用的后台工具。同时， 它也是一个功能多样的网络调试和检查工具，因为它可以生成几乎所有您想要的网络连接，包括通过端口绑定来接受输入连接。Netcat最早由Hobbit在 1995年发布，但在其广为流传的情况下并没有得到很好的维护。现在nc110.tgz已经很难找了。这个简单易用的工具促使了很多人写出了很多其它 Netcat应用，其中有很多功能都是原版本没有的。其中最有趣的是Socat，它将Netcat扩展成可以支持多种其它socket类型，SSL加密， SOCKS代理，以及其它扩展的更强大的工具。它也在本列表中得到了自己的位置（第71位）。还有Chris Gibson’s Ncat，能够提供更多对便携设备的支持。其它基于Netcat的工具还有OpenBSD’s nc，Cryptcat，Netcat6，PNetcat，SBD，又叫做GNU Netcat。</p><p>#5 Metasploit Framework：黑掉整个星球</p><p>2004 年Metasploit的发布在安全界引发了强烈的地震。没有一款新工具能够一发布就挤进此列表的15强（也就是说2000年和 2003年的调查没有这种情况），更何况此工具更在5强之列，超过了很多广为流传的诞生了几十年的老牌工具。它是一个强大的开源平台，供开发、测试和使用 恶意代码。这种可扩展的模型将负载控制、编码器、无操作生成器和漏洞整合在一起，使得Metasploit Framework成为一种研究高危漏洞的途径。它自带上百种漏洞，还可以在online exploit building demo（在线漏洞生成演示）看到如何生成漏洞。这使得您自己编写漏洞变得更简单，它势必将提升非法shellcode代码的水平，扩大网络阴暗面。与其 相似的专业漏洞工具，例如Core Impact和Canvas已经被许多专业领域用户使用。Metasploit降低了这种能力的门槛，将其推广给大众。</p><p>#6 Hping2：一种网络探测工具，是ping的超级变种</p><p>这 个小工具可以发送自定义的ICMP，UDP和TCP数据包，并接收所有反馈信息。它的灵感来源于ping命令，但其功能远远超过ping。 它还包含一个小型的路由跟踪模块，并支持IP分段。此工具可以在常用工具无法对有防火墙保护的主机进行路由跟踪/ping/探测时大显身手。它经常可以帮 助您找出防火墙的规则集，当然还可以通过它来学习TCP/IP协议，并作一些IP协议的实验。</p><p>#7 Kismet：一款超强的无线嗅探器</p><p>Kismet 是一款基于命令行（ncurses）的802.11 layer2无线网络探测器、嗅探器、和入侵检测系统。它对网络进行被动嗅探（相对于许多主动工具，例如NetStumbler），可以发现隐形网络（非 信标）。它可以通过嗅探TCP、UDP、ARP和DHCP数据包来自动检测网络IP段，以Wireshark/TCPDump兼容格式记录通讯日志，更加 可以将被检测到的网络分块并按照下载的分布图进行范围估计。如您所想，这款工具一般被wardriving所使用。嗯！还有warwalking、 warflying和warskating……</p><p>#8 Tcpdump：最经典的网络监控和数据捕获嗅探器</p><p>在 Ethereal（Wireshark）出现之前大家都用Tcpdump，而且很多人现在还在一直使用。它也许没有Wireshark那么 多花里胡哨的东西（比如漂亮的图形界面，亦或数以百计的应用协议逻辑分析），但它能出色的完成很多任务，并且漏洞非常少，消耗系统资源也非常少。它很少添 加新特性了，但经常修复一些bug和维持较小的体积。它能很好的跟踪网络问题来源，并能监控网络活动。其Windows下的版本叫做WinDump。 Libpcap/WinPcap的包捕获库就是基于TCPDump，它也用在Nmap等其它工具中。</p><p>#9 Cain and Abel：Windows平台上最好的密码恢复工具</p><p>UNIX 用户经常声称正是因为Unix平台下有很多非常好的免费安全工具，所以Unix才会成为最好的平台，而Windows平台一般不在他 们的考虑范围之内。他们也许是对的，但Cain &amp; Abel确实让人眼前一亮。这种只运行于Windows平台的密码恢复工具可以作很多事情。它可以通过嗅探网络来找到密码、利用字典破解加密密码、暴力破 解密码和密码分析、记录VoIP会话、解码非常复杂的密码、星号查看、剥离缓存密码以及分析路由协议。另外其文档也很齐全（well documented）。</p><p>#10 John the Ripper：一款强大的、简单的以及支持多平台的密码破解器</p><p>John the Ripper是最快的密码破解器，当前支持多种主流Unix （官方支持11种，没有计算不同的架构）、DOS、Win32、BeO和OpenVMS。它的主要功能就是检测弱Unix密码。它支持主流Unix下的多 种（3种）密码哈希加密类型，它们是Kerberos、AFS以及Windows NT/2000/XP LM。其它哈希类型可以通过补丁包加载。如果您希望从一些单词表开始的话，您可以在这里、这里和这里找到。</p><p>11 Ettercap：为交换式局域网提供更多保护</p><p>Ettercap 是一款基于终端的以太网络局域网嗅探器/拦截器/日志器。它支持主动和被动的多种协议解析（甚至是ssh和https这种加 密过的）。还可以进行已建立连接的数据注入和实时过滤，保持连接同步。大部分嗅探模式都是强大且全面的嗅探组合。支持插件。能够识别您是否出在交换式局域 网中，通过使用操作系统指纹（主动或被动）技术可以得出局域网结构。</p><p>#12 Nikto：非常全面的网页扫描器</p><p>Nikto 是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3200种有潜在危险的文件 /CGIs；超过625种服务器版本；超过230种特定服务器问题。扫描项和插件可以自动更新（如果需要）。基于Whisker/libwhisker完 成其底层功能。这是一款非常棒的工具，但其软件本身并不经常更新，最新和最危险的可能检测不到。</p><p>#13 Ping/telnet/dig/traceroute/whois/netstat：基本命令</p><p>虽 然有很多重型的高科技网络安全工具，但是不要忘记其基础！所有网络安全人士都要对这些基本命令非常熟悉，因为它们对大多数平台都适用（在 Windows平台上whois为tracert）。它们可以随手捏来，当然如果需要使用一些更高级的功能可以选择Hping2和Netcat。</p><p>#14 OpenSSH / PuTTY / SSH：访问远程计算机的安全途径</p><p>SSH（Secure Shell）现在普遍应用于登录远程计算机或在其上执行命令。它为不安全网络上的两台不互信计算机间通讯提供安全加密，代替非常不可靠的 telnet/rlogin/rsh交互内容。大多UNIX使用开源的OpenSSH服务器和客户端程序。Windows用户更喜欢免费的PuTTY客户 端，它也可以运行在多种移动设备上。还有一些Windows用户喜欢使用基于终端的OpenSSH模拟程序Cygwin。还有其它很多收费和免费的客户 端。您可以在这里和这里找到。</p><p>#15 THC Hydra：支持多种服务的最快的网络认证破解器</p><p>如果您需要暴力破解一个 远程认证服务，Hydra经常会是选择对象。它可以同时对30个以上的端口进行基于字典的快速破解，包括 telnet、ftp、http、https、smb、多种数据库及其它服务。和THC Amap一样，此Hydra版本来自于民间组织THC。</p><p>#16 Paros proxy：网页程序漏洞评估代理</p><p>基于Java的网页程序漏洞评估代理。支持实时编辑和浏览HTTP/HTTPS信息，修改例如Cookie和表字段中的内容。它包含有网页通讯记录器、网页小偷（web spider）、哈希计算器和一个常用网页程序攻击扫描器，例如SQL注入和跨网站脚本等。</p><p>#17 Dsniff：一款超强的网络评估和渗透检测工具套装</p><p>由Dug Song精心设计并广受欢迎的这款套装包含很多工具。Dsniff、filesnarf、mailsnarf、msgsnarf、urlsnarf和 webspy通过被动监视网络以获得敏感数据（例如密码、邮件地址、文件等）。Arpspoof、dnsspoof和macof能够拦截一般很难获取到的 网络通讯信息（例如由于使用了第二层转换（layer-2 switching））。Sshmitm和webmitm通过ad-hoc PKI中弱绑定漏洞对ssh和https会话进行重定向实施动态monkey-in-the-middle（利用中间人攻击技术，对会话进行劫持）攻击。 Windows版本可以在这里获取。总之，这是一个非常有用的工具集。它能完成几乎所有密码嗅探需要作的工作。</p><p>#18 NetStumbler：免费的Windows 802.11嗅探器</p><p>Netstumbler 是广为人知的寻找开放无线访问接入点的Windows工具（”wardriving”）。其PDA上的WinCE系统 版本名叫Ministumbler。此软件当前免费，但只能够运行在Windows平台上，且代码不公开。它使用很多主动方法寻找WAP，而Kismet 或KisMAC则更多使用被动嗅探。</p><p>#19 THC Amap：一款应用程序指纹扫描器</p><p>Amap是一款很棒的程序，它可 以检测出某一端口正在被什么程序监听。因为其独有的version detection特性，所以其数据库不会象Nmap一样变得很大，在Nmap检测某一服务失败或者其它软件不起作用时可以考虑使用之。Amap的另一特 性是其能够解析Nmap输出文件。这也是THC贡献的另一款很有价值的工具。</p><p>#20 GFI LANguard：一款Windows平台上的商业网络安全扫描器</p><p>GFI LANguard通过对IP网络进行扫描来发现运行中的计算机，然后尝试收集主机上运行的操作系统版本和正在运行的应用程序。我曾经尝试收集到了 Windows主机上的service pack级别、缺少的安全更新、无线访问接入点、USB设备、开放的共享、开放的端口、正在运行的服务和应用程序、主要注册表项、弱密码、用户和组别以及 其它更多信息。扫描结果保存在一份可自定义/可查询的HTML报告文档中。它还含有一个补丁管理器，可以检查并安装缺少的补丁。试用版可以免费获得，但只 能使用30天。</p><p>#21 Aircrack：最快的WEP/WPA破解工具</p><p>Aircrack是一套用于破解 802.11a/b/g WEP和WPA的工具套装。一旦收集到足够的加密数据包它可以破解40到512位的WEP密匙，它也可以通过高级加密方法或暴力破解来破解WPA 1或2网络。套装中包含airodump（802.11数据包捕获程序）、aireplay （802.11数据包注入程序）、aircrack（静态WEP和WPA-PSK破解），和airdecap（解密WEP/WPA捕获文件）。</p><p>#22 Superscan：只运行于Windows平台之上的端口扫描器、ping工具和解析器</p><p>SuperScan是一款Foundstone开发的免费的只运行于Windows平台之上的不开源的TCP/UDP端口扫描器。它其中还包含许多其它网络工具，例如ping、路由跟踪、http head和whois。</p><p>#23 Netfilter：最新的Linux核心数据包过滤器/防火墙</p><p>Netfilter 是一款强大的运行于标准Linux核心上的包过滤器。它集成了用户空间IP列表工具。当前，它支持包过滤（无状态或有状 态）、所有类型的网络地址和端口转换（NAT/NAPT）并支持多API层第三方扩展。它包含多种不同模块用来处理不规则协议，例如FTP。其它UNIX 平台请参考Openbsd PF（只用于OpenBSD）或者IP Filter。许多个人防火墙（personal firewalls）都支持Windows （Tiny、Zone Alarm、Norton、Kerio…），但都不提供上述IP列表。微软在Windows XP SP2中集成了一款非常基础的防火墙，如果您不安装它，它就会不断地提示您安装。</p><p>#24 Sysinternals：一款强大的非常全面的Windows工具合集</p><p>Sysinternals为Windows低级入侵提供很多非常有用的小工具。其中一部分是免费的，有些还附有源代码，其它是需要付费使用的。受访者最喜欢此集合中的以下工具：</p><p>ProcessExplorer 监视所有进程打开的所有文件和目录（类似Unix上的LSoF）。</p><p>PsTools 管理（执行、挂起、杀死、查看）本地和远程进程。</p><p>Autoruns 发现系统启动和登陆时加载了哪些可执行程序。</p><p>RootkitRevealer 检测注册表和文件系统API异常，用以发现用户模式或内核模式的rootkit工具。</p><p>TCPView 浏览每个进程的TCP和UDP通讯终点（类似Unix上的Netstat）。</p><p>生产此软件的公司已被微软于2005年收购，所以其未来产品线特征无法预测。</p><p>#25 Retina：eEye出品的商业漏洞评估扫描器</p><p>象Nessus一样，Retina的功能是扫描网络中所有的主机并报告发现的所有漏洞。eEye出品，此公司以其security research而闻名。</p><p>#26 Perl / Python / Ruby：简单的、多用途的脚本语言</p><p>常 用的安全问题都能在网上找到工具解决，但使用脚本语言您可以编写您自己的（或编辑现有的）工具，当您需要解决某种特定问题的时候。快速、简 单的脚本语言可以测试、发现漏洞甚至修复系统漏洞。CPAN上充满了类似Net：：RawIP和执行协议的程序模块，可以使您的工作更加轻松。</p><p>#27 L0phtcrack：Windows密码猜测和恢复程序</p><p>L0phtCrack 也叫作LC5，用来尝试通过哈希（通过某种访问方式获得的）方法破解诸如Windows NT/2000工作站、联网服务器、主域控制器、或活动目录密码，有时它也可以通过嗅探获得密码的哈希值。它还可以通过多种手段来猜测密码（字典、暴力破 解等等）。Symantec公司2006年已经停止了LC5的开发，但LC5 installer的安装文件随处可以找到。免费试用版只能使用15天，Symantec已经停止出售此软件的注册码，所以如果您不想放弃使用它，就必须 找到一个与其对应的注册码生成器（key generator）。因为Symantec不再维护此软件，所以最好尝试用Cain and Abel或John the Ripper来代替之。</p><p>#28 Scapy：交互式数据包处理工具</p><p>Scapy是一款强大的 交互式数据包处理工具、数据包生成器、网络扫描器、网络发现工具和包嗅探工具。它提供多种类别的交互式生成数据包或数 据包集合、对数据包进行操作、发送数据包、包嗅探、应答和反馈匹配等等功能。Python解释器提供交互功能，所以要用到Python编程知识（例如 variables、loops、和functions）。支持生成报告，且报告生成简单。</p><p>#29 Sam Spade：Windows网络查询免费工具</p><p>Sam Spade为许多网络查询的一般工作提供了图形界面和方便的操作。此工具设计用于跟踪垃圾信息发送者，但它还可以用于许多其它的网络探查、管理和安全工 作。它包含许多有用的工具，例如ping、nslookup、whois、dig、路由跟踪、查找器、原始HTTP网页浏览器、DNS地址转换、SMTP 中继检查、网站搜索等等。非Windows用户可以在线使用更多其它工具。</p><p>#30 GnuPG / PGP ：对您的文件和通讯进行高级加密</p><p>PGP是Phil Zimmerman出品的著名加密程序，可以使您的数据免受窃听以及其它危险。GnuPG是一款口碑很好的遵守PGP标准的开源应用（可执行程序名为gpg）。GunPG是免费的，而PGP对某些用户是收费的。</p><p>#31 Airsnort：802.11 WEP加密破解工具</p><p>AirSnort是一款用来恢复加密密码的无线LAN（WLAN）工具。Shmoo Group出品，工作原理是被动监控传输信息，当收集到足够多的数据包后开始计算加密密码。Aircrack和它很像。</p><p>#32 BackTrack：一款极具创新突破的Live（刻在光盘上的，光盘直接启动） 光盘自启动Linux系统平台</p><p>这款卓越的光盘自启动Linux系统是由Whax和Auditor合并而成。它以其超级多的安全和防护工具配以丰富的开发环境而闻名。重点在于它的用户模块化设计，用户可以自定义将哪些模块刻到光盘上，例如自己编写的脚本、附加工具、自定义内核等等。</p><p>#33 P0f：万能的被动操作系统指纹工具</p><p>P0f 能够通过捕获并分析目标主机发出的数据包来对主机上的操作系统进行鉴别，即使是在系统上装有性能良好的防火墙的情况下也没有问题。 P0f不增加任何直接或间接的网络负载，没有名称搜索、没有秘密探测、没有ARIN查询，什么都没有。某些高手还可以用P0f检测出主机上是否有防火墙存 在、是否有NAT、是否存在负载平衡器等等！</p><p>#34 Google：人人喜爱的搜索引擎</p><p>Google当然不是什么安全工 具，但是它超级庞大的数据库却是安全专家和入侵者最好的资源。如果您想了解某一公司，您可以直接用它搜索 “site：target-domain.com”，您可以获得员工姓名、敏感信息（通常公司不对外公开的，但在Google上就难说了）、公司内部安装 的软件漏洞等等。同样，如果您在Google上发现一个有某个漏洞的网站，Google还会提供给您其它有相同漏洞的网站列表。其中利用Google进行 黑客活动的大师Johny Long建立了一个Google黑客数据库（Google Hacking Database）还出版了一本如何用Google进行黑客活动的书Google Hacking for Penetration Testers。</p><p>#35 WebScarab：一个用来分析使用HTTP和HTTPS协议的应用程序框架</p><p>它 的原理很简单，WebScarab记录它检测到的会话内容（请求和应答），使用者可以通过多种形式来查看记录。WebScarab的设计目 的是让使用者可以掌握某种基于HTTP（S）程序的运作过程；也可以用它来调试程序中较难处理的bug，也可以帮助安全专家发现潜在的程序漏洞。</p><p>#36 Ntop：网络通讯监控器</p><p>Ntop 以类似进程管理器的方式显示网络使用情况。在应用程序模式下，它能显示用户终端上的网络状况。在网页模式下，它作为网页服务器，以 HTML文档形式显示网络状况。它是NetFlow/sFlow发射和收集器，通过一个基于HTTP的客户端界面来生成以ntop为中心的监控程序， RRD（Round Robin Database）（环形数据库）用来持续储存网络通讯状态信息。</p><p>#37 Tripwire：很老的文件完整性检查器</p><p>一 款文件和目录完整性检查器。Tripwire是一种可以帮助系统管理员和一般用户监控某一特定文件或目录变化的工具。可以用以对系统文件作 日常（例如：每天）检查，Tripwire可以向系统管理员通报文件损坏或被篡改情况，所以这是一种周期性的文件破坏控制方法。免费的开源Linux版本 可以在Tripwire.Org下载到。AIDE是UNIX平台的Tripwire替代品。或者Radmind、RKHunter和chkrootkit 也是很好的选择。Windows用户请使用Sysinternals出品的RootkitRevealer。</p><p>#38 Ngrep：方便的数据包匹配和显示工具</p><p>ngrep 尽可能多的去实现GNU grep的功能，将它们应用于网络层。Ngrep是一款pcap-aware工具，它允许指定各种规则式或16进制表达式去对数据负载或数据包进行匹配。 当前支持TCP、UDP、以太网上的ICMP、PPP、SLIP、FDDI、令牌环（Token Ring）和空接口（null interfaces），还能理解类似Tcpdump和snoop等一样形式的bpf过滤器逻辑。</p><p>#39 Nbtscan：在Windows网络上收集NetBIOS信息</p><p>NBTscan是一款在IP网络上扫描NetBIOS名称信息的工具。它通过给指定范围内所有地址发送状态查询来获得反馈信息并以表形式呈现给使用者。每一地址的反馈信息包括IP地址、NetBIOS计算机名、登录用户、MAC地址。</p><p>#40 WebInspect：强大的网页程序扫描器</p><p>SPI Dynamics’ WebInspect应用程序安全评估工具帮您识别已知和未知的网页层漏洞。它还能检测到Web服务器的配置属性，以及进行常见的网页攻击，例如参数注入、跨网站脚本、目录游走等等。</p><p>#41 OpenSSL：最好的SSL/TLS加密库</p><p>OpenSSL 项目的目的是通过开源合作精神开发一种健壮的、可以和同类型商业程序媲美的、全功能的，且开源的应用于SSL v2/v3（Secure Sockets Layer）和TLS v1（Transport Layer Security）协议的普遍适用的加密库工具集。本项目由世界范围内的志愿者们维护，他们通过互联网联络、计划和开发OpenSSL工具集及其相关文 档。</p><p>#42 Xprobe2：主动操作系统指纹工具</p><p>XProbe是一款远程主机操作系统探查工具。开发者基于和Nmap相同的一些技术（same techniques），并加入了自己的创新。Xprobe通过ICMP协议来获得指纹。</p><p>#43 EtherApe：EtherApe是Unix平台上的模仿etherman的图形界面网络监控器</p><p>包含连接层、IP和TCP三种模式，EtherApe网络活动图通过不同颜色来标识不同协议。主机和连接的图形大小随通讯情况而变化。它支持以太网、FDDI、令牌环、ISDN、PPP和SLIP设备。它可以实施过滤网络通讯，也可以抓取网络通讯快照文件。</p><p>#44 Core Impact：全自动的全面入侵检测工具</p><p>Core Impact可不便宜（先准备个上万美元吧），但它却是公认的最强的漏洞检测工具。它有一个强大的定时更新的专业漏洞数据库，它可以轻易的黑掉一台计算 机，并以它为跳板再去作别的事情。如果您买不起Core Impact，可以看看比较便宜的Canvas或者免费的Metasploit Framework。当然，三个同时用是最好的了。</p><p>#45 IDA Pro：Windows或Linux反编译器和调试器</p><p>反 编译器是一块很重要的安全研究方向。它可以帮您拆解微软的补丁，以了解微软未公开并悄悄修补的漏洞，或直接以二进制的方式对某个服务器进行 检测，以找出为何某个存在的漏洞不起作用。反编译器有很多，但IDA Pro是遵守二进制包事实标准（de-facto standard）的恶意代码和漏洞研究分析工具。这个图形化的、可编程的、可扩展的、支持多处理器的反编译器现在有了一个和Windows一模一样的 Linux（命令行模式）版本。</p><p>#46 SolarWinds：网络发现/监控/攻击系列工具</p><p>SolarWinds生产和销售了许多专业的系统管理工具。安全相关的包括许多网络发现扫描器、一个SNMP暴力破解器、路由器密码解密器、TCP连接重置程序、最快最易用的一个路由器设置下载和上传程序等等。</p><p>#47 Pwdump：一款Windows密码恢复工具</p><p>Pwdump可以从Windows主机中取得NTLM和LanMan哈希值，无论系统密码是否启用。它还能显示系统中存在的历史密码。数据输出格式为L0phtcrack兼容格式，也可以以文件形式输出数据。</p><p>#48 LSoF：打开文件列表</p><p>这是一款Unix平台上的诊断和研究工具，它可以列举当前所有进程打开的文件信息。它也可以列举所有进程打开的通讯socket（communications sockets）。Windows平台上类似的工具有Sysinternals。</p><p>#49 RainbowCrack：极具创新性的密码哈希破解器</p><p>RainbowCrack 是一款使用了大规模内存时间交换（large-scale time-memory trade-off）技术的哈希破解工具。传统的暴力破解工具会尝试每一个可能的密码，要破解复杂的密码会很费时。RainbowCrack运用时间交换 技术对破解时间进行预计算，并将计算结果存入一个名叫”rainbow tables”的表里。预计算确实也会花费较长时间，但相对暴力破解来说则短多了，而且一旦预计算完成破解开始，那么破解所需要的时间就非常非常短了。</p><p>#50 Firewalk：高级路由跟踪工具</p><p>Firewalk使用类似路由跟踪的技术来分析IP数据包反馈，以确定网关ACL过滤器类型和网络结构。这款经典的工具在2002年十月由scratch重写。这款工具的大部分功能Hping2的路由跟踪部分也都能实现。</p><p>#51 Angry IP Scanner：一款非常快的Windows IP 扫描器和端口扫描器</p><p>Angry IP Scanner能够实现最基本的Windows平台上的主机发现和端口扫描。它的体积非常的小，它还可以通过挂载插件（a few plugins）来获得主机其它信息。</p><p>#52 RKHunter：一款Unix平台上的Rootkit检测器</p><p>RKHunter是一款检测例如rootkit、后门、漏洞等恶意程序的工具。它采用多种检测手段，包括MD5哈希值对比、rootkits原始文件名检测、文件权限检测，以及LKM和KLD模块中的可疑字符串检测。</p><p>#53 Ike-scan：VPN检测器和扫描器</p><p>Ike- scan是一款检测IKE（Internet Key Exchange）服务传输特性的工具，IKE是VPN网络中服务器和远程客户端建立连接的机制。在扫描到VPN服务器的IP地址后，将改造过的IKE数 据包分发给VPN网中的每一主机。只要是运行IKE的主机就会发回反馈来证明它存在。此工具然后对这些反馈数据包进行记录和显示，并将它们与一系列已知的 VPN产品指纹进行对比。Ike-scan的VPN指纹包含来自Checkpoint、Cisco、Microsoft、Nortel和 Watchguard的产品。</p><p>#54 Arpwatch：持续跟踪以太网/IP地址配对，可以检查出中间人攻击</p><p>Arpwatch是LBNL网络研究组出品的一款经典的ARP中间人（man-in-the-middle）攻击检测器。它记录网路活动的系统日志，并将特定的变更通过Email报告给管理员。Arpwatch使用LibPcap来监听本地以太网接口ARP数据包。</p><p>#55 KisMAC：一款Mac OS X上的图形化被动无线网络搜寻器</p><p>这 款Mac OS X下非常流行的搜寻器和Kismet功能差不多，但和Kismet不同的是Kismet是基于命令行的，而KisMac有很漂亮的图形化界面，在OS X上出现得也比Kismet早。它同时还提供映射、Pcap兼容格式数据输入、登录和一些解密、验证破解功能。</p><p>#56 OSSEC HIDS：一款开源的基于主机的入侵检测系统</p><p>OSSEC HIDS的主要功能有日志分析、完整性检查、rootkit检测、基于时间的警报和主动响应。除了具有入侵检测系统功能外，它还一般被用在SEM/SIM （安全事件管理（SEM： Security Event Management）/安全信息管理（SIM：Security Information Management））解决方案中。因其强大的日志分析引擎，ISP（Internet service provider）（网络服务提供商）、大学和数据中心用其监控和分析他们的防火墙、入侵检测系统、网页服务和验证等产生的日志。</p><p>#57 Openbsd PF：OpenBSD数据包过滤器</p><p>象 其它平台上的Netfilter和IP Filter一样，OpenBSD用户最爱用PF，这就是他们的防火墙工具。它的功能有网络地址转换、管理TCP/IP通讯、提供带宽控制和数据包分级控 制。它还有一些额外的功能，例如被动操作系统检测。PF是由编写OpenBSD的同一批人编写的，所以您完全可以放心使用，它已经经过了很好的评估、设计 和编码以避免暴露其它包过滤器（other packet filters）上的类似漏洞。</p><p>#58 Nemesis：简单的数据包注入</p><p>Nemesis 项目设计目的是为Unix/Linux（现在也包含Windows了）提供一个基于命令行的、小巧的、人性化的IP堆栈。此工 具套装按协议分类，并允许对已注入的数据包流使用简单的shell脚本。如果您喜欢Nemesis，您也许对Hping2也会感兴趣，它们是互补的关系。</p><p>#59 Tor：匿名网络通讯系统</p><p>Tor 是一款面向希望提高其网络安全性的广大组织和大众的工具集。Tor的功能有匿名网页浏览和发布、即时信息、irc、ssh以及其它一些 TCP协 议相关的功能。Tor还为软件开发者提供一个可开发内置匿名性、安全性和其它私密化特性的软件平台。在Vidalia可以获得跨平台的图形化界面。</p><p>#60 Knoppix：一款多用途的CD或DVD光盘自启动系统</p><p>Knoppix 由一系列典型的GNU/Linux软件组成，可以自动检测硬件环境，支持多种显卡、声卡、SCSI和USB设备以及其它外围设 备。KNOPPIX作为一款高效的Linux光盘系统，可以胜任例如桌面系统、Linux教学光盘、救援系统等多种用途，经过这次在nmap中调查证实， 它也是一款很小巧的安全工具。如果要使用更专业的Linux安全系统请看BackTrack。</p><p>#61 ISS Internet Scanner：应用程序漏洞扫描器</p><p>Internet Scanner是由Christopher Klaus在92年编写的一款开源的扫描器工具。现在这款工具已经演变成了一个市值上亿美元生产无数安全产品的公司。</p><p>#62 Fport：Foundstone出品的加强版netstat</p><p>Fport 可以报告所有本地机上打开的TCP/IP和UDP端口，并显示是何程序打开的端口。所以用它可以快速识别出未知的开放端口以及与其 相关的应用程序。它只有Windows版本，但现在很多UNIX系统上的netstat也提供同样的功能（Linux请用’netstat -pan’）。SANS article有Fport的使用说明和结果分析方法。</p><p>#63 chkrootkit：本地rootkit检测器</p><p>chkrootkit 是一款小巧易用的Unix平台上的可以检测多种rootkit入侵的工具。它的功能包括检测文件修改、 utmp/wtmp/last日志修改、界面欺骗（promiscuous interfaces）、恶意核心模块（malicious kernel modules）。</p><p>#64 SPIKE Proxy：HTTP攻击</p><p>Spike Proxy是一款开源的以发现网站漏洞为目的的HTTP代理。它是Spike Application Testing Suite的一部分，功能包括自动SQL注入检测、 网站爬行（web site crawling）、登录列表暴力破解、溢出检测和目录游走检测。</p><p>#65 OpenBSD：被认为是最安全的操作系统</p><p>OpenBSD 是将安全作为操作系统首要任务的操作系统之一，甚至有时安全性级别要高于易用性，所以它骄人的安全性是不言而喻的。 OpenBSD也非常重视系统的稳定性和对硬件的支持能力。也许他们最伟大的创举就是创造了OpenSSH。 OpenBSD用户对此系统之上的[pf]（OpenBSD上的防火墙工具，本列表中第57位有介绍）也褒奖有佳。</p><p>#66 Yersinia：一款支持多协议的底层攻击工具</p><p>Yersinia 是一款底层协议攻击入侵检测工具。它能实施针对多种协议的多种攻击。例如夺取生成树的根角色（生成树协议：Spanning Tree Protocol），生成虚拟CDP（Cisco发现协议：Cisco Discovery Protocol）邻居、在一个HSRP（热等待路由协议：Hot Standby Router Protocol）环境中虚拟成一个活动的路由器、制造假DHCP反馈，以及其它底层攻击。</p><p>#67 Nagios：一款开源的主机、服务和网络监控程序</p><p>Nagios 是一款系统和网络监控程序。它可以监视您指定的主机和服务，当被监视对象发生任何问题或问题被解决时发出提示信息。它的主要功能 有监控网络服务（smtp、pop3、http、nntp、ping等等）、监控主机资源（进程负载、硬盘空间使用情况等等）、当发现问题或问题解决时通 过多种形式发出提示信息（Email、寻呼机或其它用户定义的方式）。</p><p>#68 Fragroute/Fragrouter：一款网络入侵检测逃避工具集</p><p>Fragrouter 是一款单向分段路由器，发送（接收）IP数据包都是从攻击者到Fragrouter，将数据包转换成分段数据流发给受害者。很多入侵检测系统都不能重建一 段被视为一个整体的网络数据（通过IP分段和TCP流重组），详情请见这篇文章（this classic paper）。Fragrouter可以帮助骇客在逃避入侵检测后发起基于IP的攻击。它是Dug Song出品的NIDSbench套装中的一部分。Fragroute是Dug song出品的另一款和Fragrouter相似的工具。</p><p>#69 X-scan：一款网络漏洞扫描器</p><p>一 款多线程、支持插件的漏洞扫描器。X-Scan主要功能有全面支持NASL（Nessus攻击脚本语言：Nessus Attack Scripting Language）、检测服务类型、远程操作系统类型（版本）检测、弱用户名/密码匹配等等。最新版本可以在这里获取。请注意这是一个中文网站（原文为英 文，所以原文作者提醒英文读者这是个中文网站）。</p><p>#70 Whisker/libwhisker：Rain.Forest.Puppy出品的CGI漏洞扫描器和漏洞库</p><p>Libwhisker 是一款Perl模板集用来测试HTTP。它的功能是测试HTTP服务器上是否存在许多已知的安全漏洞，特别是CGI漏 洞。Whisker是一款基于libwhisker的扫描器，但是现在大家都趋向于使用Nikto，它也是基于libwhisker的。</p><p>#71 Socat：双向数据传输中继</p><p>类 似于Netcat的工具，可以工作于许多协议之上，运行于文件、管道、设备（终端或调制解调器等等）、socket（Unix、IP4、 IP6-raw、UDP、TCP）、Socks4客户端、代理服务器连接、或者SSL等等之间。它提供forking、logging和dumping， 和不同模式的交互式处理通讯，以及更多其它选项。它可以作为TCP中继（单次触发：one-shot或者daemon（Internet中用于邮件收发的 后台程序））、作为基于daemon的动态Sockes化（socksifier）、作为Unix平台上sockets的shell接口、作为IP6中 继、将面向TCP的程序重定向成串行线路（Serial Line）程序、或者建立用来运行客户端或服务器带有网络连接的shell脚本相关安全环境（su和chroot）。</p><p>#72 Sara：安全评审研究助手</p><p>SARA是一款源于infamous SATAN扫描器的漏洞评估工具。此工具大约两个月更新一次，出品此工具的开源社区还维护着Nmap和Samba。</p><p>#73 QualysGuard：基于网页的漏洞扫描器</p><p>在 网站上以服务形式发布， 所以QualysGuard没有开发、维护和升级漏洞管理软件或ad-hoc安全应用程序的负担。客户端可以安全的通过一个简单易用的网页访问 QualysGuard。QualysGuard含有5000种以上的单一漏洞检查，一个基于推理的扫描引擎，而且漏洞知识库自动天天升级。</p><p>#74 ClamAV：一款UNIX平台上的基于GPL（通用公开许可证：General Public License）的反病毒工具集</p><p>ClamAV 是一款强大的注重邮件服务器附件扫描的反病毒扫描器。它含有一个小巧的可升级的多线程daemon、一个命令行扫描器和自动升级 工具。Clam AntiVirus基于AntiVirus package发布的开源病毒库，您也可以将此病毒库应用于您自己的软件中，但是别忘了经常升级。</p><p>#75 cheops / cheops-ng：提供许多简单的网络工具，例如本地或远程网络映射和识别计算机操作系统</p><p>Cheops 提供许多好用的图形化用户界面网络工具。它含有主机/网络发现功能，也就是主机操作系统检测。Cheops-ng用来探查主机上 运行的服务。针对某些服务，cheops-ng可以探查到运行服务的应用程序是什么，以及程序的版本号。Cheops已经停止开发和维护，所以请最好使用 cheops-ng。</p><p>#76 Burpsuite：一款网页程序攻击集成平台</p><p>Burp suite允许攻击者结合手工和自动技术去枚举、分析、攻击网页程序。这些不同的burp工具通过协同工作，有效的分享信息，支持以某种工具中的信息为基础供另一种工具使用从而发动攻击。</p><p>#77 Brutus：一款网络验证暴力破解器</p><p>这款Windows平台上的暴力破解器通过字典猜测远程系统网络服务密码。它支持HTTP、POP3、FTP、SMB、TELNET、IMAP、NTP等等。不开放源码，UNIX平台上的类似软件有THC Hydra。</p><p>#78 Unicornscan：另类端口扫描器</p><p>Unicornscan 是一款通过尝试连接用户系统（User-land）分布式TCP/IP堆栈获得信息和关联关系的端口扫描器。它试图为 研究人员提供一种可以刺激TCP/IP设备和网络并度量反馈的超级接口。它主要功能包括带有所有TCP变种标记的异步无状态TCP扫描、异步无状态TCP 标志捕获、通过分析反馈信息获取主动/被动远程操作系统、应用程序、组件信息。它和Scanrand一样都是另类扫描器。</p><p>#79 Stunnel：用途广泛的SSL加密封装器</p><p>stunnel 用来对远程客户端和本地机（可启动inetd的：inetd-startable）或远程服务器间的SSL加密进行封装。它可 以在不修改任何代码的情况下，为一般的使用inetd daemon的POP2、POP3和IMAP服务器添加SSL功能。它通过使用OpenSSL或SSLeay库建立SSL连接。</p><p>#80 Honeyd：您私人的蜜罐系统</p><p>Honeyd 是一个可以在网络上创建虚拟主机的小型daemon。可以对此虚拟主机的服务和TCP进行配置，使其在网络中看起来是在运行某种 操作系统。Honeyd可以使一台主机在局域网中模拟出多个地址以满足网络实验环境的要求。虚拟主机可以被ping通，也可以对它们进行路由跟踪。通过对 配置文件进行设置可以使虚拟计算机模拟运行任何服务。也可以使用服务代理替代服务模拟。它的库有很多，所以编译和安装Honeyd比较难。</p><p>#81 Fping：一个多主机同时ping扫描程序</p><p>fping 是一款类似ping（1）（ping（1）是通过ICMP（网络控制信息协议Internet Control Message Protocol）协议回复请求以检测主机是否存在）的程序。Fping与ping不同的地方在于，您可以在命令行中指定要ping的主机数量范围，也可 以指定含有要ping的主机列表文件。与ping要等待某一主机连接超时或发回反馈信息不同，fping给一个主机发送完数据包后，马上给下一个主机发送 数据包，实现多主机同时ping。如果某一主机ping通，则此主机将被打上标记，并从等待列表中移除，如果没ping通，说明主机无法到达，主机仍然留 在等待列表中，等待后续操作。</p><p>#82 BASE：基础分析和安全引擎（Basic Analysis and Security Engine）</p><p>BASE 是一款基于PHP的可以搜索和实施安全事件的分析引擎，她的安全事件数据库来源于很多入侵检测系统、防火墙、网络检测工具生成的安全 事件。它的功能包括一个查找生成器和搜索界面，用来搜索漏洞；一个数据包浏览器（解码器）；还可以根据时间、传感器、信号、协议和IP地址等生成状态图。</p><p>#83 Argus：IP网络事务评审工具</p><p>Argus 是一款固定模型的实时的流量监视器，用来跟踪和报告数据网络通讯流中所有事务的状态和性能。Argus为流量评估定制了一种数据格式， 其中 包括连通性、容量、请求、丢包、延迟和波动，这些就作为评估事务的元素。这种数据格式灵活易扩展，支持常用流量标识和度量，还可以获得指定的应用程序/协 议的信息。</p><p>#84 Wikto：网页服务器评估工具</p><p>Wikto是一款检查网页服务器漏洞的工具。它和Nikto类似，但是添加了很多其它功能，例如一个整合了Google的后台发掘器。Wikto工作于MS ..NET环境下，下载此软件和源代码需要注册。</p><p>#85 Sguil：网络安全监控器命令行分析器</p><p>Sguil（按sgweel发音）是由network security analysts出品的网络安全分析工具。Sguil的主要组件就是一个Snort/barnyard实时事件显示界面。它还包含一些网络安全监控的辅助工具和事件驱动的入侵检测系统分析报告。</p><p>#86 Scanrand：一个异常快速的无状态网络服务和拓朴结构发现系统</p><p>Scanrand是一款类似Unicornscan的无状态主机发现和端口扫描工具。它以降低可靠性来换取异常快的速度，还使用了加密技术防止黑客修改扫描结果。此工具是Dan Kaminsky出品的Paketto Keiretsu的一部分。</p><p>#87 IP Filter：小巧的UNIX数据包过滤器</p><p>IP Filter是一款软件包，可以实现网络地址转换（network address translation）（NAT）或者防火墙服务的功能。它可以作为UNIX的一个核心模块，也可以不嵌入核心，强烈推荐将其作为UNIX的核心模块。 安装和为系统文件打补丁要使用脚本。IP Filter内置于FreeBSD、NetBSD和Solaris中。OpenBSD可以使用Openbsd PF，Linux用户可以使用Netfilter。</p><p>#88 Canvas：一款全面的漏洞检测框架</p><p>Canvas是 Aitel’s ImmunitySec出品的一款漏洞检测工具。它包含150个以上的漏洞，它比Core Impact便宜一些，但是它也价值数千美元。您也可以通过购买VisualSploit Plugin实现在图形界面上通过拖拽就可以生成漏洞。Canvas偶尔也会发现一些ODay漏洞。</p><p>#89 VMware：多平台虚拟软件</p><p>VMware 虚拟软件允许您在一个系统中虚拟运行另一个系统。这对于安全专家在多平台下测试代码和漏洞非常有用。它只运行在Windows和 Linux平台上，但它可以虚拟运行几乎所有的x86操作系统。它对建立沙箱（sandboxes）也非常有用。在VMware虚拟系统上感染了恶意软件 不会影响到宿主机器，可以通过加载快照文件恢复被感染了的虚拟系统。VMware不能创建虚拟系统的镜像文件。VMware最近刚刚宣布免费。另一款在 Linux下颇受瞩目的虚拟平台软件是Xen。</p><p>#90 Tcptraceroute：一款基于TCP数据包的路由跟踪工具</p><p>现 代网络广泛使用防火墙，导致传统路由跟踪工具发出的（ICMP应答（ICMP echo）或UDP）数据包都被过滤掉了，所以无法进行完整的路由跟踪。尽管如此，许多情况下，防火墙会准许反向（inbound）TCP数据包通过防火 墙到达指定端口，这些端口是主机内防火墙背后的一些程序和外界连接用的。通过发送TCP SYN数据包来代替UDP或者ICMP应答数据包，tcptraceroute可以穿透大多数防火墙。</p><p>#91 SAINT：安全管理综合网络工具</p><p>SAINT象Nessus、ISS Internet Scanner和Retina一样，也是一款商业漏洞评估工具。它以前是运行在UNIX系统之上的免费开源工具，但现在收费了。</p><p>#92 OpenVPN：全功能SSL VPN解决方案</p><p>OpenVPN 是一款开源的SSL VPN工具包，它可以实现很多功能，包括远程登录、站对站VPN、WiFi安全、带有负载平衡的企业级远程登录解决方案、节点控制移交 （failover）、严密的访问控制。OpenVPN运行于OSI 2层或3层安全网络，使用SSL/TLS工业标准协议，支持灵活的基于证书、智能卡、二元验证的客户端验证方法，允许在VPN虚拟接口上使用防火墙规则作 为用户或指定用户组的访问控制策略。OpenVPN使用OpenSSL作为其首选加密库</p><p>#93 OllyDbg：汇编级Windows调试器</p><p>OllyDbg 是一款微软Windows平台上的32位汇编级的分析调试器。因其直接对二进制代码进行分析，所以在无法获得源代码的时候它非常有用。 OllyDbg含有一个图形用户界面，它的高级代码分析器可以识别过程、循环、API调用、交换、表、常量和字符串，它可以加载运行时程序，支持多线程。 OllyDbg可以免费下载，但不开源。</p><p>#94 Helix：一款注重安全防护的Linux版本</p><p>Helix是一款自定义 版本的Knoppix自启动Linux光盘系统。Helix远不止是一张自启动光盘。除了光盘启动到自定义的 Linux环境，还具有超强的硬件支持能力，包含许多应付各种问题的软件。Helix尽量少的接触主机软硬资源。Helix不自动加载交换（swap）空 间，不自动加载其它任何外围设备。Helix还可以自动加载Windows，以应对意外情况。</p><p>#95 Bastille：Linux、Mac OS X和HP-UX的安全加强脚本</p><p>Bastille 使操作系统固若金汤，减少系统遭受危险的可能，增加系统的安全性。Bastille还可以评估系统当前的安全性，周期性的报 告每一项安全设置及其工作情况。Bastille当前支持Red Hat（Fedora Core、Enterprise和Numbered/Classic版本）、SUSE、Debian、Gentoo和Mandrake这些Linux版 本，还有HP-UX和Mac OS X。Bastille旨在使系统用户和管理员了解如何加固系统。在其默认的最坚固模式下，它不断的询问用户问题，并对这些问题加以解释，根据用户对问题不 同的回答选择不同的应对策略。在其评估模式下，它会生成一份报告旨在告诉用户有哪些安全设置可用，同时也提示用户哪些设置被加固了。</p><p>#96 Acunetix Web Vulnerability Scanner：商业漏洞扫描器</p><p>Acunetix WVS自动检查您的网页程序漏洞，例如SQL注入、跨网站脚本和验证页面弱密码破解。Acunetix WVS有着非常友好的用户界面，还可以生成个性化的网站安全评估报告。</p><p>#97 TrueCrypt：开源的Windows和Linux磁盘加密软件</p><p>TrueCrypt是一款非常出色的开源磁盘加密系统。用户可以加密整个文件系统，它可以实时加密/解密而不需要用户干涉，只要事先输入密 码。非常巧妙的hidden volume特性允许您对特别敏感的内容进行第二层加</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[An open letter to hobbyists]]></title>
      <url>http://fengchao.github.io/2016/04/06/An-open-letter-to-hobbyists/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>February 3, 1976</p><p>By William Henry Gates III</p><p>To me, the most critical thing in the hobby market right now is the lack of good software courses, books and software itself. Without good software and an owner who understands programming, a hobby computer is wasted. Will quality software be written for the hobby market?</p><p>Almost a year ago, Paul Allen and myself, expecting the hobby market to expand, hired Monte Davidoff and developed Altair BASIC. Though the initial work took only two months, the three of us have spent most of the last year documenting, improving and adding features to BASIC. Now we have 4K, 8K, EXTENDED, ROM and DISK BASIC. The value of the computer time we have used exceeds $40,000.</p><p>The feedback we have gotten from the hundreds of people who say they are using BASIC has all been positive. Two surprising things are apparent, however, 1) Most of these “users” never bought BASIC (less than 10% of all Altair owners have bought BASIC), and 2) The amount of royalties we have received from sales to hobbyists makes the time spent on Altair BASIC worth less than $2 an hour.</p><p>Why is this? As the majority of hobbyists must be aware, most of you steal your software. Hardware must be paid for, but software is something to share. Who cares if the people who worked on it get paid?</p><p>Is this fair? One thing you don’t do by stealing software is get back at MITS for some problem you may have had. MITS doesn’t make money selling software. The royalty paid to us, the manual, the tape and the overhead make it a break-even operation. One thing you do do is prevent good software from being written. Who can afford to do professional work for nothing? What hobbyist can put 3-man years into programming, finding all bugs, documenting his product and distribute for free? The fact is, no one besides us has invested a lot of money in hobby software. We have written 6800 BASIC, and are writing 8080 APL and 6800 APL, but there is very little incentive to make this software available to hobbyists. Most directly, the thing you do is theft.</p><p>What about the guys who re-sell Altair BASIC, aren’t they making money on hobby software? Yes, but those who have been reported to us may lose in the end. They are the ones who give hobbyists a bad name, and should be kicked out of any club meeting they show up at.</p><p>I would appreciate letters from any one who wants to pay up, or has a suggestion or comment. Just write to me at 1180 Alvarado SE, #114, Albuquerque, New Mexico, 87108. Nothing would please me more than being able to hire ten programmers and deluge the hobby market with good software.</p><p>Bill Gates</p><p>General Partner, Micro-Soft</p><hr><p>When you look long into abyss , the abyss also looks into you.</p><p>– Friedrich Nietzsche</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mpeg to Theora]]></title>
      <url>http://fengchao.github.io/2016/04/05/Mpeg-to-Theora/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>原来养狗的时候，用相机拍了不少小视频，时间很短但是占的空间很大。所以找了个方法将它们压缩到开源的 Theora 格式。</p><ol><li><p>安装 ffmpeg2theora</p><p># emerge ffmpeg2theora</p></li><li><p>使用它将一个目录下的全部 MPEG 文件转化到 Theora</p><p># find . -name “*.MPG” -exec ffmpeg2theora ‘{}’ \;</p></li></ol><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[可变参数宏定义 VA_ARGS]]></title>
      <url>http://fengchao.github.io/2016/04/05/VA-ARGS/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>宏定义支持参数个数未知的情况，在打印调试信息时很管用。</p><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><pre><code>#ifdef DEBUG
#define print_dbg(...) printf(__VA_ARGS__)
#else
#define print_dbg(...) 
#endif
</code></pre><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><pre><code>print_dbg（“Total is %d”,total）;
</code></pre><p>如果在编译的时候定义了 DEBUG (添加 -dDEBUG 编译选项)，就会打印调试信息。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[删除代码]]></title>
      <url>http://fengchao.github.io/2016/04/05/Delete-code/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>删除代码的方法其实很简单：选中代码，并按下 Delete 键。但是程序员似乎不太愿意这么简单直接。看了不少代码，发现残留了许多垃圾。在古老的时代，为了在改错了的情况下恢复回去，可以这么做，而在有了版本控制系统的情况下，这样注释掉代码将会引发混乱。</p><h2 id="注释掉几行代码或者用-if-0-将一段代码删除"><a href="#注释掉几行代码或者用-if-0-将一段代码删除" class="headerlink" title="注释掉几行代码或者用 #if 0 将一段代码删除"></a>注释掉几行代码或者用 #if 0 将一段代码删除</h2><pre><code>// old_function();
new_function();
</code></pre><p>通常，我看到这样的代码，就不得不去思考为什么用新方法，老函数为什么不行。大部分情况下，根本获得不了什么有用的信息。就像欣赏一幅画，不需知道作品经历了哪些涂改一样。程序员应该展现出完美的代码，而要在代码上留下无用的补丁。希望了解代码演进史的时候，尽管去挖掘版本控制系统就行了。</p><h2 id="未被调用的函数"><a href="#未被调用的函数" class="headerlink" title="未被调用的函数"></a>未被调用的函数</h2><p>在没有调用上下文的情况下，猜测函数的作用将更加困难。对不会被调用的函数，要分两种情况：如果一个函数已经被另外一个函数取代，就应该将旧函数删除；而如果一个函数是接口的一部分，则予以保留。</p><h2 id="标记不确定的删除"><a href="#标记不确定的删除" class="headerlink" title="标记不确定的删除"></a>标记不确定的删除</h2><p>有些时候，会不确定一段代码到底该不该删掉。只有在新的代码经过测试验证之后，才能确定。这个时候可以用特殊的注释将他们删除，比如使用 //- 标记每一行。</p><pre><code>//- OldWayImUnsureOf(zooey);

 #if 0 //- I don&apos;t think I need this with the new FooBar
    OldWayStepOne(fooey);
    ...
    OldWayStepTwenty(hooey);
#endif 
</code></pre><h2 id="安心删除代码"><a href="#安心删除代码" class="headerlink" title="安心删除代码"></a>安心删除代码</h2><p>有时候删除大段代码看上去确实是很激进，但是不用担心，因为代码的删除，总是有原因的。毕竟，需要返回原来代码的机会是少之又少。比较一下需要恢复原来代码的可能性和永远面对丑陋注释的确定性。安心的删除吧，您不会再想念它。</p><p>原文：<a href="http://nedbatchelder.com/text/deleting-code.html" target="_blank" rel="external">http://nedbatchelder.com/text/deleting-code.html</a></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的 linux 路程]]></title>
      <url>http://fengchao.github.io/2016/04/05/My-linux-history/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>年关将至，稍微总结下下 Linux 发行版的使用历史。关于发行版的优劣不希望引发什么争论，我只是讲讲个人使用的感受和切换的理由。</p><h2 id="Red-Hat-（2005）"><a href="#Red-Hat-（2005）" class="headerlink" title="Red Hat （2005）"></a>Red Hat （2005）</h2><p>最早接触 Linux 是从经典的 Red Hat 9 开始的。从某种意义上说，Red Hat 9 就是一个传奇。在相当长的时间里，红帽就是 Linux 的代名词。而 Red Hat 9 则是曾经的巅峰之作。后来，Red Hat 不复存在，转而产生 Fedora 与 Red Hat 企业版。这个决定在当时确实得到很大的抵制，不过现在看来，红帽做了一个正确的决定。个人桌面应用更倾向于易用与新软件的使用；而企业版最重视稳定性。当这两者的矛盾在同一个发行版中得不到调和的时候，分支就是最好的选择。说来还有些搞笑，我的红帽光盘是从拖鞋门口的盗版小贩手里买的。</p><h2 id="Fedora-（2006）"><a href="#Fedora-（2006）" class="headerlink" title="Fedora （2006）"></a>Fedora （2006）</h2><p>装完红帽没用几天，发现一个红的通知图标老闪提示无法升级。网上搜了搜，才知道应该转用 Fedora Core。于是就下了 FC5 装了过去。这个典型的经历从一个侧面表明，Fedora 开始的时候，一直生活在 Red Hat 的阴影之下。知道若干年之后，还有人在水源上问哪里可以下 Red Hat，而解答者就需要不厌其烦的讲解 Fedora 与 Red Hat 的关系。这其实也是我翻译十大发行版介绍的原因。当时的 Fedora 已经通过 yum 解决了 RPM 的依赖问题，但是用起来总是觉得不方便，更新和升级都比较慢（我已经换 ftp.sjtu 了，奈何服务器老挂科）。</p><h2 id="Ubuntu-（2006-2008）"><a href="#Ubuntu-（2006-2008）" class="headerlink" title="Ubuntu （2006 - 2008）"></a>Ubuntu （2006 - 2008）</h2><p>这个时候，有人推荐了 Ubuntu，于是装了 Ubuntu 6.06. 最初的时候发现 apt 非常好用，然后发现论坛上的文档很好，非常适合新手使用。从此一发不可收拾，从 6.06 一直用到 8.10 而且每次都是从 Alpha 1 就开始使用测试版。中间自然经常遇到大大小小的问题，从最早的 MAC 地址绑定；到显示驱动 GLX、Compiz，超炫的立方体等等。个人的能力也随着问题的解决而逐步得到提升。期间，彻底删掉了系统中的WinXP，并开始了Launchpad 上的翻译工作。当时倾向于只在 Launchpad 上工作而不把成果提交到上游，因为感觉 Linux 中的发行版有点过多，分散了开发的经历，而希望 Ubuntu 能吸引更多的眼球，率先达到能够与微软相抗衡的程度。现在，的 Ubuntu ，有点像当年的 Red Hat，许多新手把它和 Linux 画上了等号。但是现在，我的看法有了很大的改变，Ubuntu 吸引了很多的新用户，但是在开发方面确实贡献有点少。也许未来的方向，应该是将一部分熟练的 Ubuntu 用户介绍给其他发行版。</p><h2 id="Linux-From-Scratch-（2008）"><a href="#Linux-From-Scratch-（2008）" class="headerlink" title="Linux From Scratch （2008）"></a>Linux From Scratch （2008）</h2><p>也许 LFS 不应该被成为一个发行版，因为基本上它只是一个供人学习的工具，通过从 0 开始一步一步安装系统需要的程序。我对这个系统的使用，仅限于从头到尾安装了两次，而装完之后就立即删掉了。但是通过 Linux From Scratch,我对操作系统的认识产生了质的飞跃。在之前，光操作系统这个词都能把我镇住。而从头装卸了一次之后，突然间豁然开朗，操作系统整个的解体了，“提刀而立，为之四顾，为之踌躇满志，善刀而藏之”。所以向每个希望了解操作系统的人推荐这个系统。安装下来，可能需要花费两三天的时间，但是学到的东西，比用 Ubuntu 两三年都要多。</p><h2 id="Gentoo-（2009-2010）"><a href="#Gentoo-（2009-2010）" class="headerlink" title="Gentoo （2009-2010）"></a>Gentoo （2009-2010）</h2><p>Gentoo 和 Linux From Scratch 简直是绝配。从某种意义上说，Gentoo 安装的 Stage3，就是 Linux From Scratch 前面准备的编译环境。Linux From Scratch 提供了最基本的系统，而 Gentoo 则是用一种优雅的方式管理软件包的下载、自动补丁和依赖关系解决。和 Ubuntu 不同，Gentoo 提供了最大的灵活性，用户可以按照自己的喜好进行选择而不是简单的提供默认选项。用 Gentoo 一年多了，系统基本没有出过什么问题，滚动升级，不但可以使用最新的软件，而且降低了一次升级许多软件包而产生的危险。即时出了问题，也更容易缩小范围，发现问题的所在。但是 Gentoo 也不是没有问题，编译安装需要不少时间，在以前我在台式机中用 xfce 最小安装，还算可以接受。现在换了笔记本，一直那么高负荷编译，发热大，硬盘也会吃不消。所以有了换 Arch 的打算。</p><h2 id="Arch-2010-？"><a href="#Arch-2010-？" class="headerlink" title="Arch 2010 ？"></a>Arch 2010 ？</h2><p>本来老早就试着安装过，不过太不幸了，我的 ATI 显卡恰巧遇到内存分配问题。当时只知道一起图形界面就死机，开始以为 Arch 的问题，后来 Gentoo 安装的时候也碰到这个问题，花了不少时间在内核里面禁掉了 agpgart 的驱动，暂时是解决了问题。不知道现在 Arch 如何，貌似呼声很高，而滚动升级的特点也很和我胃口。所以过年之后就准备开始行动了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Red Hat -&gt; Fedora-&gt; Ubuntu -&gt; Gentoo –&gt; Arch –&gt; ?<br>这是一条由简单，到深入，再到简单的曲线。随着对系统了解的逐步深入，人也快到了“不折腾”的年龄。 Arch 会成为终极发行版么？ Debian Sid 到底好不好用？新的一年，等待新的答案。</p><p>后记: 已经用到 2016 年了，暂时也没有看到变动的可能性。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gentoo 转到 Arch]]></title>
      <url>http://fengchao.github.io/2016/04/05/Gentoo-to-Arch/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>老的台式机换成了笔记本，同时桌面从 XFCE 转成 KDE，结果发现编译量太大了。KDE 基本每月出一个小版本，每次都要编译好久。在 KDE 4.4.2 出来之后终于觉得换成 Arch 了。作为 Arch 的初级用户，大致比较一下两个发行版。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>除了编译的时间，两者的安装比较神似。都提供了大量的可选组件供选择，而不是像 Ubuntu 一样事先定好。相对来说，Arch 需要手动修改的配置文件更少。除了一些软件包的名字变了，需要 Pacman 仔细搜索之外，Gentoo 的经验都可以直接使用。</p><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><p>Pacman 速度很快，默认的源文件里面也有 163 lupaworld 等常用源。目前为止没有碰到依赖问题。不少软件官方源里是没有的，于是有了 AUR – 一个 port 系统。如果以前知道 Arch 有这个，也许早换了。 yaourt 非常好用，还提供了即时修改 PKGBUILD 的功能。 预编译包 + port，在速度和订制软件包直接达到了更好的平衡。</p><p>总的来说，非常喜欢 Arch，刚装没几天，已经很少用 Gentoo. 所谓存在就是合理，这么多人推荐它，一定有其优点，需要主动尝试，慢慢体会。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>切换到 Arch 已经好多年了，一直都在用。自己还成了 Arch Wiki 的 Admin。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[看牛人们是怎么评价编程语言的]]></title>
      <url>http://fengchao.github.io/2016/04/05/Different-programe-languages/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>2012 年最早转载这个文章的时候，没有看到 Javascript，世界变化正式大啊。</p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>一个有过 BASIC 编程经历的人是很难学会好的编程习惯的。作为一个潜在的程序员，他们已经被脑残并且无法修复。</p><p>– Edsger Wybe Dijkstra，Dijkstra 算法发明者</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>C 语言程序就像一群拿着刀的人在刚刚打过蜡的地板上快速的跳舞。</p><p>– Waldi Ravens</p><p>罗马帝国衰败的主要原因之一是因为他们缺少0，他们没有办法知道他们的 C 程序已经成功的执行完了。</p><p>– Robert Firth</p><p>现在是早上五点，你知道那个指针现在什么地方吗？</p><p>– 匿名</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><p>C 很容易让你朝自己的脚开枪。在 C++ 中，这么做变的困难了，但是你要不注意就会崩掉自己的整条腿。</p><p>– Bjarne Stroustrup，C++ 发明者</p><p>我发明了“面向对象”，但是我可以明确的是，我不知道什么是 C++。</p><p>– Alan Kay，Smalltalk 发明者</p><p>C++ 的最新功能是用来修正之前的最新功能的。</p><p>– David Jameson</p><p>50年的编程语言研究就搞出来一个 C++ ？</p><p>– Richard A. O’Keefe</p><p>只要你花一点时间研究 C++，你就会发现 C++ 的用户都在寻找一门更好的语言。</p><p>– R. William Beckwith.</p><p>Java 就是去掉了枪炮，刀剑，还有黑帮的 C++。</p><p>– James Gosling，Java 联合发明人</p><p>C++ 是一门恐怖的语言。即使选择 C 没有任何优势，只是为了逃避 C++，那这个理由也足够了。</p><p>– Linus Torvalds，Linux 发明者</p><h2 id="COBOL"><a href="#COBOL" class="headerlink" title="COBOL"></a>COBOL</h2><p>使用 COBOL 会让你变的脑残，所以教别人使用 COBOL 就是犯罪。</p><p>– E.W. Dijkstra，Dijkstra 算法发明者</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>如果 Java 真的有垃圾收集的话，大部分程序在刚开始执行的时候就会把他们自己删了。</p><p>– Robert Sewell</p><h2 id="Lisp"><a href="#Lisp" class="headerlink" title="Lisp"></a>Lisp</h2><p>Lisp 不是一门语言，它只是一种构建材料。</p><p>– Alan Kay，Smalltalk 发明者</p><h2 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h2><p>Perl 是唯一一门在 RSA 加密前后看起来一样的语言。</p><p>– Keith Bostic</p><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>PHP 是由不称职的业余选手发明和操纵的，而 Perl 是伟大而阴险的，由一帮高水平的变态专业人士操纵。</p><p>– Jon Ribbens</p><h2 id="Bash-以及其他-shell"><a href="#Bash-以及其他-shell" class="headerlink" title="Bash 以及其他 shell"></a>Bash 以及其他 shell</h2><p>很明显，移植 shell 要比移植 shell 脚本更容易。</p><p>– Larry Wall，Perl 发明者</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>世界上只有两种编程语言：整天被人喷的语言，没有人用的语言。</p><p>– Bjarne Stroustrup</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[告别百度空间]]></title>
      <url>http://fengchao.github.io/2016/04/05/Goodbye-Baidu/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>从2006年开始写博客，最开始在MSN空间，后来MSN访问一直不正常，就迁移到了百度空间。看着访问量不断提高，最高到时候日访问量超过 200, 很是高兴。后来百度空间越来越不像博客，很多功能都找不到了。最终决定建自己的博客。</p><h2 id="文章回顾"><a href="#文章回顾" class="headerlink" title="文章回顾"></a>文章回顾</h2><p>手动迁移了历史文章，迁移的工作其实也是在回顾自己的历程。看着过去收集的技术资料，感触良深。</p><p>有些东西已经退出了历史舞台，比如我参与的第一个开源项目 Songbird.</p><p>有些东西，真希望当时能够研究的透彻一些，比如 dbus。如果当时理解得再深刻一些，在做网络电视的时候能够用 dbus 通讯，可能就能摆脱层出不穷的死锁问题。</p><p>有些东西，一直还在坚持使用，比如 Arch Linux。从 2010 年一直用到现在，而且没有换新发行版的任何想法。</p><h2 id="博客未死"><a href="#博客未死" class="headerlink" title="博客未死"></a>博客未死</h2><p>最近已经很少更新博客了，工作很忙，空闲时间又大部分花在 Arch Wiki 上。Arch Wiki 的历程，从翻译开始，后来成为维护者，最终成为管理员。对 Wiki 这个知识形式的理解，也逐渐的变得深刻。博客、微博、维基、论坛、IRC、问答，即时通讯，每一个东西都有其擅长的东西，没有一个单独的形式可以通吃一切。</p><p>微博：适合时时播报，时效性非常强。</p><p>博客：不那么随意，适合总结性的文章，鞭策自己思考。</p><p>Wiki：适合客观性的知识总结，汇集所有人的智慧。</p><p>问答：针对性强，方便于解决问题，但很难聚集人气</p><p>开通了自己的博客，后面有时间把 Wiki 和 Owncloud 都做好。在虚拟的世界，慢慢的产生了一个和现实有区别的身份。考虑到每天在电脑前的时间几乎超过 10 小时，也许虚拟的身份反而更真实吧。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开源软件维护者的责任]]></title>
      <url>http://fengchao.github.io/2015/11/07/Open-source-maintainer/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>开始清理公司的资料了，发现几封很老的邮件。事情的起因是： 2.6.32-rc6 的时候，一个用户发现了内核无线网络驱动中的 Bug，他通过二分搜索找到导致问题的修改并发邮件请 Linus 取消修改。这时候无线子系统的维护者有点不乐意，他发文希望以后这种邮件直接发给维护者。 Linus 的回答以 “You’re full of sh*t” 开始，言辞犀利，直中要害。面对世界上最优秀的程序员，Linus 能够主持 Linux 开发这么多年，不是盖得。</p><p>On Wed, 4 Nov 2009, Marcel Holtmann wrote:</p><blockquote><p>I have to agree here. It happens why too often lately. And this needs to<br>stop. Otherwise why bother with subsystem maintainers? Just send<br>everything to Linus directly and have him to review every line of code.<br>You’re full of sh*t.</p></blockquote><p>Bugs are bugs. They should be reverted, and the people who introduced them<br>should be SHAMED if the thing was introduced after the merge window.</p><p>I don’t need to review any line of code at all - a revert is a revert.<br>There’s not a lot of review that needs, just a very obvious “that bug<br>causes more problems than it fixed”.</p><p>And yes, I’m upset, because in this case I saw one of the <em>earlier</em> bisect<br>results too, and I did actually spend time debugging it and sending<br>Johannes the information, because he basically ignored the bisect result.</p><p>That makes me upset. The fact that somebody has bisected the problem means<br>that you should damn well thank them, not complain. And look at the -rc<br>number, look at the commit - and you should realize that “please revert”<br>is OBVIOUSLY the right thing to say to something that introduces problems<br>after -rc5.</p><p>The fact is, maintainer ship does <em>not</em> mean ownership. It means that you<br>should be <em>responsible</em> for the code, and you get credit for it, but if<br>problems happen you do NOT “own” it. Not at all.</p><p>If you don’t understand that, you shouldn’t be a maintainer.</p><p>And if it’s not obvious - I’m really upset that people are complaining<br>about “please revert” for this case. YOU were wrong.</p><p>Linus==================================================</p><p>On Tue, 3 Nov 2009, Johannes Berg wrote:</p><blockquote><p>I’ll rant a bit too – I’ve been very annoyed by this many times. Note<br>this isn’t really against you (Dmitry) in particular, just another<br>case … but it does tick me off that many times when somebody manages<br>to blame a failure on a specific commit the first thing they do is ask<br>somebody way “above” (in terms of patch flow into mainline) the person<br>writing the patch (like Linus here) to revert it.<br>Johannes, you’re simply WRONG.</p></blockquote><p>At this point (ie <em>way</em> after -rc1), “just revert it” really is the right<br>thing to do. The commit was shit. It caused more problems than it fixed. I<br>should have reverted it immediately when that was clear. I didn’t, and<br>because I didn’t, other people then had to waste time bisecting it.</p><p>So instead of complaining about other people, I would suggest you look<br>yourself in the mirror. Stop thinking you “own” code. If you wrote a buggy<br>commit, and somebody else went through the work to bisect it, you should<br>(a) expect it to be reverted<br>(b) thank the person for finding the bug YOU introduced.<br>(c) be ashamed of YOURSELF<br>instead of whining about it as if we should thank you!</p><p>Linus</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[中科红旗倒了]]></title>
      <url>http://fengchao.github.io/2015/11/07/Redflag-linux/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>中科红旗倒闭了，有人拍手称快，有人扼腕叹息。我倒是觉得，这种开源世界的封闭怪胎，这种靠国家拨款才能生存的机构，存在与否，又有什么关系呢。</p><h2 id="中科红旗-开源的幌子"><a href="#中科红旗-开源的幌子" class="headerlink" title="中科红旗 - 开源的幌子"></a>中科红旗 - 开源的幌子</h2><p>中科红旗倒下，能说明 Linux 在中国混不开了吗？显然不是，因为中科红旗，完全是按封闭的手法运营一个开放的科技。这么多年下来，红旗 Linux 没有为开源界做出过什么贡献。照抄国外的发行版，自己做做汉化翻译。而且这些翻译也没有提交到上游，完全是自私自立的玩法。这样的公司，能有什么竞争力？</p><h2 id="技术前沿"><a href="#技术前沿" class="headerlink" title="技术前沿"></a>技术前沿</h2><p>开源世界不缺少优秀的公司，Red Hat 每年的净利润都大幅增长。而这些优秀公司都有一个共同的特点：他们都是主营技术的重要贡献者，参与者。只有这样的公司，才能一直走在技术的最前沿。那些把修改留在自己手里的公司很快发现，保持私有代码的同步更新就已经耗费了大量的精力。之前在 VIA 工作的时候，我对这一点也是深有体会。因为 Linux Driver 没有提交到上游，每次内核有变动，都需要重新适配，针对每一个发行版打包。历史的包袱会越来越重，到最后不堪重负，败下阵来。</p><h2 id="代码不再是核心竞争力"><a href="#代码不再是核心竞争力" class="headerlink" title="代码不再是核心竞争力"></a>代码不再是核心竞争力</h2><p>曾几何时，源代码是很多公司的核心机密。擅自将代码拷贝出去会被立即开除，甚至关入监狱。那是一个代码稀缺的时代。随着一代代编程语言的兴起和衰落，很多公司逐步发现，其实代码不重要，而代码中的逻辑和知识才是核心竞争力。增强这种竞争力的手段，不是把代码放入保险箱，而是公开代码，让更多的人了解它，改进它。</p><h2 id="靠申请经费活着的公司，其实已经死了"><a href="#靠申请经费活着的公司，其实已经死了" class="headerlink" title="靠申请经费活着的公司，其实已经死了"></a>靠申请经费活着的公司，其实已经死了</h2><p>真的有实力，有竞争力，投资者还是能找到的。中国大部分的科研院所都在捣浆糊，做学问不行，骗经费在行。中科红旗，其实算比较好的，至少有东西可以用。不像有些人编纂了几组数据就到处骗人。</p><p>红旗 Linux，就像红旗汽车一样，是闭关锁国的产物。中国人要用一个旗帜，证明自己行，证明自己可以做汽车，可以做 Linux 发行版。从这个意义上说，中科红旗已经完成了其历史使命。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nodejs nvm]]></title>
      <url>http://fengchao.github.io/2015/11/07/nodejs-nvm/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>NVM（<a href="https://github.com/creationix/nvm" target="_blank" rel="external">Node version manager</a>)顾名思义，就是 Node.js 的版本管理软件，可以轻松的在 Node.js 各个版本间切换.</p><h2 id="下载并安装NVM脚本"><a href="#下载并安装NVM脚本" class="headerlink" title="下载并安装NVM脚本"></a>下载并安装NVM脚本</h2><pre><code>$ curl https://raw.githubusercontent.com/creationix/nvm/v0.13.1/install.sh | bash
$ source ~/.bash_profile
</code></pre><h2 id="列出所需要的版本"><a href="#列出所需要的版本" class="headerlink" title="列出所需要的版本"></a>列出所需要的版本</h2><pre><code>nvm list-remote
</code></pre><h2 id="安装相应的版本"><a href="#安装相应的版本" class="headerlink" title="安装相应的版本"></a>安装相应的版本</h2><pre><code>nvm install v0.10.40
</code></pre><h2 id="查看已安装的版本"><a href="#查看已安装的版本" class="headerlink" title="查看已安装的版本"></a>查看已安装的版本</h2><pre><code>nvm list
</code></pre><h2 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h2><pre><code>nvm use v0.10.30
</code></pre><h2 id="设置默认版本"><a href="#设置默认版本" class="headerlink" title="设置默认版本"></a>设置默认版本</h2><pre><code>nvm alias default v0.10.30
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[推广自己]]></title>
      <url>http://fengchao.github.io/2015/10/12/self-promote/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><a href="https://www.nczonline.net/blog/2013/10/15/the-best-career-advice-ive-received/" target="_blank" rel="external">这篇文章</a>里面作者也提到对其职业生涯最有帮助的话：</p><blockquote><p>You do great work. I mean really great work. I like how your code looks and that it rarely breaks. The problem is that others don’t see it. In order for you to get credit for the work you’re doing, you have to let people know. You need to do a bit of self-promotion to get noticed.</p></blockquote><p>技术的极致是什么？就是把自己隐藏起来，让人感受不到技术的存在。所以技术出身的人，大都有个通病：只会埋头苦干，不会推广自己，甚至不屑于推广自己。</p><p><strong>学会推广自己，才能让别人看到自己的价值，才能提高影响力</strong>。这个道理，我花了很多年的经历才有深刻的体会。希望新入职场的人能看到这篇文章，早日明白这一点。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[回味IE、firefox(Netscape)十余年6轮技术攻防战]]></title>
      <url>http://fengchao.github.io/2015/10/12/IE-vs-Firefox/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><img src="/images/FirefoxIE.jpg" alt="Firefox" title="Firefox"></p><blockquote><p>Firefox 真心命苦，眼看要实现超越，结果 Chrome 来了</p></blockquote><p>2006.10.24 来自：CSDN</p><p>简 介：1993年4月22日，伊利诺斯大学的一个学生小组发明了一段旨在从各种公共网 络上获取信息的程序。当时很少有人会预见这个叫Mosaic的程序将从根本上改变我们的日常生活。1994年，网景拥有了Mosaic，并在在1994年 4月推出了Netscape Communication，很快地，Netscape就以其强大的功能、友好方便的用户界面获得了广大用户的好评。随着微软在1995年8月24日推出 的Windows95，在其后的数个月内，互联网取得了突飞猛进的发展，Netscape更是接着如此东风，取得了70％以上的市场份额（注意：那时候的 Netscape可是一个收费软件）。好景不长，随着微软免费捆绑的IE3.0推出，一场龙争虎斗、硝烟四起的浏览器市场霸主争夺战争就这样拉开了序幕。</p><p>这里，我们记录了历史上浏览器之战中最大的和最精彩的战役。</p><p>在互联网发展早期，第一款浏览器是WorldWideWeb。由Tim Berners-Lee所开发，这款事件上第一款Web浏览器是在NeXT平台上开发，并专门为这个平台所编写的–换句话说，它并不是许多人都可以享受到的。</p><p>随 后，其他一些浏览器接踵而至–www, Erwise, Midas, ViolaWWW, Cello等等。但是真正意义上点开Web的是1993年发布的Mosaic。由(美国)国家超级计算应用中心的Mark Andreessen和Eric Bina所编写，Mosaic成为第一款在同一个窗口中成功结合文字和图片的Web浏览器。虽然早先该浏览器是为Unix平台所编写，但是不久，它就被迁 移到了Mac和Windows平台，使网络浏览为更多的观众所接受。于是，电脑用户们向Web一拥而上，而Mosaic就成为他们联系Web的一个最好的 途径了。</p><p>Round 1: Netscape Navigator vs. Mosaic</p><p>就在发布 Mosaic后不久，Andreessen辞去了在NCSA的工作，创建了Mosaic Communications Corp. 。NCSA继续延用Mosaic的名字，然而，Andreessen的新公司改名为Netscape Communications。同时，NCSA注册了Mosaic技术和商标，并将其提供给Spry和Spyglass公司，以开发全新商业版本的 Mosaic。</p><p>1994年，Netscape发布了一个叫做Netscape的新浏览器，于是，世界浏览器市场的第一次世界大战爆发 了。快 速、稳定并且功能丰富等特色，使得Netscape迅速成为Web浏览事实上的标准。在1994和1995年期间，表示Netscape浏览器的大写N在 接入到互联网的电脑桌面上随处可见。渐渐地，Mosaic抵挡不住Netscape的强大攻击了，慢慢地淡出了浏览器市场。</p><p>The Winner: Netscape Navigator</p><p>Round 2: Internet Explorer 1.0/2.0 vs. Netscape Navigator 1.0/2.0</p><p>当WWW 逐渐成为大众文化不可或缺的一部分的时候，微软决定是时候参加这个互联网大战了。但是，微软并非是白手起家，而是从Spyglass申请注册的浏览器技 术。这样，Internet Explorer的基础实际上就是Mosaic–一款被Netscape所废弃的浏览器。</p><p>1995年8月 Internet Explorer 1.0的发布，引发了一系列有争议的战斗，并扩大了两款浏览器之间的差距，但是IE市场份额增长的一个主要因素就是它的亲和性。在IE发布之前，对于日常 PC用户来说，跟踪和安装一个Web浏览器并非易事：确保拨号兼容性和配置TCP/IP功能需要相当的技术专长。通过利用易于安装的Plus! Pack Add-On在Windows 95平台上绑定它的浏览器，微软迅速开发了一个IE的后续版本。</p><p>然而，很不幸的是，微软那不争气的浏览器在载入Web页面的时候比Netscape慢好多。此外，IE 1.0对许多站点并不是100%的兼容，因为需要Web开发者早先只是关注于确保他们的页面与Netscape的兼容性。</p><p>为 了积极应对这个问题，仅仅在IE 1.0推出后三个月，微软发布了Internet Explorer的一个新的2.0版本。这一草率的修正版添加了许多功能，目的就是提高开发者的效率和降低客户对安全的关注。例如， Secure Sockets Layer（安全套接字层，简称SSL），就是保证数据安全传输的一个重要的加密协议。该版本的浏览器同样还包含了一个集成的Usenet新闻组阅读器。</p><p>Netscape 将IE 2.0的匆忙推出视为一个微软开始进攻的一个信号，于是该公司迅速开始对Navigator开始修改。Andreessen的浏览器，依然是比IE更快， 功能更丰富并且能够显示绝大多数Web站点，占据了浏览器市场的主要份额。但是压力依然存在，Netscape的运气不久就改变了。</p><p>The Winner: Netscape Navigator<br>Round 3: Internet Explorer 3.0 vs. Netscape Navigator 3.0</p><p>1996 年八月，微软再次为Windows 95发布了Internet Explorer 3.0，但是不同的是，这次微软对IE进行了完全的重新编译。这款浏览器包含了大量的新功能，比如Internet Mail和集成了对GIF和JPG文件以及MIDI和流音频的支持。（在IE3.0之前，用户需要去下载辅助的应用程序以显示或者收听这些类型的文件。）</p><p>最为重要的是，微软这次赢取了Web开发社区的芳心。IE3提供了一个支持多脚本语言的灵活的编程模型。并且它引入了层叠样式表（CSS）的首次使用，从而给予了开发者对其页面的显示方式更多的控制权和预见权。</p><p>在 就同一个月，为了应对微软IE的第三次发布，Netscape发布了Netscape Navigator 3.0。基于上两个版本的相同技术开发的3.0，为用户带来两个不同的选择：Standard Edition 和 Gold Edition。Gold Edition带来了许多新功能，比如集成的邮件客户端和针对Web设计的WYSIWYG功能。但是Netscape这次却不是那么幸运，这个改进版本因 为反应较迟钝而收到用户的严厉批评。</p><p>虽然Internet Explorer支持抢占了Netscape的18%的市场份额，但是微软缺在质量上和Netscape拉近了距离。</p><p>The Winner：平局</p><p>Round 4: Internet Explorer 4.0 vs. Netscape Communicator</p><p>1997年标志了Netscape终结的开始。在十月份，微软在浏览器开发上的攻击驱力导致了Internet Explorer 4.0的发布。</p><p>除 了在性能上得到很大的提升以外，IE 4.0引入了一个叫做DHTML（动态HTML）的强大的新功能，该功能可以使开发者们实现达到交互性和页面样式的空前层次。此外，IE 4.0的发布同样也结合了大量在Windows上广泛的升级，包括了MP3的支持。为了应对来自微软IE新功能所带来的冲击，Netscape将其4.0 版本的浏览器以一个新的名称发布：Netscape Communicator。该浏览器是Netscape Navigator的Gold Edition的一个精装版本，并提供了许多集成的应用程序，如一个e-mail阅读器。但不幸的是，这个新的名字惹恼了用户，并且因为该浏览器的启动较 慢和迟钝的表现，用户对其进行了严厉的批评。</p><p>微软已经达到了其在质量上打败Netscape的目的。Web开发者们，技术记者们，以及消费者们开始全体向IE阵营迁徙。</p><p>1998 年，Netscape作出了一个大胆的决定：在一个开源协议的约束下，发布其浏览器的基础代码。有趣的是，这些代码成为了Mozilla的Firefox 浏览器的基础所在，也就是这款浏览器，在6年之后的2004年开始了对Internet Explorer的强有力挑战。就是在同时，美国在线收购了Netscape，并将它的浏览器集成到了AOL客户端中。</p><p>AOL继续着 Netscape Navigator的后续开发和发行，微软也在继续着Internet Explorer的修正和改进之路，但是Netscape Navigator 4.x始终不能战胜微软的IE。到2002年，微软的Internet Explorer占据了浏览器市场超过95%的份额。这场历时7年之久的浏览器之战终于以Internet Explorer的完胜而宣告结束。</p><p>The Winner: Internet Explorer</p><p>Round 5: Firefox 1.0/1.5 vs. Internet Explorer 6.0</p><p>然 而，自从Netscape在1998年公布代码之后，开源项目的成员组织之一的Mozilla.org却在悄悄地开发着一款更好的浏览器。终于，在 2002年，包含一个Web浏览器、一个电子邮件客户端，一个聊天客户端的Mozilla 1.0套件正式发布。但是，直到其在2004年发布一个叫Firefox的独立浏览器之前，这个团队的产品始终没有对Internet Explorer构成太大的威胁。</p><p>强大且灵活的Firefox自称进行了诸多关键性的改进，如标签式浏览（这个功能在一些不出名的浏览 器， 如Opera中已经出现了）和一个集成的RSS阅读器，还有一大批第三方开发的提供扩展功能的插件。2005年11月发布了一个过渡的1.5版本，添加了 许多新的功能，并对现存的版本进行了提高。</p><p>Firefox好似微软得意忘形之际的一个当头棒喝，因为微软因为在浏览器市场没有竞争对 手，故 放慢了对IE的开发，使数年之内IE都未得到很好的改进和开发。由于Firefox对其浏览器市场霸主地位的威胁，微软开始向其最新版本的浏览器–IE 7中加入了许多类Firefox的功能，并对其采取了更好的安全措施。IE 7独立于Windows XP，并将集成于在明年一月发布的Windows Vista操作系统中。</p><p>如今，微软仍然在这场浏览器市场占领的战斗中处于遥遥领先的地位，但是Firefox正在继续挺进。截至2006年7月，据有效数据统计结果显示，因为Firefox的加入，微软的市场份额已经削减至83%。</p><p>The Winner：谁胜谁负全依赖于你如何去看待：Firefox在功能和安全性上领先；但是IE仍然占据了市场份额的绝对比例。鸽子这里认为相比如IE雄厚的后台实力，Firefox绝对已经胜出了。</p><p>Round 6: Firefox 2.0 vs. Internet Explorer 7.0</p><p>事实表明，这场浏览器之战远没有到结束的时候。随着Firefox 2和IE 7在今天的推出，下一回合仅仅只是开始了。</p><p>为 了使IE 7的功能赶上Firefox，微软已经作出了许多努力。微软是否可以通过这些功能，再结合IE 7与Vista的集成，降低人们对Firefox的盲目崇拜呢，亦或Firefox的志愿者开发团队继续保持着Firefox的奇迹呢？接下来几年内，浏 览器竞技场必将上演一场精彩的龙虎斗，大家只管拭目以待吧！</p><p>The Winner: 很快见分晓</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[volatile_in_C]]></title>
      <url>http://fengchao.github.io/2015/10/12/volatile-in-C/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>2009-05-18</p><blockquote><p>这个是 06 年 4 月面试 Intel 实习生的题目。当时确实什么都不懂.</p></blockquote><p><strong>volatile</strong> 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如并口等外围接口的变化与程序无关，还有就是另外的程序可能会改变本程序使用的数据。</p><p>用 volatile 关键字声明的变量 i 每一次被访问时，执行部件都会从 i 相应的内存单元中取出i的值。</p><p>没 有用 volatile 关键字声明的变量i在被访问的时候可能直接从cpu的寄存器中取值（因为之前 i 被访问过，也就是说之前就从内存中取出i的值保存到某个寄存器中），之所以直接从寄存器中取值，而不去内存中取值，是因为编译器优化代码的结果（访问 cpu 寄存器比访问 RAM 快的多）。</p><p>以上两种情况的区别在于被编译成汇编代码之后，两者是不一样的。</p><p>之所以这样做是因为变量i可能会经常变化，保证对特殊地址的稳定访问。</p><hr><p>人生第一次电面，很失败啊</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[远程办公 - 下一个风口]]></title>
      <url>http://fengchao.github.io/2015/10/08/remote-work/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h2 id="科技的力量"><a href="#科技的力量" class="headerlink" title="科技的力量"></a>科技的力量</h2><p>信息技术飞速发展，正在迅速改变各个行业。</p><ul><li>O2O 是整个消费行业的趋势，商场的界限被打破，生产者和消费者直接对接。</li><li>在线教育是教育行业的趋势，学校的界限被打破，最好的老师和学生直接对接。</li><li>远程工作是办公领域的趋势，城市的界限被打破，公司的工作不再受地域限制。</li></ul><h2 id="诱惑"><a href="#诱惑" class="headerlink" title="诱惑"></a>诱惑</h2><p>远程办公会产生巨大的节省，有巨大的市场、巨大的诱惑.</p><ul><li>一线城市，被堵车、交通、雾霾折磨着的人，被高放假压的喘不过气的人，是受益者</li><li>被马太效应压制的二三线城市，找不到合适技术人才的企业，是受益者</li><li>跨国的工作协助也会走上新的台阶，国家界限进一步弱化。</li></ul><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>一些人已经意识到这个巨大市场的存在，但是绝大部分公司依然持反对态度。一些新的协作软件已经出现，但是依然很不完善，只能算是初级阶段。</p><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><ul><li>很多沟通的书籍都强调面对面沟通的重要，定期会面机制。</li><li>需要新的工具，进行远程沟通，远程管理。</li><li>异步工作流程</li></ul><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>很快，不愿意拥抱远程工作的公司，将越来越难招到最优秀的人才，会在竞争中处于劣势。</p><p>当前的公司组织架构、流程、人员、项目管理方式，都会需要为更好的支持远程办公而改变。</p><p>这一切，都预示着一个巨大的市场，巨大的机会。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown_cheetsheet]]></title>
      <url>http://fengchao.github.io/2015/10/06/Markdown-cheetsheet/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight vala"><table><tr><td class="code"><pre><div class="line"><span class="meta"># Header 1 #</span></div><div class="line"><span class="meta">## Header 2 ##</span></div><div class="line"><span class="meta">### Header 3 ###             </span></div><div class="line"><span class="meta">#### Header 4 ####</span></div><div class="line"><span class="meta">##### Header 5 #####</span></div></pre></td></tr></table></figure><p>右侧的 # 可以省略</p><h2 id="带-ID-的标题"><a href="#带-ID-的标题" class="headerlink" title="带 ID 的标题"></a>带 ID 的标题</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line"><span class="section">## Markdown plus h2 with a custom ID ##         &#123;#id-goes-here&#125;</span></div><div class="line">[<span class="string">Link back to H2</span>](<span class="link">#id-goes-here</span>)</div></pre></td></tr></table></figure><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><div class="line">This <span class="keyword">is</span> a <span class="built_in">paragraph</span>, which <span class="keyword">is</span> <span class="built_in">text</span> surrounded <span class="keyword">by</span> whitespace. Paragraphs can be <span class="keyword">on</span> one </div><div class="line">line (<span class="keyword">or</span> many), <span class="keyword">and</span> can drone <span class="keyword">on</span> <span class="keyword">for</span> hours.</div></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">Here is a Markdown link to [<span class="string">Warped</span>](<span class="link">http://warpedvisions.org</span>), and a literal <span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">link.com</span>/&gt;</span></span>. </div><div class="line">Now some SimpleLinks, like one to [google] (automagically links to are-you-</div><div class="line">feeling-lucky), a [wiki: test] link to a Wikipedia page, and a link to </div><div class="line">[foldoc: CPU]s at foldoc.</div></pre></td></tr></table></figure><h2 id="格式标记"><a href="#格式标记" class="headerlink" title="格式标记"></a>格式标记</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><div class="line">Now <span class="keyword">some</span> inline markup like _italics_,  **bold**, <span class="keyword">and</span> `code()`. Note <span class="keyword">that</span> underscores <span class="keyword">in</span> </div><div class="line"><span class="built_in">words</span> are ignored <span class="keyword">in</span> Markdown Extra.</div></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line">![<span class="string">picture alt</span>](<span class="link">/images/photo.jpeg "Title is optional"</span>)</div></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight vbnet"><table><tr><td class="code"><pre><div class="line">&gt; Blockquotes are <span class="keyword">like</span> quoted <span class="keyword">text</span> <span class="keyword">in</span> email replies</div><div class="line">&gt;&gt; <span class="keyword">And</span>, they can be nested</div></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line"><span class="bullet">* </span>Bullet lists are easy too</div><div class="line"><span class="bullet">- </span>Another one</div><div class="line"><span class="bullet">+ </span>Another one</div><div class="line"></div><div class="line"><span class="bullet">1. </span>A numbered list</div><div class="line"><span class="bullet">2. </span>Which is numbered</div><div class="line"><span class="bullet">3. </span>With periods and a space</div></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>And now some code:<br></p><figure class="highlight gcode"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Code is just text indented a bit</span></div><div class="line">which<span class="comment">(is_easy)</span> to_remember<span class="comment">()</span>;</div></pre></td></tr></table></figure><p></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line">// <span class="keyword">Markdown </span>extra <span class="keyword">adds </span>un-indented <span class="meta">code</span> <span class="keyword">blocks </span>too</div><div class="line"></div><div class="line"><span class="symbol">if</span> (this_is_more_code == true &amp;&amp; !indented) &#123;</div><div class="line">    // tild wrapped <span class="meta">code</span> <span class="keyword">blocks, </span>also not indented</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="诗歌"><a href="#诗歌" class="headerlink" title="诗歌"></a>诗歌</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><div class="line">Text <span class="keyword">with</span>  </div><div class="line"><span class="literal">two</span> trailing spaces  </div><div class="line">(<span class="keyword">on</span> <span class="title">the</span> <span class="title">right</span>)  </div><div class="line">can be used  </div><div class="line"><span class="keyword">for</span> things like poems</div></pre></td></tr></table></figure><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line"><span class="bullet">* </span><span class="bullet">* *</span> *</div><div class="line"><span class="section">****</span></div><div class="line">--------------------------</div></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight gherkin"><table><tr><td class="code"><pre><div class="line">|<span class="string"> Header </span>|<span class="string"> Header </span>|<span class="string"> Right  </span>|</div><div class="line">|<span class="string"> ------ </span>|<span class="string"> ------ </span>|<span class="string"> -----: </span>|</div><div class="line">|<span class="string">  Cell  </span>|<span class="string">  Cell  </span>|<span class="string">   $10  </span>|</div><div class="line">|<span class="string">  Cell  </span>|<span class="string">  Cell  </span>|<span class="string">   $20  </span>|</div><div class="line"></div><div class="line"><span class="symbol">*</span> Outer pipes on tables are optional</div><div class="line"><span class="symbol">*</span> Colon used for alignment (right versus left)</div></pre></td></tr></table></figure><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight ada"><table><tr><td class="code"><pre><div class="line">Bottled water</div><div class="line">: $ 1.25</div><div class="line">: $ 1.55 (<span class="type">Large</span>)</div><div class="line"></div><div class="line">Milk</div><div class="line">Pop</div><div class="line">: $ 1.75</div></pre></td></tr></table></figure><ul><li>Multiple definitions and terms are possible</li><li>Definitions can include multiple paragraphs too</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><figure class="highlight gams"><table><tr><td class="code"><pre><div class="line"><span class="comment">*[ABBR]: Markdown plus abbreviations (produces an &lt;abbr&gt; tag)</span></div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[下一站 Hexo - 我的博客历史]]></title>
      <url>http://fengchao.github.io/2015/10/05/Hexo/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>从最开始写博客，一晃已经十年时间。博客平台换了好几个，目前开始 Github + Hexo,追忆一下往事。</p><h2 id="起步-MSN-Space"><a href="#起步-MSN-Space" class="headerlink" title="起步 - MSN Space"></a>起步 - MSN Space</h2><p>最早开始写博客，是从微软的 MSN Space 开始的。研究生刚入学，加了一些同学的 MSN。发现用户签名有标记，点开可以看到 MSN Space 上的新文章更新。那时候时间充裕，所以也开启了自己的 MSN 空间。</p><p>内容以转载为主，包含了印象深刻的电源，动画。后来加入了一些自己历程的总结。有些幼稚，有些年轻。</p><h2 id="Baidu-Hi-Space"><a href="#Baidu-Hi-Space" class="headerlink" title="Baidu Hi Space"></a>Baidu Hi Space</h2><p>后来 MSN 开始持续出现登录异常，很难更新。所以只好换平台，因为那时候百度 Hi Space 界面比较干净简单。就把所有的文章放到 Baidu 上面。</p><p>因为有技术，又有个人内容，经济、历史。感觉比较混乱，后来还单独把技术文章分出一个。</p><h2 id="博客平台的消亡"><a href="#博客平台的消亡" class="headerlink" title="博客平台的消亡"></a>博客平台的消亡</h2><p>再后来，Twitter 出现了，微博出现了。于是很多人都停止大篇幅文章的写作，各个博客平台流量持续下降。</p><ul><li>MSN Space 停了，只有图片还存在 One Drive 里面</li><li>百度 Hi Space 停了，文章保留在了百度网盘</li></ul><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p>因为看到各个平台的不稳定，而自己也开通了阿里云服务器。所以就自己在阿里云上搭建了Mezzanine，导入了以前的博客。Mezzanine 是 Django 写的，之所以选用它，是因为阿里云上已经建好了一个 askbot 站点。而当时我在技术上确实是想向 Python 转移的，后来发现这其实是一个错误的绝对。</p><p>虽然自己的博客平台搭建好了，但是出现了一些问题。SEO 做的很差，几乎没有访问。而我自己的业余时间也大部分都花在 Arch Wiki 上面。所以基本上文章都没有什么更新，就那么空放着。</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>再后来，更新阿里云的时候，Python 2 升级到了 Python 3。Mezzanine 遇到了严重的兼容性问题，至今没时间修复。Python 在我心中的位置，也被 Javascript 取代。</p><p>考虑过搭建 Ghost，但是精力实在有限，就一直没有启动。后来看到 Github 可以当博客平台用，于是就有了 Hexo.</p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>最近几年，经历了很多，整理之前文章的时候，回想当时的一些观点，不禁唏嘘不已。以前写博客是为了吸引眼球，证明自己，展现自己。现在的想法是：</p><blockquote><p>写文章本身，就是一种收获，是一种思想的提炼；而如果这些想法能对别人有帮助，那就是物超所值。</p></blockquote><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[再见 Google Reader]]></title>
      <url>http://fengchao.github.io/2013/03/14/Goodby-google-reader/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p><img src="/images/google-reader.jpg" alt="google reader" title="Google reader"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[KDE 4.10]]></title>
      <url>http://fengchao.github.io/2013/02/07/kde-4-10/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>今夜，KDE4.10 正式发布，一直为 Linux 冲锋陷阵的 Arch 紧随提供了升级下载。Arch 用户蜂拥而至，导致全球所有镜像服务器带宽占满。KDE 官方下载主站也正在经受着大量下载的考验，增加了新的服务器以应对问题。很多听到这个消息的人，都欢声而笑。这一刻，KDE 是幸福的；Arch Linux 是幸福的；我是幸福的。</p><p>过去一段时间，我的大部分业余时间都花在这两个项目上面。</p><p>最早开始接触 KDE，完全是因为在 Launchpad 翻译 Ubuntu，发现有些词条比上游翻译的好，所以就花了点时间将他们同步到上游。接触 KDE 之后，发现其优势，所以就翻译了更多的软件。然后就拿到代码权限，逐步开始看 Bug，一路走来。前些天 Ubuntu 的 Aron 还在 irc 上说自从我跑到 KDE 之后，就没有人刷 Launchpad 的翻译了，这么几年过去了，难得还有人记得我:)</p><p>最早用 Arch Linux，是因为它可以提供最新的 KDE 版本，这样翻译起来更方便。而 Arch Linux 的文档 ArchWiki是最好的技术文档。在 Arch 的论坛里面，经常有人提出 Wiki 的中文翻译都过于陈旧，所以就没事的时候翻译一些文章。翻译英文的时候发现不少页面也是需要改进的，所以就改了不少页面。有一天，ArchWiki 的管理员问我：“想成为管理员吗，每天花一点时间，维护 ArchWiki 的整体质量”。所以我就成了 ArchWiki 的管理员。</p><p>KDE 和 Arch 占据了我很大一部分的工作外的时间。老婆经常抱怨：“又再搞你的开源项目，不来陪我，又不能挣钱，搞它干啥”。成就感吧，这是每个人都渴望得到的。有人通过挣钱来获得成就感；有人通过网络游戏，获得虚拟的成就感；我通过推动自由软件的进步获得成就感。今夜，这个成就感得到了极大的满足：更多的人在使用 KDE，更多的人在使用 Arch。</p><p>软件改变世界，自由软件改变软件。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[别了，Wintel]]></title>
      <url>http://fengchao.github.io/2013/01/28/Goodbye-Wintel/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>曾经，It 界很稳定，Wintel 联盟就是定海神针。</p><p>那是一个美好的时代：绝大部分程序员只需要盯住一个操作系统(Windows)就行了，不像现在，要用 Object-C 开发苹果应用，用 Java 开发 Android 应用，用 C# 开发 Windows Phone 应用，用 Qt 开发黑莓应用, 用 HTML5开发 Tizen 应用…</p><p>那是一个黑暗的时代：所有做芯片的，都要看着英特尔的脸色，有任何越界举动，直接拍死，惨如威盛；所有做软件的，都惧怕微软的魔爪，操作系统绑定是悬在所有软件公司头上的达摩克利斯之剑。微软实行先抄袭兼容、再超越独霸的战略，Borland、Lotus、Netscape 这些曾经红极一时的公司，都惨死在微软的屠刀之下。</p><p>哪里有压迫，哪里就有反抗。</p><p>ARM 出世了，初生的 ARM，非常弱小。为了避免同英特尔竞争，采取了 IP 授权的形式。自己只进行芯片设计，然后把它卖给其他芯片厂商，这些厂商可以根据自己的需要对其进行定制。在黑暗中徘徊的芯片公司终于看到了黎明前的曙光，并且采取了农村包围城市的战略，从低端入手，逐步提高性能。日积月累，低端的嵌入式系统首先被占领，然后是车载系统，手机、数字电视、平板电脑。现在又推出了 ARM64 位系统，准备进攻服务器市场。</p><p>Wintel 还在牢牢的固守着桌面系统，但是他们的疆域目前也仅限于此。<br>进些年，英特尔使出各种招数，希望将自己的领域拓展到移动市场。架构没有 ARM 好，导致功耗下不来，是 Intel 致命的短板。Intel 不是没有机会，它拿到 ARM 授权搞 StrongARM 还是很成功的。但是，傲慢的 Intel，瞧不起龟速运行的 ARM；短视的 Intel，过于信奉其创始人的摩尔定律，没有遇见到有一天，消费者更关注待机时间而不是处理器速度；内斗的 Intel，X86 部门作为最强势、最挣钱的部门，把 StrongARM 扫地出门，卖给了 Marvell。</p><p>硬件上没有办法超越竞争对手，Intel 病急乱投医，希望从软件入手，取得局部优势。这条路走得磕磕绊绊。搞 Moblin 的时候，市场并不怎么买账。和 Nokia 一起搞 Meego，本来还算顺利，直到有一天 Nokia 打电话说：“不好意思，我不陪你玩了。我去抱微软的大腿去。”悲催的 Nokia 从此被微软玩弄于股掌之上，开始了市场份额的自由落体。Meego、Sailfish、Tizen 到底能不能打开自己的一片天地还不好说，期待是金子，早晚会发光吧。</p><p>Intel 起了异心，支持 Linux 系统。微软当然不干了，而且正如很早之前的 这篇文章 的分析结论，ARM 是其必然的选择和出路。于是 Win8 开始支持 ARM 架构，微软开始出 Surface。Wintel 联盟分崩离析。</p><p>天下大势，合久必分、分久必合。</p><p>Wintel 联盟分裂的后果，就是产生出了几十个 CPU 厂商；曾经统治全球的塞班系统已经入土，手机操作系统这个竞技台上，iOS、Android、WinPhone、Blackberry、Sailfish、Tizen、Firefox OS，Ubuntu Phone 正在上演百家争鸣的好戏。谁能最终胜出，还不好说，但是有一点是肯定的：在下一个统治者到来的时候，我们的生活已经发生了天翻地覆的变化。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[上证月K线]]></title>
      <url>http://fengchao.github.io/2012/05/09/stock-k-line/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>为了投资，许多人用各种方法研究股市曲线。什么波段、什么分形，本人在捣糨糊的研究生时代也试图写一篇“基于稀疏神经网络的股市预测算法”. 回望上证月K线的时候我立刻被震惊了！这是一个完美的 PID 曲线. 控制股市的那个手太厉害了，做过控的、运控的必将为之汗颜。</p><p><img src="/images/Stock.jpg" alt="stock" title="Stock"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ZIP - 一个没落天才的故事]]></title>
      <url>http://fengchao.github.io/2012/05/07/ZIP-Story/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>ZIP,一个没落天才的故事，Phil Katz不愿意为一个压缩软件付钱，就索性自己写了一个更好的算法，然后无偿公开。2000年4月14日，他被发现死于一家汽车旅馆，年仅37岁，死时手中握着一个空酒瓶。他留下了zip算法，却没有留下一张像样的照片。</p><p>久违了的zip在你的脑海里还能占据多少空间?或许，你跟本就把它忘记了。</p><p>记得刚上大学的2001年,在电脑报上看到过一篇介绍Philip Katz的文章，那时，我才知道，原来zip是曾经是那么的“不可一世”，那么广泛的被使用着。</p><p>Winzip的创始人是Philip Katz。用Ultraedit打开任一个zip文件，可以看到文件最前面PK两个字母，这便是zip文件格式的创始人Philip Katz的名字缩写。</p><p>在19年前，也就是公元1988年，那时候互联网还刚刚开始有了雏形，而最流行的是一种使用电话线拨号登陆别人在家里搭建的服务平台——交换信息的电子公告牌(BBS)系统。这种系统有些类似现在的论坛和新闻组，由于站长之间互相转信也成为了一个庞大的信息网络(惠多网)。</p><p>老一点的网虫可能都有印象，在没有 Internet的年代，中国大地上也曾有几十个这样的BBS存在，著名的字处理软件WPS的作者求伯君和CCED的作者朱崇君当年都是非常有名的个人站长。</p><p>由于电话线的接入速度慢的可怜，通过BBS传输较大文件实在是叫人痛苦的一件事。于是，使用文件压缩技术减小文件的体积并将多个文件压缩到一个封包中就成为了BBS用户的一项必须掌握的技巧。当时的美国BBS上，比较流行的是一种叫做ARC的压缩技术，由于它是一家商业公司开发的压缩技术，使用这种软件进行工作是需要付费的。那时候的菲利普·卡兹是一个沉迷于BBS 上的毛头小伙，由于经常混迹于BBS上，对于ARC的收费非常不满的他自己开发了一个程序叫PKARC，这个程序与ARC完全兼容，可以压缩和解压缩 ARC文件。这样一来，大批的ARC用户自然转而使用菲利普·卡兹的免费软件。ARC的制作公司一怒之下将菲利普·卡兹告上了法庭，法庭自然判决菲利普· 卡兹禁止继续开发和传播PKARC。这种判决并没有磨灭菲利普·卡兹的斗志，而是激起了他要与ARC斗争到底的决心。在虚拟的世界中，自由、平等永远是真正的程序员永久的追求。</p><p>他放弃了PKARC的开发，发誓要写出一款比ARC更好的压缩软件来打败ARC。这一场官司造就了一名编程天才的横空出世，也造就了一个后来在互联网时代的文件标准。几周以后，后来统治整个BBS世界乃至Internet世界的ZIP在菲利普·卡兹手中发出了第一声响亮的啼哭!</p><p>不名则已，一鸣惊人，这种名为PKZIP的程序可以将一个或多个文件压缩到一个后缀为“.zip”的文件中，无论从压缩比、压缩速度方面都超过了商业软件 ARC。卡兹将PKZIP作为自由软件免费发放，使其如同草原上的星星之火般在全美的各大BBS上蔓延开来，用户以几何级数的增长，各大BBS的站长自发将原来使用ARC格式压缩的文件转换成ZIP格式，卡兹用他天才的头脑和顽强的毅力堂堂正正的击败了ARC，ARC的制作公司在PKZIP的强大攻势下很快就消声匿迹了。用自由软件打败商业公司的传奇故事很快传遍了整个BBS世界，疾恶如仇而又身手不凡的菲利普·卡兹如同数字世界的大侠般仗剑江湖，劫富济贫，以一人之力擎起了压缩软件的大旗。</p><p>此后卡兹一直继续着对 PKZIP的开发和维护工作，PKZIP建立和统治了DOS时代的压缩标准。直到Windows的诞生，使用卡兹创造的压缩算法的软件Winzip的出现更使ZIP格式成为Internet的传输标准，ZIP压缩格式也成为压缩文档的事实标准。</p><p>PKZIP及其“克隆”作品Winzip成为Internet历史上最有名的共享软件之一，ZIP压缩格式也成为压缩文档的事实标准，建立起一个统治Internet的“ZIP王朝”。菲利普·卡兹为世界贡献了一个伟大的共享软件，而他自己却几乎没有从中获得任何好处!因为从一开始，ZIP就是为了反抗收费的PKARC“而生”的。</p><p>但是，不良的生活习惯，长期巨大的精神压力，导致了潦倒无助的他在2000年的4月14号，死在了美国威斯康星州密尔沃基的一家汽车旅馆里，死时，手里还紧握着一个烈性酒的酒瓶。</p><p>Philip Katz从未在ZIP身上得到半点好处，坚持信念的结果往往是潦倒的生活，糟糕的个人生活和长期编写软件的巨大压力使卡兹染上了酗酒的恶习，最终断送了他那年轻的生命。他为世界贡献了一个伟大的免费软件，更为重要的是他缔造了一种大众化的压缩格式，然而却过早地离开了这个世界。</p><p>就在Philip Katz去世的前后，ZIP的最大对手：WINRAR，正在悄然崛起。当时Winzip早已稳坐压缩界头把交椅，但随着2.7版本的出现，Wrar却日益壮大，两者斗争得异常激烈(注：与Winzip一样，其实早在DOS时代，就存在RAR的DOS版本，只是RAR在DOS时代敌不过只能用命令行的ARJ，到了Windows时代又招架不住WinZip的进攻，皆因RAR压缩率低和速度慢，并且RAR压缩格式以前一直缺少其它软件的支持，导致WinRAR都未能广泛流行)。</p><p>就当时两者的性能而言，Winzip压缩只支持ZIP格式，解压缩支持ZIP、CAB，还有TAR、GZip、UUencode、XXencode、BinHex、MIME等几种Internet常用格式(可以看出WinZip的重心之所在)，ARJ、LHA和ARC则需要相应的外挂程序。但WinZip跟Windows资源管理器结合得很紧密，最常用的压缩和解压缩操作已集成到鼠标右键菜单中，点按右键即可轻松完成压缩解压缩。并且增加了不少人性化的功能如E-mail功能，分卷压缩，密码加密等;那Winrar又凭什么与其争锋呢?答案是格式支持与功能!WinRAR压缩格式支持自家的RAR和ZIP(即可“兼容”ZIP)，解压缩支持RAR、ZIP、CAB、ACE、ARJ、LHA、TAR、GZip、UUE，基本上常用的都有了。WinRAR在界面上类似WinZip在功能上基本是WinZip有的它都有，甚至有好多比WinZip还更好更强大。如有特色的”Repair archive”功能甚至可以修复损坏的zip文件;”Convert archive to SFX”功能把RAR和ZIP文件转换成自解压文件，同WinZip不同的是，在压缩时就可以直接存为自解压文件…取对手之精华，并改进之，这就是Winrar敢于与压缩界龙头叫板的原因。</p><p>或许到了这里，你会问：为什么zip不去支持rar呢?这样竞争不就“公平”了吗?但我告诉你的是：zip格式是开放的，任何压缩软件都可以免费使用，RAR是RARLab的专利算法，其它软件要想提供对Rar格式支持必须交纳费用以获得授权，如果winzip想要支持zip，就必须向rarlab付费，这根本就是拿自己的血汗去喂饱对手。我们须明白：winzip和winrar都是共享软件，中国人用惯了盗版的winrar，以为rar才是压缩格式的王道，如果自以为全天下的压缩软件都应该支持rar格式，那么只能说这是一种极其荒谬的认知。</p><p>虽然ZIP仍然是压缩文件的标准格式，但随着WinRAR的功能越来越强大，并且对ZIP的兼容性和ISO镜像文件的支持，固步自封的WinZip已经逐渐开始被网民们所遗忘。面临被打倒，昔日的强者做出了最后的反击–Winzip9.0。2004年发布的Winzip9.0是Winzip公司在02年后两年内第一次发布的Winzip软件更新，可见这次Winzip反击的决心。本版本的Winzip带来了很多新的功能特性，如：加密标准提高，支持符合AES技术的128位和256位的高级加密标准;支持64位扩展技术;内置了先进的“真空”压缩算法(Enhanced Deflate)等。这一切都是针对WinRAR 3.30，誓求夺回压缩界的王座。</p><p>可惜就像乔丹的最后出场一样，也许真的是老了，我们再难看到英雄昔日的光彩。</p><p>WinZip 9.0对压缩格式的支持并没有什么增加，支持原有的18种压缩格式，但仍然不支持ISO这一非常流行的镜像文件格式，并且最大的问题是不兼容RAR，这就令许多用户敬而远之了;相对而言，WinRAR 3.30目前的压缩格式虽然只有15种，但由于兼容ZIP和支持ISO，仅仅这两条就使不少WinZip的老用户心动神移了。</p><p>随着绝唱反击的失败，于2005年7月，WinZip被Vector Capital收购。</p><p>也许在天之灵的Philip Katz并没有想到有这一天，作为下载量达到1亿4000万次，成就压缩标准zip的Winzip计算公司好象没有考虑过用其技术来赚钱的事(实际上很少有人会在WinZip试用期过后支付29美元购买正版授权，因此WinZip至今都没有获得太多利润)。它为大家提供一款如此经典的压缩软件，曾经，它是何等辉煌，但如今却威风难再。或者正如歌词所说:”想回到过去，试着让故事继续，至少不再让你离我而去…”</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[胡适致毕业生：在不健全的中国，如何不堕落]]></title>
      <url>http://fengchao.github.io/2012/04/09/How-to-be-great-in-China/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>原载1932年7月3日《独立评论》第7号<br>这一两个星期里，各地的大学都有毕业的班次，都有得多的毕业生离开学校去开始他们的成人事业。</p><p>学生的生活是一种享有特殊优待的生活，社会都能纵容他们，不肯严格的要他们负行为的责任。现在他们要撑起自己的肩膀来挑他们自己的担子了。在这个国难最紧急的年头，他们的担子真不轻!我们祝他们的成功，同时也不忍不依据自己的经验，赠他们几句送行的赠言，——虽未必是救命毫毛，也许做个防身的锦囊罢！</p><p>你们毕业之后，可走的路不出这几条：绝少数的人还可以在国内或国外的研究院继续做学术研究；少数的人可以寻着相当的职业；此外还有做官，办党，革命三条路；此外就是在家享福或者失业亲居了。</p><p>走其余几条路的人，都不能没有堕落的危险。堕落的方式很多，总括起来，约有这两大类：</p><p>第一是容易抛弃学生时代求知识的欲望。你们到了实际社会里，往往学非所用，往往所学全无用处，往往可认完全用不着学问，而一样可认胡乱混饭吃，混官吃。在这种环境里即使向来抱有求知识学问的人，也不免心灰意懒，把求知的欲望渐渐冷淡下去。况且学问是要有相当的设备的；书籍，实验室，师友的切磋指导，闲暇的工夫，都不是一个平常要糊口养家的人的能容易办到的。没有做学问的环境，又谁能怪我们抛弃学问呢?</p><p>第二是容易抛弃学生时代理想的人生的追求。少年人初次和冷酷的社会接触，容易感觉理想与事实相去太远，容易发生悲观和失望。多年怀抱的人生理想，改造的热诚，奋斗的勇气，到此时候，好像全不是那么一回事了。渺小的个人在那强烈的社会炉火里，往往经不起长时期的烤炼就熔化了，一点高尚的理想不久就幻灭了。抱着改造社会的梦想而来，往往是弃甲抛兵而走，或者做了恶势的俘虏。你在那牢狱里，回想那少年气壮时代的种种理想主义，好像都成了自误误人的迷梦!从此以后，你就甘心放弃理想人生的追求，甘心做现在社会的顺民了。要防御这两方面的堕落，一面要保持我们求知识的欲望，一面要保持我们对人生的追求。</p><p>有什么好方法子呢？依我个人的观察和经验，有三种防身的药方是值得一试的。</p><p>第一个方子只有一句话：“总得时时寻一两个值得研究的问题！”问题是知识学问的老祖宗;古往今来一切知识的产生与积聚，都是因为要解答问题，——要解答实用上的困难和理论上的疑难。所谓“为知识而求知识”，其实也只是一种好奇心追求某种问题的解答，不过因为那种问题的性质不必是直接应用的，人们就觉得这是无所谓的求知识了。 我们出学校之后，离开了做学问的环境，如果没有一二个值得解答的问题在脑子里盘旋，就很难保持求学问的热心。可是，如果你有了一个真有趣的问题逗你去想他，天天引诱你去解决他，天天对你挑衅你无可奈何他，–这时候，你就会同恋爱一个女子发了疯一样，坐也坐不下，睡也睡不安，没工夫也得偷出工夫去陪她，没钱也得缩衣节食去巴结她。没有书，你自会变卖家私去买书;没有仪器，你自会典押衣物去置办仪器;没有师友，你自会不远千里去寻师访友。你只要有疑难问题来逼你时时用脑子，你自然会保持发展你对学问的兴趣，即使在最贫乏的知识中，你也会慢慢的聚起一个小图书馆来，或者设置起一所小试验室来。所以我说，第一要寻问题。脑子里没有问题之日，就是你知识生活寿终正寝之时!古人说，“待文王而兴者，凡民也。若夫豪杰之士，虽无文王犹兴。”试想伽利略 (GALIEO)和牛顿(NEWTON)有多少藏书？有多少仪器？他们不过是有问题而己。有了问题而后他们自会造出仪器来解决他们的问题。没有问题的人们，关在图书馆里也不会用书，锁在试验室里也不会有什么发现。</p><p>第二个方子也只有一句话：“总得多发展一点非职业的兴趣，”离开学校之后，大家总是寻个吃饭的职业。可是你寻得的职业未必就是你所学的，未必是你所心喜的，或者是你所学的而和你性情不相近的。在这种情况之下，工作往往成了苦工，就感觉不到兴趣了。为糊口而做那种非“性之所近而力之所能勉”的工作，就很难保持求知的兴趣和生活的理想主义。最好的救济方法只有多多发展职业以外的正当兴趣与活动。</p><p>一个人应该有他的职业，也应该有他非职业的玩艺儿，可以叫做业余活动。往往他的业余活动比他的职业还更重要，因为一个人成就怎样，往往靠他怎样利用他的闲暇时间。他用他的闲暇来打麻将，他就成了个赌徒;你用你的闲暇来做社会服务，你也许成个社会改革者；或者你用你的闲暇去研究历史，你也许成个史学家。你的闲暇往往定你的终身。英国十九世纪的两个哲人，弥儿(J.S.MILL)终身做东印度公司的秘书，然而他的业余工作使他在哲学上，经济学上，政治思想史上都占一个很高的位置; 斯宾塞(SPENCER)是一个测量工程师，然而他的业余工作使他成为前世纪晚期世界思想界的一个重镇。古来成大学问的人，几乎没有一个不善用他的闲暇时间的。特别在这个组织不健全的中国社会，职业不容易适合我们的性情，我们要想生活不苦痛不堕落，只有多方发展。</p><p>有了这种心爱的玩艺，你就做六个钟头抹桌子工作也不会感觉烦闷了，因为你知道，抹了六个钟的桌子之后，你可以回家做你的化学研究，或画完你的大幅山水，或写你的小说戏曲，或继续你的历史考据，或做你的社会改革事业。你有了这种称心如意的活动，生活就不枯寂了，精神也就不会烦闷了。</p><p>第三个方法也只有一句话：“你得有一点信心。”我们生当这个不幸的时代，眼中所见，耳中所闻，无非是叫我们悲观失望的。特别是在这个年头毕业的你们，眼见自己的国家民族沉沦到这步田地，眼看世界只是强权的世界，望极天边好像看不见一线的光明–在这个年头不发狂自杀，已算是万幸了，怎么还能够保持一点内心的镇定和理想的信任呢?我要对你们说：这时候正是我们要培养我们的信心的时候!只要我们有信心，我们还有救。</p><p>古人说：“信心(FAITH)可以移山。” 又说：“只要工夫深，生铁磨成绣花针。”你不信吗?当拿破仑的军队征服普鲁士，占据柏林的时候，有一位教授叫做费希特(FICHTE)的，天天在讲堂劝他的国人要有信心，要信仰他们的民族是有世界的特殊使命的，是必定要复兴的。费希特死的时候，谁也不能预料德意志统一帝国何时可以实现。然而不满五十年，新的统一的德意志帝国居然实现了。</p><p>一个国家的强弱盛衰，都不是偶然的，都不能逃出因果的铁律的。我们今日所受的苦痛和耻辱，都只是过去种种恶因种下的恶果。我们要收获将来的善果，必须努力种现在新因。一粒一粒的种，必有满仓满屋的收，这是我们今日应有的信心。我们要深信：今日的失败，都由于过去的不努力。我们要深信：今日的努力，必定有将来的大收成。</p><p>佛典里有一句话：“福不唐捐。”唐捐就是白白的丢了。我们也应该说：“功不唐捐!”没有一点努力是会白白的丢了的。在我们看不见想不到的时候，在我们看不见的方向，你瞧!你下的种子早已生根发叶开花结果了!你不信吗? 法国被普鲁士打败之后，割了两省地，赔了五十万万法朗的赔款。这时候有一位刻苦的科学家巴斯德(PASTEUR)终日埋头在他的化学试验室里做他的化学试验和微菌学研究。他是一个最爱国的人然而他深信只有科学可以救国。他用一生的精力证明了三个科学问题：(1)每一种发酵作用都是由于一种微菌的发展; (2)每一种传染病都是一种微菌在生物体内的发展;(3)传染病的微菌，在特殊的培养之下可以减轻毒力，使他们从病菌变成防病的药苗。</p><p>这三个问题在表面上似乎都和救国大事业没有多大关系。然而从第一个问题的证明，巴斯德定出做醋酿酒的新法，使全国的酒醋业每年减除极大的损失。从第二个问题的证明巴斯德教全国的蚕丝业怎样选种防病，教全国的畜牧农家怎样防止牛羊瘟疫，又教全世界怎样注重消毒以减少外科手术的死亡率。从第三个问题的证明，巴斯德发明了牲畜的脾热瘟的疗治药苗，每年替法国农家减除了二千万法朗的大损失;又发明了疯狗咬毒的治疗法，救济了无数的生命。所以英国的科学家赫胥黎 (HUXLEY)在皇家学会里称颂巴斯德的功绩道：“法国给了德国五十万万法朗的赔款，巴斯德先生一个人研究科学的成就足够还清这一笔赔款了。” 巴斯德对于科学有绝大的信心，所以他在国家蒙奇辱大难的时候，终不肯抛弃他的显微镜与试验室。他绝不想他有显微镜底下能偿还五十万万法朗的赔款，然而在他看不见想不到的时候，他已收获了科学救国的奇迹了。</p><p>朋友们，在你最悲观失望的时候，那正是你必须鼓起坚强的信心的时候。你要深信：天下没有白费的努力。成功不必在我，而功力必不唐捐。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在合肥 MTK 的日子]]></title>
      <url>http://fengchao.github.io/2012/03/19/My-life-in-MTK-Hefei/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>时隔一年半，再次来到深圳，再次看华强北，感觉完全不同了。不禁感慨，这两年自己真是变了太多。晚上恰好又和合肥 MTK 的同事 QQ 上聊了会，回忆起当年苦不堪言的日子，觉得还是记下点什么，省得老了忘记了。</p><p>被上海的高房价压迫着，寻思落根二线城市，离家近、朋友多。最后因为加班太多，压力太大而离开联发科，自己都觉得有点出乎意料。作为一个工作狂，居然真的摸到了精神承受的极限。反思一下，公司整体的架构，不管是人事上还是技术上，都有很大的问题。</p><ol><li>自负的”执行力”</li></ol><p>首先一点，MTK 整体的执行力绝对是世界一流的，身在其中，绝大部分人都有一个坚定的信念：没有什么事情是做不成的。不管是什么样的功能，只要真的决定做，可以立即跨组调动所有所需资源，达成目标，就行一辆无坚不摧的战车。但是正所谓成也萧何败也萧何，什么事都能做成的结果，就是什么事都想自己做。</p><p>明明有 make，却要自己用脚本另写一套。明明有 Qt，却要自己写一套 Widget。不断的重复发明轮子，而新发明轮子的质量通常和开源版本相差甚远，不停地冒出 bug，许多人都疲于应对。拿我当时分管的文件系统和设备管理来说，如果使用标准的 glibc 文件操作接口，不另外包一层。如果使用 udev 而不是自己解析 uevent，那么工作量至少减半。</p><ol><li>Nucleus 的包袱太重</li></ol><p>到 MTK 的时候，数字电视部门正在从 nucleus 系统转向 Linux 系统。转化采用了平滑切换方式，应用层接口不变，中间件做平台适配。这样做有其合理性，因为风险较小。但是事实却证明，一失足成千古恨，错误的演进路径几乎成了万恶之源。</p><p>为了适配 nucleus 系统，中间件只能按照原来的 API 进行移植。但是 Nucleus 和 Linux 差别太大了，Nucleus 中是没有内核空间和用户空间之分的，所以原有的 API 中上层可以直接调用下层的任意程序。单单为了满足这一点，无数的丑陋接口产生了，目的就是穿透内核空间。用 Linux 适配 Nucleus 程序的后果就是 Linux 上的通用接口被隐藏，人为包上原有接口。比如文件系统操作， 所有调用都有包裹程序，每个文件操作都要进过多个调用才能完成，效率低下。</p><p>本来，使用 Linux 的目的应该是更好的利用上面的接口和已有程序，到最后还是用那么丑陋的一套，没有很好的利用 Linux 的优势。</p><ol><li>软件分支过多，版本发布过于频繁</li></ol><p>MTK 是以周为单位拉分支的，可谓是前无古人、后无来者。每周四晚上都会打 Tag，冠以 2011_WEEKLY_78 之类的名字，客户分支会从周版本中再拉子分支。我一直怀疑，能想出这种脑残方式的人到底有没有开发过大程序：一周时间根本就不够稳定版本的，唯一能想到的理由就是，每周打一个版本，周一就可以给 QA 发测试版本， QA 就不会干等着吃闲饭。这种极短开发周期的后果就是：</p><p>A. 每个周版本都不稳定</p><p>周分支就像一个流水线，不停地往外冒版本，通常是这个版本的 Bug 还没解，下个版本的 Bug 已经出现在 CR 上。而且在周版本 Bug 解完之前客户版本可能已经拉出来了。</p><p>B. 每天都在下版本、编译、下载</p><p>许多 Bug 都必须在给定的版本上复现，下代码很耗时间，编译也耗时间。尤其是因为 Nucleus 和 Linux 为了代码复用，使用了无数的宏进行控制，根本不可能所有宏都编译一遍，代码编不过非常常见。持续整合的重要性在大程序中显露无余。</p><p>C. 许多 Bug 有 N 多的分支需要发布</p><p>因为在解 Bug 的过程中已经拉出了许多分支，理论上说，所有中间的周分支都需要发布修改。遇到死机等严重问题，一下发布到 70 个分支也是有可能的…</p><p>重点也就这么多了，那段时间真的很累。归根到底，还是公司根本不关心员工的身体，好多老员工都谢顶，工作压力大是最主要的，还有估计就是一个人周围 N 多大电视、显示器，辐射太严重了吧。最近听说开始搞 Android TV 了，希望老同事们的日子会好过一些。</p><p>============================================================================================</p><p>突然间发现访问量激增，从留言中也看到有人因为我的一篇文章而决定不去联发科。突然觉得言论有些偏颇，缺陷说得比较突出，可能是因为处女座的本性吧。就留言中决定不去报到的同学，还请再三考虑。</p><p>太多的东西要另起文章展开了，先简要说下：</p><ol><li><p>总结在合肥半年多的时光，虽然很苦、很累，但是我还是觉得是值得的，并没有后悔当初的决定。加班和来自量产的压力，其实也是动力，软件水平上的提升确实是之前工作的好几倍。</p></li><li><p>并不是每一个公司都能给员工接触世界性产品的机会。上海有许多外企，但是核心技术都在国外。而如合肥这样的二线城市，像 MTK 这样对员工开放核心技术得真的不多。</p></li><li><p>同事和主管对我都很好，帮助也很大。印象最深的就是有天小组长为了帮我解一个超变态 CR 一直到 3 点。</p></li><li><p>最后决定离开，除了加班的压力之外，还有很大一部分来自在上海的老婆，那么长时间没在一起，到现在还觉得有所亏欠。</p></li></ol><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Later == Never]]></title>
      <url>http://fengchao.github.io/2011/12/27/Later-Never/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>翻了翻编辑页面的读取草稿，共有 6 篇文章起好了名字，写了点东西，然后就没了下文。也许当时想的是放放在写，但是实际上：Later == Never。</p><p>Chrome 和 Firefox 都一个非常优秀的插件，名字叫 “Read it later”，架构清晰、界面友好，使用方便。但是至少对我来说，这个插件绝对是有害的。几乎所有标记着随后阅读的文章，都像进入了黑洞，再也没有被拿出来读过。Read it later 变成了 Read it never。这个软件，给了我懒惰的借口，那些标记成随后阅读的文章，大多质量都很高，需要慢慢花时间看的，最后却被这个该死的插件吞了。最后痛下决心，删了这个插件。清理历史的时候，居然发现还有 Gentoo、BIOS 之类的文章，不禁一阵唏嘘。</p><p>后来浏览器也换成了 Chrome， Chrome 的每个标签页都是一个进程，所以相对于 Firefox 会多消耗不少内存。于是就不能像 Firefox 那样同时开几十个标签。这就更强迫自己，要看得文章，不要留在后面看。</p><p>当天的事情当天做，这句话好难。</p><h2 id="2016-10-16-更新"><a href="#2016-10-16-更新" class="headerlink" title="2016-10-16 更新"></a>2016-10-16 更新</h2><p>最近看到 0-bug 对一篇文章，对这个问题又有了新的理解。把一个问题延后，不光会导致问题不再被关注，其实也是一种成本，在下一次看到的时候，还要回忆起整个故事对背景。上下文准备，暗时间消耗。所以说有问题，都尽量在第一次碰到时解决，这是最经济的一种问题解决方式。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Wiki]]></title>
      <url>http://fengchao.github.io/2011/12/27/Wiki/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>现在，已经进入了信息社会。信息社会面对的问题，已经不是信息短缺，而是信息爆炸，信息越来越多，重复信息越来越多，错误信息越来越多。</p><p>搜索引擎从一定程度上解决了信息越来越多的问题，通过各种搜索排名，把有用的页面显示出来。而 Wiki 则可以解决信息重复问题，成为知识合作的最好方式。</p><h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><p>在 Wiki 产生之前，人们共享信息的方式是网站、论坛、BBS 等等。这些形式有一个共同的特点，那就是只有个别人才能进行编辑，而且一般情况页面一旦生成，一般都不能修改。Wiki 就是为克服这点而产生：Wiki 中的文档，是对外开放的，所有注册用户，都可以修改所有的页面，都可以完善不好的地方。这样，大规模的知识合作生产成为可能，而 Wikipedia 就是世界各地人们共同开发合作的结晶。</p><p>“维基百科由来自全世界的自愿者协同写作。自2001年1月15日英文维基百科成立以来，维基百科快速成长，已经成为最大的资料来源网站之一，至今，共有359,017篇条目以中文撰写；每天有数十万的访客作出数十万次的编辑，并創建数千篇新条目以让维基百科的内容变得更完整。”</p><p>很长段时间，因为某些敏感信息，维基百科被封，中文页面的增长基本停滞，让国人晚了几年才认识到这个伟大的发明。还好现在网站解封，而且百度百科的推广，认识使用wiki的人也是越来越多。</p><h2 id="Wiki-的特点"><a href="#Wiki-的特点" class="headerlink" title="Wiki 的特点"></a>Wiki 的特点</h2><h3 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h3><p>因为所有人都要编辑权限，所以通常每篇文章都有需要人参与共同创建。这样虽然每个人知识都有限，但是可以相互补充。三个臭皮匠，顶个诸葛亮。而许多 Wiki 文章由成百上千的人编辑，质量都很高。成为被广泛认可的信息源。</p><h3 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h3><p>文章内容不是固定不变的，只有有改进的地方，都会被逐步完善。</p><h3 id="集中"><a href="#集中" class="headerlink" title="集中"></a>集中</h3><p>一个话题一篇文章就够了，不需要有什么改进还要写新文章。技术 Wiki 更是如此，尤其是开放合作的开源软件。像 Arch Wiki，基本上无所不包，而且很容易搜索到需要的内容。</p><h3 id="每个人都可以贡献"><a href="#每个人都可以贡献" class="headerlink" title="每个人都可以贡献"></a>每个人都可以贡献</h3><p>许多 Wiki 都是公开的，只要注册帐号，就可以编辑，非常方便。过去一年，技术类博客基本上没写过了。花了不少时间在 Wiki 上面。相对于博客， Wiki 确实是更好的技术载体。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[别了，IE6]]></title>
      <url>http://fengchao.github.io/2011/12/17/Goodbye-IE6/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>IE6, Windows XP 中自带的浏览器，曾经成就了微软的辉煌，曾经成为微软涉嫌垄断的重点，一直是网页开发人员的噩梦。今天，随着微软开始自动升级，对 IE6 强制升级，终于迈开了走向最终刑场的脚本。</p><h2 id="IE6-代表了一个时代"><a href="#IE6-代表了一个时代" class="headerlink" title="IE6 代表了一个时代"></a>IE6 代表了一个时代</h2><p>在这个时代里，网景死了，苹果奄奄一息，微软独步天下。在这个时代里，标准都是一纸空文，IE6 就是标准。试用新浏览器的用户经常会问：问什么××× 网页显示不正常？太差了。其实不是浏览器差，而是网页本身有许多错误，而在 IE6 中正好达到他们想要的效果。许多别的应用也一样，打不开 Word (.doc) 的工具不能称为文字处理工具。Word 只能在微软自家的系统中运行，垄断就这样迅速形成。</p><h2 id="哪里有压迫，哪里就有反抗"><a href="#哪里有压迫，哪里就有反抗" class="headerlink" title="哪里有压迫，哪里就有反抗"></a>哪里有压迫，哪里就有反抗</h2><p>网景倒下了，Firefox 诞生了。从一开始， Firefox 就致力于遵循网页标准，当然结果就是相当比例的网页根本打不开。但是在微软的统治之下，无数程序员、网页开发者都把希望寄托在它身上，不断的贡献代码、贡献扩展。Firefox 开源的代码、方便的扩展开发，吸引着越来越多的人使用，市场占有率缓慢的上升。不兼容的网页也越来越少，IE Tab 这个插件，曾经被非常频繁的使用，到现在，需要用的地方越来越少了。随后，苹果基于 KDE 的 KHTML 开发出了开源的 Webkit, 谷歌加入 Webkit 开发，发布开源的 Chrome。不管是功能还是市场份额，开源的浏览器已经完全能够与微软抗衡。</p><h2 id="微软自食其果"><a href="#微软自食其果" class="headerlink" title="微软自食其果"></a>微软自食其果</h2><p>不遵守标准的结果，就是害人害己，这个道理在微软的 IE6 身上得到充分的体现。面对开源浏览器的侵蚀，微软终于拾起好多年都停止开发的 IE6, IE7、IE8、IE9 相继诞生。但是和其它浏览器一样，新浏览器要遵守网页标准，就必须处理无数的 IE6 页面。IE7 有了 IE6 兼容模式。而 IE8 发布时，除了兼容 IE6， 还有 IE7 兼容模式、IE7 兼容 IE6 的模式… 对于任何程序员来说，这都是噩梦。</p><h2 id="宣判-IE6-死刑"><a href="#宣判-IE6-死刑" class="headerlink" title="宣判 IE6 死刑"></a>宣判 IE6 死刑</h2><p>仅仅为了处理 IE6 问题，就耗费了世界无数程序员的宝贵时间，这些时间，本来可以花在美化界面、提供更好功能上。谷歌 Youtube 很早就开始建议 IE6 用户升级浏览器，QQ 开始建议升级浏览器，现在微软开始在世界范围内对开启自动更新服务的系统进行 IE6 升级。从前面的图表可以看到，中国已经是 IE6 最后的龟缩之地。</p><p>如果您还在使用 IE6，请尽快升级，Chrome 和 Firefox 都是很好的选择，实在不行用 IE8 也比 IE6 好太多。</p><p>没有 IE6, 世界将会变得更美好。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[不服用的顾准]]></title>
      <url>http://fengchao.github.io/2011/12/14/Guzhun/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><h2 id="壹"><a href="#壹" class="headerlink" title="壹"></a>壹</h2><p>1952年，37岁的顾准被撤去上海市财政局局长职务。</p><p>关于这次撤职，没有档案材料，只有一份当年2月29日新华社电讯稿的几句话：“顾准一贯存在严重的个人英雄主义，自以为是，目无组织……屡经教育，毫无改进，决定予以撤职处分。”</p><p>人人穿黄布军装的年代，一个穿背带裤，戴玳瑁眼镜，在跟弟弟的通信中常常用“睥睨”二字的人，得到这个评语不奇怪。</p><p>他不是出身望族，12岁在上海会计师事务所当学徒养活一大家子人，15岁已经写出中国会计业的最早教材之一，大家都承认：“整个大华东地区找不出他这样有才干的人”。</p><p>但是这个人“不服用”。</p><p>撤职当天，他一句话不说在办公室坐了一个晚上，他的秘书陪着他坐了整整一个通宵，没有暖气，脚都冻痛了……天亮之后，他“使劲推开了门，走了出去”。</p><p>1个月之后，他找了几本初等几何，代数，微积分……开始学习数学，觉得在阶级斗争和政治动向之外别有天地，他试图沉浸在与人世无关的理性里，一直到1955年进中央党校为止，全部业余时间都用在数学上。</p><p>他受过西方经济学的训练，很容易上手，为数理中的逻辑感到狂喜，以至于沉醉其中，深夜受寒，得了急性肺炎。</p><p>不过他很快跨越对三角尺和圆规的单纯迷恋，他说“逻辑只是工具，研究经济一定要研究历史。”</p><p>他开始研究西方史和中国史，英文是他的另一大重要工具，他依靠这个工具大步跳出了当时扎在知识分子头脑中的篱笆，正好又赶上中央党校在学术上的黄金时期，书尽管有限，但他已经可以直接阅读到凯恩斯和斯密的原作，自己动手改译资本论。</p><p>历史学家朱学勤说，后来那一代知识分子未能达到顾准的成就，是因为“知识大限以及逻辑乏力拖住了他们的脚步”。</p><p>知识让人求实，逻辑让人求是。</p><h2 id="贰"><a href="#贰" class="headerlink" title="贰"></a>贰</h2><p>当一个人知道自己什么都干不了，也不存什么经世致用的念头时，功利也就自然消失，他只是以“不顾死活”的方式读书，作笔记，下蛮力，用笨功夫，来解开思想上的迷惑。</p><p>1956年4月，他开始思考凯恩斯为资本主义开出的药方是否会失效？</p><p>“我作过一个摘记，认为不会。”他说，“可是，（苏共）二十次大会的报告不是这样说法。这是说，我与他们（美国资产阶级经济学家）是一致的了……”</p><p>他被自己的想法吓了一跳，喃喃自语“这糟糕不糟糕？”</p><p>但他无论如何在逻辑上不可能认同计划经济体制：“目前这一套规律，是独断的，缺乏继承性的，没有逻辑上的严整性的”，他谴责斯大林“以道德规范式的规律吹嘘、粉饰太平的理论来描写社会主义经济……”</p><p>1964年，他翻译熊彼得的名著《资本主义、社会主义与民主主义》,里面有一句话“在民主法治制度缺失的群集环境，道德上的限制和文明的思想方法或感觉方法突然消失……是我们面对谁都知道、可是谁都不愿正视的各种毛骨悚然的事实……”</p><p>他精确地预言：“中国的政治空气的大改变将从一年以后开始”。</p><p>“在屋檐底下躲暴风雨，一定要躲过去。”他写道。</p><h2 id="叁"><a href="#叁" class="headerlink" title="叁"></a>叁</h2><p>“观察，而不是愤慨，可观察与记录的就多。”他在日记里写道。</p><p>他在河南商城劳动改造，他腰不好，拿的又是短锄，有时只能双膝跪在泥里，靠双臂支撑着爬行，双膝破损，臂膀全部红肿了，手掌也血肉模糊，很难拿笔。但他写道：“也只是在这样的环境条件下，才有机会学习我国的农村经济这门课。”</p><p>早已经没有了在上海时穿背带裤的习惯，他的新工作是捡粪。因为饥饿，粪越来越少了，他需要站在别人边上，等着人家拉完。衣服上全是粪，他可以不再用工具，“直接用手捡起来”。</p><p>这样每天十五六个小时的高强度劳动之后，他在日记里对自己有抱臂旁观的总结“充裕建设中的劳力来源，这是一个很好的办法，凡是这样的队伍，军事化程度高，效率远高于民工……政治挂帅就是用政治手段来实行经济目的。”</p><p>1959年秋冬的河南，劳动队三餐只吃红薯叶子，但在他眼里“已经是天堂”，大量的篇幅都在记录他每天能找到的吃的，甚至偷的东西。他难以掩饰自己的卑微之感：“人变得下流了”。</p><p>“哀鸿遍野”的饥荒中，他已经没有余心再像1956年那样为自己的命运感到激愤了，连感喟都没有。他在日记里写下所见的浮肿、死亡和人相食的惨剧。</p><p>他为哀鸿遍野时却努力求饱感到羞愧，但是，他说他要保存自己，“至少应该记下一个时代的历史，给后代一个经验教训。”</p><p>“大声说话，理应有此机会。”他写道。</p><h2 id="肆"><a href="#肆" class="headerlink" title="肆"></a>肆</h2><p>1960年之后，到他第二次被划为右派为止，将近10年，他没有日记留世。</p><p>所以，红卫兵让写罪行交代时，他在自己的大字报上只写了两个字“读史”，贴在墙上。</p><p>事后他对朋友张纯音说：“这是一个非常的历史时期，冷眼旁观这一切，只当是在读史，看中国向何处去。”</p><p>他始终有自己的底线，“文革”初期，在河南明城，外调人员要他写材料说明某人过去和国民党有瓜葛。顾准说，从来不知道这件事。对方当即打了他一个耳光。他干脆把脸送过去。对方一连打了十几个耳光之后，终于打不下去了。</p><p>他可以接受自己是牛鬼蛇神和反革命，他从改造地回到家的第一句话就是“我就是反三面红旗，我不反谁反？”</p><p>但他不接受道德上的泼污。</p><p>他从小就极倔强，老师在他作文上写“猫屎狗屎，臭不可闻”，他当众撕碎——“既然臭不可闻，留它作什么？”</p><p>顾有一本中英文对照的《圣经》，有一天他看的时候，被军宣队的一位参谋发现了，便训斥他，“马克思早就说过宗教是人民的鸦片，你怎么能看这样的书？”</p><p>过了几天，顾准拿着一本《共产主义运动中的“左派”幼稚病》去问这位参谋：“列宁说修正主义者为了一碗红豆汤出卖了长子权，是什么意思啊？”</p><p>这位参谋答不上来，顾准说：“这个典故出自《圣经》。你不读《圣经》，就根本读不懂列宁。”军宣队的人从此有意识地避开顾准，即使看见他在看书，也绕着走，以免尴尬。</p><h2 id="伍"><a href="#伍" class="headerlink" title="伍"></a>伍</h2><p>顾准的妻子汪璧，原名叫方采秀，结婚的时候，他们都在做地下革命工作，顾19岁，她20岁，一起流亡，他当时发表文章的笔名多是“怀璧”，情意拳拳。</p><p>他说过，她是他唯一可倾诉一切的人。</p><p>他被撤职后，“我对她说有些寂寞之感，她说读书了就不寂寞了，这是对的。”</p><p>每周六，她都准备一册小说读给他听，他喜爱《安徒生童话》。</p><p>她出差，他在日记里写“悒悒寡欢”。</p><p>他打成右派到商城后，日子已经难熬起来了。</p><p>“接秀信，语句公式化，来商城后第一次半夜呜咽。”这话让人心碎。</p><p>她让顾用自己的40元的生活费买书，她自己的工资用来抚养5个孩子和一个老人。</p><p>他记下唯一忘忧的时刻，是雨雪中的凌晨4点半，在外厨房帮着烧火，“火大，有幸福之感，一时脑袋中想写的东西都忘却，简直是陶醉了。”</p><p>1966年，他被秘密羁押，在自述中说“我在监狱中的态度非常顽固，直到了死不悔改的地步。”他是全国唯一两次被划为右派的人。</p><p>他的母亲这时已经80多岁，在屋子里只语无伦次地重复一句话“我怎么还不死呢？我怎么还不死呢？”</p><p>他从被关押地回来把母亲送到山西的妹妹家，临走的时候，他的母亲“死死地盯住他看了半晌”。那是他们母子的诀别。</p><p>大雪的小年夜，妻子提出离婚，他痛快地答应了。他是从那之后得了心脏病的。</p><p>方采秀给家人的信中曾说，一旦摘帽，可以立即复婚，顾准对此抱着迷信般的希望，在周口店里他痛苦于“刮胡子刀盒被马蹄踏碎，镜破之谶”。</p><p>他仍然每周给妻子写信，方每信必看，但不再回。他们商量过，为了保护孩子，宁可让他们认为父亲是错的。</p><p>他们之后只见过一面。</p><p>他回家想看望家人，看见她满口的牙都脱落了，嘴瘪着，一脸病容，极度憔悴。“你害人害得还不够吗？”她说。他“实在不忍心”，走了。</p><p>冬天冷，他写信说回来取衣服，到了门口，发现所有的衣物都被放在门外，门关着，他久敲不开。走的时候，他把一张存折和粮票从门下塞了进去。</p><p>回到单位，他收到一张4个孩子签字的脱离父子关系的纸，把他的户口和粮食关系也转来了。</p><p>他在日记里写“从此以后，就连他们每月寄粮票来的字迹也看不见。我想念他们。”</p><p>1969年，他预感到妻子出事了，他向组织保证她死了，疯了，病重了，都一不影响改造，二不影响下放，组织告诉了他实情，但是“死期，死况，遗言，一概不知”。</p><p>汪璧是因为被揭发在5年前曾经帮助“反革命分子销毁资料”而自杀的，她把他的所有手稿用水浸湿，揉烂，再放到马桶里用水冲下去，资料太多了，以至于全楼的下水道都发生了堵塞。这样的事情，在解放前的革命年代里，她也为他作过。</p><p>他唯一得到的悲悯，是他可能终生都不知道，汪璧是喝消毒用的来苏水自杀的，死状极惨。</p><p>她的遗书只有一句话，“帮助反革命分子销毁材料罪该万死”。</p><p>她对孩子都没有留下遗言，儿子说，她离婚是为了我们孩子，内心非常痛苦，在提出离婚之前，已经有自杀的念头。</p><p>只有顾准明白“她已经实在支持不住了……”</p><p>他写知道死讯后，“我就去打饭来吃，吃了几口饭，悲从中来，脸伏在饭盆上失声大号”，然后他写：“但我还是抑制住，努力要把饭吃完，我要活下去……”</p><p>据经济学家骆耕漠回忆：“那时，顾准手头拮据，却买了一盏有两个绿玻璃灯罩的双头台灯。江明问他，为什么买两个头的灯？他只是沉默，不回答。后来我们才知道，他是为了纪念死去多年的汪璧，仿佛妻子仍旧坐在他的对面。”</p><p>他后来看《茵梦湖》，写一个人失去自己所爱的女人，孤独终老，他泪流满面地看完，还书的时候说“哀而不怨，哀而不怨”。</p><p>吴敬琏说：“就是他生命的最后一天。他还跟我说了一句，他说他一辈子只爱过一个人。”</p><p>顾临终前，签了认罪书，他哭了，他说这对他是奇耻大辱，但也许能改善孩子们的处境。</p><p>但那还是1974年，他的孩子拒绝在他临终前来看他，“在对事业的热爱和对顾准的憎恨之间，是没有什么一般的父子关系可言的”。</p><p>1974年12月3日凌晨，大风雪，他去世了，“我已经原谅了你们，希望你们也原谅我。”这是他留给孩子的最后一句话。</p><h2 id="陆"><a href="#陆" class="headerlink" title="陆"></a>陆</h2><p>顾准的孤独不同于因为境遇导致的落寞——落寞里还可以充满幻觉或者憧憬。他的孤独，是一个认识到绝境之后，又心甘情愿地停留在这个绝境当中的选择。</p><p>他曾经是最具备理想主义气质的人，等他一旦认识到理想主义变成专制主义的根源之后，几乎是在头脑中把自己杀死了一次。</p><p>那是血肉模糊的厮杀，一个人对过去信仰过的东西不再有敬畏之情，要经历极大的思想危机，从“诗意的理想主义”到“转到冷静的分析”时，十分痛苦，他说自己像托尔斯泰笔下的列文那样，“为我的无信仰而无所凭依”。</p><p>但是他克服了。</p><p>这个克服不是靠简单的仇恨和破灭。是靠认识，推导，批判。真正的批判，批判自己曾真诚信仰，并奉献了全部生命的东西。</p><p>同时批判并不意味着“独断，骂倒，抹杀”，而是重估一切价值，“能够继承和吸收一切良好的东西，能够雄辩地批判一切不正确的东西”。</p><p>他就像朱学勤说的，“黑暗如磐，一灯如豆，在思想的隧道中单兵掘进”。</p><p>他曾一再批评中国人正因为没有笨劲，懒得穷根究底，所以，“中国有天才，而没有科学上系统的步步前进，不停滞、不倒退的前进。中国人善于综合，都是根据不足的综合。”他没有著书立说的机会，只能在和弟弟的通信中，用“热恋般的热情”写下厚厚的笔记，用他说的“穷根究底的笨拙憨态”，写下《希腊城邦制度》、《从理想主义到经验主义》，用吴敬琏的话说，他对一切的研究其实都指向“娜拉走后怎么办？”——无产阶级的革命之后，政治和经济向何处去？</p><p>此时，文革尚未结束，他已经风烛残年，病入膏肓，他自己也知道，没有人会去听一个老人的喃喃自语。但他写道：“学术自由和思想自由是民主的基础，而不是依赖于民主才能存在的东西，因为，说到底，民主不过是方法，根本的前提是进步，唯有看到权威主义会扼杀进步，权威主义是与科学精神水火不相容的，民主才是必须采用的方法。唯有科学精神才足以保证人类的进步，也唯有科学精神才足以打破权威主义和权威主义下面恩赐的民主。”</p><p>靠直觉也可以批评，但是，顾准式的批判，是把包裹着理想外衣的绝对真理，从底部撬动的力量，这是铲除它的合法性的最强的力量。</p><p>这就是顾准的力量，穷尽事理的逻辑的力量。</p><p>像贝多芬的四重奏里反复回旋的“非如此不可？非如此不可！”</p><h2 id="柒"><a href="#柒" class="headerlink" title="柒"></a>柒</h2><p>他在三里河的中科院大楼里工作过，我才知道他离我住的地方这么近，不过现在那里看门的人根本不知道顾准是谁，住过哪间房子了。</p><p>他的骨灰有一半就撒在我家附近的河里，因为暮年时，他常常在这条河边漫步，他那时仍然穿着背带裤，一直戴着一顶从旧帽子上拆下来的白布衬里，没人知道为什么，也没人问过，我猜他也许是为妻子服丧。</p><p>不知道在这条河的边上，他的头脑暂时歇息，暮色四合中，一个人走回去的时候，是怎么样的无望和悲怆？</p><p>很多次从电脑前直起身，看到窗外那条河的方向，我都想起顾准——如果他有一个还算平静的时代，有一张书桌，他将能创造出什么？</p><p>知道了他的存在，人就没有权力狂妄，也没有权力虚无。他早就说过，历史让人不可能发牢骚。</p><p>但知道了他的存在，就像王元化说的，你也再不可能平静，“许多问题一经作者提出，你就再也无法摆脱掉。它们促使你思考，促使你去反省并检验由于习惯惰性一直扎根在你头脑深处的既定看法。”</p><p>我受益于他最深的，是他对人类永恒进步的信仰，去世前，他留给吴敬琏的话是“待机守时”——“总有一天要发生变化，发生变化时要拿得出东西”。</p><p>改革开放后，当吴敬琏成为中国市场经济改革的先驱后，他说“顾准改变了我的全部人生”。</p><p>在顾去世10年后，他的儿女们有机会看到了由他的日记和通信整理成的书稿。</p><p>“人生只有一个父亲，我们对这样一个父亲做了些什么呢？”顾准的大女儿写道，“为什么我们都有强烈的爱国心，都愿意献身于比个人家庭大得多的目标而长期视为殊途……问题的关键在于，我们所接受和奉行的一套准则，为什么容不进新鲜的、可能是更为科学的内容？究竟哪一部分需要审查、更新，以避免以后对亲人以至社会再做蠢事？”</p><p>我们也是顾准的后代，能够正视这些问题，才能无愧于顾准，才能说几十年来，时代的确是在进步的。</p><p>顾准反对将任何人神化，他的思想也并非完美，但是将来的时代评价一个人，不会简单地基于得失功过。</p><p>遇罗克说过，“所谓的不朽，就是在后代的心中引起共鸣”。</p><p>黑暗如磐，一灯如豆，在思想的隧道中单兵掘进。</p><hr><p>看完之后泪流满面，不知道触动了心理的哪根神经…</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序员考题]]></title>
      <url>http://fengchao.github.io/2011/05/01/Example-for-programmer/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>一、选择题（皆为单选）：</p><p>以下谁是二进制思想的最早提出者？</p><p>a，伏羲；b，姬昌；c，莱布尼茨；d，柏拉图。</p><p>以下哪个概念和公孙龙的《指物论》中的“指”字含义相近？</p><p>a，变量；b，数组；c，对象；d，指针。</p><p>蔺相如，司马相如；魏无忌，长孙无忌。下列哪一组对应关系与此类似？</p><p>a，PHP，Python；b，JSP，servlet；c，java，javascript；d，C，C++。</p><p>秦始皇吞并六国采用了以下哪种算法思想？</p><p>a，递归；b，分治；c，迭代；d，模拟。</p><p>雅典王子忒修斯勇闯克里特岛斩杀米诺牛的时候采用了以下哪种算法？</p><p>a，动态规划；b，穷举；c，记忆化搜索；d，Dijkstra算法。</p><p>印度电影《宝莱坞机器人之恋》中的机器人七弟采用的智能算法最有可能是以下哪一种？</p><p>a，神经网络；b，遗传算法；c，模拟退火；d，穷举算法。</p><p>《公孙龙子》记载：“齐王之谓尹文曰：‘寡人甚好士，以齐国无士，何也？’尹文曰：‘愿闻大王之所谓士者。’齐王无以应。”这说明了齐王：</p><p>a，昏庸无道；b，是个结巴；c，不会下定义；d，不会定义自己的需求。</p><p>惠施曾提出过“卵有毛”的命题，以下哪一项是导致这个错误命题的原因：</p><p>a，混淆了命名空间；b，引入了错误的包；c，衍生类未重载；d，调用了危险的指针。</p><p>下面哪种面向对象的方法可以让你变得富有？</p><p>a，继承；b，封装；c，多态；d，抽象。</p><p>明朝时期张居正改革的一条鞭法的主要思想是：</p><p>a，面向过程；b，万物皆数；c，统一接口；d，泛型编程。</p><p>二、匹配题（分析A中的句子所体现的算法，和B中的算法一一匹配）：</p><p>A：</p><p>江南可采莲，莲叶何田田，鱼戏莲叶间。鱼戏莲叶东，鱼戏莲叶西，鱼戏莲叶南，鱼戏莲叶北。——汉乐府《江南》</p><p>众里寻他千百度，蓦然回首，那人却在灯火阑珊处。——辛弃疾《青玉案》</p><p>从前有座山，山里有座庙，庙里有个老和尚，再给小和尚讲故事，故事内容是：从前有座山，山里有座庙，庙里有个老和尚，再给小和尚讲故事，故事内容是：从前有座山，山里有座庙，庙里有个老和尚，再给小和尚讲故事，故事内容是……</p><p>只劝楼台追后主，不愁弓矢下残唐。——孔尚任《桃花扇》</p><p>飞鸟之影，未尝动也。——《庄子》</p><p>B：</p><p>贪心；回溯；穷举；分治；递归；<br>三、阅读理解（阅读下文，回答后面的问题）：</p><p>美国的贝尔实验室设计了最初的C语言 刻在UNIX操作系统距今已有三四十年 你在屏幕前凝视数据的缱绻 我却在旁轻轻敲打键盘把你的梦想展现 循环 递归 贪心 动规 是谁的从前 喜欢在匈牙利算法中你我牵手的画面 经过MSRA门前我以大牛之名许愿 思念像斐波那契数列般漫延 当软工沦落在设计的文档间 算法依旧是永垂不朽的诗篇 我给你的爱写在程序间 深藏在最长不下降子序列里面 几万组数据流过后发现 我的心依然不变 我给你的爱写在程序间 深藏在最长不下降子序列里面 用无尽的代码刻下了永远 那已保存千年的誓言 一切又重演我算了很多遍 时间复杂度还是趋于无限 我只想要这样永远链接在你的身边</p><p>题目中的MSRA是什么的缩写？</p><p>试赏析“思念像斐波那契数列般漫延”一句。</p><p>请结合时代背景，谈谈你对“当软工沦落在设计的文档间，算法依旧是永垂不朽的诗篇”一句的理解。</p><p>“几万组数据流过后发现，我的心依然不变”一句体现了算法的什么特性？</p><p>就“喜欢在匈牙利算法中你我牵手的画面”一句，谈谈你对匈牙利算法的理解。</p><p>本文来源网络，出处未知，真想认识出这试题的牛人啊~</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Live Not By Lies]]></title>
      <url>http://fengchao.github.io/2010/12/20/Live-Not-By-Lies/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>Following is the full text of Alexander Solzhenitsyn’s essay <code>Live Not By Lies.</code> It is perhaps the last thing he wrote on his native soil [before the collapse of the Soviet Union] and circulated among Moscow’s intellectuals [at that time]. The essay is dated Feb. 12, the day that secret police broke into his apartment and arrested him. The next day he was exiled to West Germany.</p><p>At one time we dared not even to whisper. Now we write and read samizdat, and sometimes when we gather in the smoking room at the Science Institute we complain frankly to one another: What kind of tricks are they playing on us, and where are they dragging us? gratuitous boasting of cosmic achievements while there is poverty and destruction at home. Propping up remote, uncivilized regimes. Fanning up civil war. And we recklessly fostered Mao Tse-tung at our expense– and it will be we who are sent to war against him, and will have to go. Is there any way out? And they put on trial anybody they want and they put sane people in asylums–always they, and we are powerless.</p><p>Things have almost reached rock bottom. A universal spiritual death has already touched us all, and physical death will soon flare up and consume us both and our children–but as before we still smile in a cowardly way and mumble without tounges tied. But what can we do to stop it? We haven’t the strength?</p><p>We have been so hopelessly dehumanized that for today’s modest ration of food we are willing to abandon all our principles, our souls, and all the efforts of our predecessors and all opportunities for our descendants–but just don’t disturb our fragile existence. We lack staunchness, pride and enthusiasm. We don’t even fear universal nuclear death, and we don’t fear a third world war. We have already taken refuge in the crevices. We just fear acts of civil courage.</p><p>We fear only to lag behind the herd and to take a step alone-and suddenly find ourselves without white bread, without heating gas and without a Moscow registration.</p><p>We have been indoctrinated in political courses, and in just the same way was fostered the idea to live comfortably, and all will be well for the rest of our lives. You can’t escape your environment and social conditions. Everyday life defines consciousness. What does it have to do with us? We can’t do anything about it?</p><p>But we can–everything. But we lie to ourselves for assurance. And it is not they who are to blame for everything-we ourselves, only we. One can object: But actually toy can think anything you like. Gags have been stuffed into our mouths. Nobody wants to listen to us and nobody asks us. How can we force them to listen? It is impossible to change their minds.</p><p>It would be natural to vote them out of office-but there are not elections in our country. In the West people know about strikes and protest demonstrations-but we are too oppressed, and it is a horrible prospect for us: How can one suddenly renounce a job and take to the streets? Yet the other fatal paths probed during the past century by our bitter Russian history are, nevertheless, not for us, and truly we don’t need them.</p><p>Now that the axes have done their work, when everything which was sown has sprouted anew, we can see that the young and presumptuous people who thought they would make out country just and happy through terror, bloody rebellion and civil war were themselves misled. No thanks, fathers of education! Now we know that infamous methods breed infamous results. Let our hands be clean!</p><p>The circle–is it closed? And is there really no way out? And is there only one thing left for us to do, to wait without taking action? Maybe something will happen by itself? It will never happen as long as we daily acknowledge, extol, and strengthen–and do not sever ourselves from–the most perceptible of its aspects: Lies.</p><p>When violence intrudes into peaceful life, its face glows with self-confidence, as if it were carrying a banner and shouting: <code>I am violence. Run away, make way for me--I will crush you.</code> But violence quickly grows old. And it has lost confidence in itself, and in order to maintain a respectable face it summons falsehood as its ally–since violence lays its ponderous paw not every day and not on every shoulder. It demands from us only obedience to lies and daily participation in lies–all loyalty lies in that.</p><p>And the simplest and most accessible key to our self-neglected liberation lies right here: Personal non-participation in lies. Though lies conceal everything, though lies embrace everything, but not with any help from me.</p><p>This opens a breach in the imaginary encirclement caused by our inaction. It is the easiest thing to do for us, but the most devastating for the lies. Because when people renounce lies it simply cuts short their existence. Like an infection, they can exist only in a living organism.</p><p>We do not exhort ourselves. We have not sufficiently matured to march into the squares and shout the truth our loud or to express aloud what we think. It’s not necessary.</p><p>It’s dangerous. But let us refuse to say that which we do not think.</p><p>This is our path, the easiest and most accessible one, which takes into account out inherent cowardice, already well rooted. And it is much easier–it’s dangerous even to say this–than the sort of civil disobedience which Gandhi advocated.</p><p>Our path is to talk away fro the gangrenous boundary. If we did not paste together the dead bones and scales of ideology, if we did not sew together the rotting rags, we would be astonished how quickly the lies would be rendered helpless and subside.</p><p>That which should be naked would then really appear naked before the whole world.</p><p>So in our timidity, let each of us make a choice: Whether consciously, to remain a servant of falsehood–of course, it is not out of inclination, but to feed one’s family, that one raises his children in the spirit of lies–or to shrug off the lies and become an honest man worthy of respect both by one’s children and contemporaries.</p><p>And from that day onward he:</p><p>Will not henceforth write, sign, or print in any way a single phrase which in his opinion distorts the truth.<br>Will utter such a phrase neither in private conversation not in the presence of many people, neither on his own behalf not at the prompting of someone else, either in the role of agitator, teacher, educator, not in a theatrical role.<br>Will not depict, foster or broadcast a single idea which he can only see is false or a distortion of the truth whether it be in painting, sculpture, photography, technical science, or music.<br>Will not cite out of context, either orally or written, a single quotation so as to please someone, to feather his own nest, to achieve success in his work, if he does not share completely the idea which is quoted, or if it does not accurately reflect the matter at issue.<br>Will not allow himself to be compelled to attend demonstrations or meetings if they are contrary to his desire or will, will neither take into hand not raise into the air a poster or slogan which he does not completely accept.<br>Will not raise his hand to vote for a proposal with which he does not sincerely sympathize, will vote neither openly nor secretly for a person whom he considers unworthy or of doubtful abilities.<br>Will not allow himself to be dragged to a meeting where there can be expected a forced or distorted discussion of a question.<br>Will immediately talk out of a meeting, session, lecture, performance or film showing if he hears a speaker tell lies, or purvey ideological nonsense or shameless propaganda.<br>Will not subscribe to or buy a newspaper or magazine in which information is distorted and primary facts are concealed.<br>Of course we have not listed all of the possible and necessary deviations from falsehood. But a person who purifies himself will easily distinguish other instances with his purified outlook.</p><p>No, it will not be the same for everybody at first. Some, at first, will lose their jobs. For young people who want to live with truth, this will, in the beginning, complicate their young lives very much, because the required recitations are stuffed with lies, and it is necessary to make a choice.</p><p>But there are no loopholes for anybody who wants to be honest. On any given day any one of us will be confronted with at least one of the above-mentioned choices even in the most secure of the technical sciences. Either truth or falsehood: Toward spiritual independence or toward spiritual servitude.</p><p>And he who is not sufficiently courageous even to defend his soul- don’t let him be proud of his <code>progressive</code> views, and don’t let him boast that he is an academician or a people’s artist, a merited figure, or a general–let him say to himself: I am in the herd, and a coward. It’s all the same to me as long as I’m fed and warm.</p><p>Even this path, which is the most modest of all paths of resistance, will not be easy for us. But it is much easier than self-immolation or a hunger strike: The flames will not envelope your body, your eyeballs, will not burst from the heat, and brown bread and clean water will always be available to your family.</p><p>A great people of Europe, the Czhechoslovaks, whom we betrayed and deceived: Haven’t they shown us how a vulnerable breast can stand up even against tanks if there is a worthy heart within it?</p><p>You say it will not be easy? But it will be easiest of all possible resources. It will not be an easy choice for a body, but it is only one for a soul. Not, it is not an easy path. But there are already people, even dozens of them, who over the years have maintained all these points and live by the truth.</p><p>So you will not be the first to take this path, but will join those who have already taken it. This path will be easier and shorter for all of us if we take it by mutual efforts and in close rank. If there are thousands of us, they will not be able to do anything with us. If there are tens of thousands of us, then we would not even recognize our country.</p><p>If we are too frightened, then we should stop complaining that someone is suffocating us. We ourselves are doing it. let us then bow down even more, let us wail, and out brothers the biologists will help to bring nearer the day when they are able to read our thoughts are worthless and hopeless.</p><p>And if we get cold feet, even taking this step, then we are worthless and hopeless, and the scorn of Pushkin should be directed to us:</p><p><code>Why should cattle have the gifts of freedom? Their heritage from generation to generation is the belled yoke and the lash.</code></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 的竞争力]]></title>
      <url>http://fengchao.github.io/2010/09/18/Growing-Linux/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>TCL 的新产线终于经过了试产，正式开始量产，深圳的老总特地飞过来给 DTV 部门开庆功宴。这是具有重要意义的量产，因为是新的 IC 陆规第一个产线，也是 DTV 转向 Linux 之后的第一个产线。深圳的老总敬酒的时候说：“你们桌我认识的人最多，以后多过来，合肥和深圳联手搞，肯定拿回第一的位子。”</p><p>第一的位子，现在是 mStar 的。公司在规划产品线的时候似乎出现了比较大的失误，那就是没有重视大陆的市场。大陆的数字电视标准，由于清华和上海交大在背地里进行毫无意义的死缠烂打，一直久拖不决。于是公司的主要精力都放在欧美、日韩。于是 小M 在大陆成了事实上的垄断，而过去几年，大陆电视的出货量是世界增长最快的，结果是显而易见的。还好没什么技术含量的 DTMB 标准总算是出来了，公司的重心也在往大陆倾斜。至少目前来看，形式还不错。</p><p>除了市场重心的改变，向 Linux 平台的转型则更是意义深远。</p><p>MTK 原来的产品，从手机到数字电视，都是使用 nucleus 作为操作系统内核。优点是短小精湛，比较适合曾经的嵌入式产品。缺点则是没有进程的支持，所有的程序都作为线程运行。最致命的是缺少对网络的支持。</p><p>从欧美电视市场来看，网络电视已经三分天下，网站直接成了电视台。Boardcom 正是凭借网络电视上绝对的技术优势据守美国市场。国内的电视厂商也开始全面铺开，创维有酷开，TCL 长虹有欢网。所以网络电视成为了竞争的主战场。嵌入式 + 网络协议栈，nucleus 难以胜任， Linux 成为不二之选。</p><p>开源</p><p>除了技术上的优势之外, Linux 最重要的一个属性就是开源。可以说开源正是 Linux 取得成功的唯一原因。如果没有 Stallman 的 GCC，如果 Linus 没有将代码发布到 FTP， Linux 根本就不会存在。至少目前来书，开源虽然已经逐步渗透到了 IT 产业的方方面面，还是有许多人从直觉上认为开源违反商业常理。</p><p>对一个代码作为绝对机密的公司更是如此。一边享受开源产品带来的好处，一边把开源作为公司竞争力威胁的人大有人在。阻力是切实存在的，而 Linux 能够冲破这些阻力，不断的攻城略地，最根本的原因，还在于它提供的商业竞争力。不管反对的理由多么强，“xx 已经在用，不用我们无法竞争” 成了最锋利的武器。</p><p>基础设施</p><p>从某种意义上说， Linux 提升了市场竞争的层次。在基础的技术平台上，大家都使用同样的产品，而对这些产品的改进逐步公开出来，成为所谓的信息技术基础设施。单独的少数公司通过提供操作系统获取竞争优势的时代已经过去，就像极少有公司通过修路、建立港口、铺设网线获取竞争优势一样。Google 会把改进融合进 Linux；Nokia 会把改进融合进 Linux、QT；IBM、Novell、Redhat、Oracle 在市场上是死敌，但是它们所雇用的各个牛人、各个 Linux 分支树的维护者，却共同合作，不断完善者同一个代码库。</p><p>开源的力量正在通过这样的通力合作，集合起了越来越强大的力量。而这种决定性的优势，使得 Linux 的应用领域不断扩张。越来越多的成功案例，正在不断的拷问保守者陈旧的商业成见。从嗤之以鼻，认为是少数几个代码黑客的玩具；到惊讶过了这么多年 Linux 居然没有死；到发现可以偷偷使用现成的优秀代码；到积极的参与开发、成为贡献者。人的头脑是顽固的，这个历程是漫长而艰辛的，但这已经成为历史的必然。</p><p>这种思想的改变，会不会跨越纯粹技术领域的疆界，渗透到其它方面、渗透到政治？ 历史说不定正在默默的改变前进的轨迹。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[朝圣 - 深圳华强北]]></title>
      <url>http://fengchao.github.io/2010/09/05/Shenzhen/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>十一是家电销售的黄金旺季，所以各大电视厂商都会赶在 9 月量产出货，所以这个时段的加班是最疯狂的。 本来已经准备回上海过生日大宴宾客，为了 Skyworth 的量产，被拉到深圳解 Bug，原定 3 天的行程一直延长到两周。于是第一次出差、第一次去深圳、生日的时候还干到 11 点，见证了深圳三十年的生日。起早贪黑，连续奋战，终于周五产线开始试产，得以脱身回家。</p><p>八月十五号到的深圳，那时候温家宝正在深圳视察。公司和迅雷在同一个大楼里面，据说早来两天有机会看到温总理。我到每天打车都会路过世界之窗、欢乐谷，都没时间去看下，昨天下午回酒店的时候看得一个海盗船形状的酒店很好看，就想以前怎么没看见，才想起以前都是在夜深人静的时候回的。突然想到一首歌，“ 我们在黑夜里逆风飞行，我们是黑夜里的中国之鹰，我们用黑夜里黑色的眼睛，迎接光明的来临“。</p><p>唯一感到欣慰的是抽空去了趟华强北，也算是不枉此行。</p><p>对于一个 IT 人，华强北就是一个圣地，不折不扣的电子天堂。怎么形容呢，对于熟悉上海的人来说，大概就是六七个太平洋数码 + 四五个北京东路，而销售给人的感觉比较像七浦路。由于下午还要干活，我是赶早去的，山寨手机的卖场里面已经很多人了。 每个卖手机的柜台都有一个大大的保险柜。一路走过点钞机刷刷的响，山寨赚不赚钱这里就能看清楚。</p><p>曾经比较落魄的时候，有过南下深圳的冲动。这两个星期，看过了，感受了，深圳对我的吸引力已经变得没有那么强。低成本、低技术含量确实富了不少人，但是竞争的门槛低、产品难以差异化，许多人脸上都透出一种浮躁。这条路到底能够走多久，值得深深的怀疑。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hacker Hack Thyself]]></title>
      <url>http://fengchao.github.io/2010/08/22/Hacker-Hack-Thyself/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>前几天追内存随机被踩的问题，网上搜资料无意中踩中一个黑客站点。不禁感叹，只有黑客才会用追绝世美女的尽头，去观 察分析 malloc 的一颦一笑；只有黑客会像寻宝者一样，盯着一堆十六进制的数字，剥离出栈变量、程序跳转地址和链表指针，一步步走向目标。不但如此，许多人其实除了钻研代 码，也会钻研人心，小打小闹的就是猜密码，而大神 Kevin Mitnic 更是把社会工程学推到了极致。在有些人眼里：</p><p>“All human beings, all persons who reach adulthood in the world today are<br>programmed biocomputers. None of us can escape our own nature as programmable entities. Literally, each of us may be our programs, nothing more, nothing less.”</p><p>– John C. Lilly, Programming and Metaprogramming in the Human</p><p>Biocomputer70 年代初，人工智能还刚刚起步，心理学和计算机科学联合起来，希望能够认识思维的本质。认知科学、随之诞生，其中经典著作《脚本、计划、目标和理解》开创了信息处理模型分支。其核心思想为：人脑中会形成一系列的脚本(程序)，在不同情况下指导大脑的判断，达到需要的目标。人的一生，一直受这些脚本的支配，并不断的增加新的脚本、从经验教训中改进旧的脚本。虽然人可能一辈子都无法设计好所有的脚本，但是如果真的意识到这些脚本的存在，就有可能更好的利用它们，更快的改进它们。</p><p>表面上看人很复杂，但是许多时候抽丝剥茧，真正起决定性作用的脚本其实并不多。拿用的比较多的气质类型来说，</p><h2 id="控制型"><a href="#控制型" class="headerlink" title="控制型"></a>控制型</h2><p>喜欢推销自己的决定，如果给他输入拒绝、反对意见，那么输出几乎必然是说服、强压。</p><h2 id="分析型"><a href="#分析型" class="headerlink" title="分析型"></a>分析型</h2><p>理性、重事实，如果输入的是没有证据的言辞，必然不屑一顾，嗤之以鼻。<br>重大的决定必然衡量再三，将各种可能性想得足够透彻，询问周围的各种意见。<br>但是做决定的时候，一般不是因为有哪个人的意见，而是综合分析的结果。<br>做决定前表现得比较犹豫，但是决定之后一般不会后悔，因为经过了全面而理性的分析。</p><p>一不小心写多了，鄙人的类型。</p><h2 id="服从型"><a href="#服从型" class="headerlink" title="服从型"></a>服从型</h2><p>从众，不喜欢做决定，从不争吵。追求安全感，不会选择高风险的创意。<br>如果输入的是“大家都是…，大部分都是…”，得到到一般都是“好吧，咱也一起…”。</p><h2 id="表现型"><a href="#表现型" class="headerlink" title="表现型"></a>表现型</h2><p>有创意，关注自己比较多，害怕不被人注意。<br>只要有一个表现的理由阿，必然不会错过，不喜欢别人不屑一顾.貌似和我是天敌……钻研代码，可以控制电脑；钻研人生的脚本，就有可能控制人生.</p><p>Hacker Hack Thyself</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[学英语的方法]]></title>
      <url>http://fengchao.github.io/2010/08/06/How-to-learn-English/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>老早就答应小倩写篇学英语的文章，加班太多，回家太累，一直拖着。今天下了个恨劲，算是一个总结吧，希望对看到的人有帮助。</p><p>效果</p><p>先小小的炫耀一下，用事实证明此方法的有效性。高考成绩：我自己 137；随后把方法传授给表弟表妹，具体分数记不清，应该没有低于 130 的，应该有个 140 的。在俺们家英语考不过 120 根本不好意思跟人家打招呼。最搞笑的是表弟毕业的时候请他英语老师兼班主任吃饭，我大姨夸老师说”俺锐锐能考这么多全靠老师您啊！”，表弟直接来一句：”全是我哥教的”。真是个诚实的孩子。 我一高中同学按照同样的方法，考研也拿了 80 分。如果有人认为我是应试教育，咱看美剧从来不用等字幕。我其实是个低调的人，发完炫耀贴，开始将方法。</p><p>动机</p><p>有不少人就是为了过四六级、就是为了考试，或者为了拿奖励比如一个单词 1 块钱之类。这样的动机是产生不了强大的学习动力的。语言的本质，就是交流的工具。直接的交流，需要能听懂，能说明白。间接的交流，需要能够看懂别人写的文章，自己也要能写出来供别人参考。这个世界的现实就是英语是世界上使用最广的语言，最新的科技、最流行的时尚，最好看的电视剧、电影，英语占了最大的比例。换句话说：你放弃了这个语言，就失去了走在时代最前面的机会。</p><p>信心</p><p>有不少人怀疑自己学好英语的能力。觉得自己发音永远不准、单词永远背了就忘、英语就是听不懂、找不到字幕不能活。人，总是给自己划定原本不存在的边界，然后就固步自封。其实道理很简单，有哪个英国人学不好英语？ 世界上最难学的语言是汉语、是汉字。学不好英语的唯一原因，就是缺乏足够的时间和环境。人的大脑是非常发达的神经网络，只要外界给出足够的输入、足够的刺激，大脑中的神经元就会自动的重组，完成对英语的处理。、</p><p>英语思维</p><p>有一点很关键，你不能在输入和输出之间，再加入汉语。比如说如果看到 Book，你脑子里面出现了 shu 这个声音，那就是错误的信息路径。 Book 应该在脑海里面显现出书的形状或者说那种抽象的概念。如果每次处理、看到英文时的思考是通过中文的那块大脑实现的，那就很难形成专门处理英语的区域。</p><p>听</p><p>很多人都忽略了听的重要性，其实声音的刺激，对语言区域的形成是最关键的。还记得那是在上初中的时候，根本没有网络，更不知道 MP3 是什么东西。就听英语课文，而且听的时候从来都不看文章。上英语课上老师放课文，别人都”认真”的看着课文，只有我会干别的事情。老师开始会瞪下我，后来就习惯了。其实，把声音和文字分开处理，才是成功的关键。最有效的声音刺激，就是把它们作为生活的背景，听的时候可以干任何事情，包括刷牙、洗脸、吃饭、睡觉。许多晚上，我都是听着英语睡觉，记得把声音开得非常小，不然会损伤听力。</p><p>绝大部分人在听新闻或看电影的时候，开始听不懂就放弃了。其实，所有人在学会说话之前，都是听了好久听不懂的汉语的。单词有了一定的量之后，就可以听英语新闻了。开始的时候都是听不懂的，关键是坚持。我那时候是听 CCTV4 的英语新闻，每天中午吃饭的时候看。开始就像听音乐一样，完全分布出来句子中的单词。经过一个多月，逐步的大脑开始能够区分出短句和一些单词，也就两个月，基本上都能明白新闻的内容了。一般的情况是，只要这个单词听懂了，从今往后，就再也不会忘记了。</p><p>读</p><p>所谓的阅读理解，占据了各种英语考试的大半江山。阅读的关键上面已经讲过，就是要用英语思考，绝对排除汉语的渗透。只要有任何翻译过程，速度必然大幅降低。还有就是一点点速读技巧，不要一个单词一个单词的看，要一次看几个单词，这么做不仅仅是速度的提高，还是阻止汉语思维渗透的有效方法。阅读是要有量的支持。回家的时候看到曾经阅读的英语报纸，记得是上海英文报，还有英语学习报吧，差不多半米高，自己都咋了下舌。</p><p>被单词</p><p>有人把它当成英语学习的全部，其实它只是听说读写的副产品。有人拿本单词书从 A 背到 S ：）就再也背不动了。其实纯粹的被单词，只是事先提供一个印象，这写印象是虚幻的。只有从新闻里面、电影里面听到了这个单词，从文章里面看到了这个单词，这个单词才是真实的，这个单词就会从短期记忆过渡到长期记忆。我自己的经验就是一旦见过并回想起来它们一次，就再也不会忘记了。</p><p>坚持</p><p>学英语，其实是一件快乐的事情。通过单词的积累，就可以阅读越来越难的文章，最终过渡到现实的新闻、热播的美剧和专业的技术文章。不过这个过程可能会很长，需要一定的耐心与毅力。</p><p>最关键其实就是在还听不懂、看不快的时候，坚持坚持再坚持，大脑就会产生质的飞跃。许多人在飞跃之前就放弃了，真的非常可惜。希望这个人，不是你。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[台湾的国企]]></title>
      <url>http://fengchao.github.io/2010/08/01/Goodbye-VIA/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>入职两个月，终于转正了。和 Fleisa 进行了简单的转正面谈，大部分属于过场性质，不外乎表现不错，好好干之类。</p><p>聊到新老公司的感受，我说最大的差别就是在威盛会干许多没有用的事情，而在这里做的东西会出现在世纪各地的电视上。当时 Fleisa 就用不可思议的眼神看着我说：“难道没有市场竞争吗？我们有那么多客户想要的功能都没时间实现呢。” 这句话真是醍醐灌顶，原来对威盛里面的好多事情都十分费解，错误的组织架构、错误的市场决策、错误的人在错误的位子上干错误的事情。这一切的一切，都找到了根源。</p><p>离开威盛的时候，心里还是有点怨愤，因为 Nick 被逼走后就我们这帮小兵开始被无聊的人逼着干无聊的事。对某需求提出的合理解决方案一直得不到采纳，原因居然是正确方案属于别的组的工作范围，我们不能做，真是狗屁逻辑。被逼无奈，只好在 Direct Show 上消极怠工，难道我反微软的形象表现的还不够明显吗？我根本就不想在任何微软专有的技术上耗费生命。</p><p>说到这里，真的打心底里面感谢下 Nick，他安排工作的时候总是考虑到个人的喜好。也许是看出我是喜欢新东西的人，总是说有没有兴趣玩这个，有没有兴趣玩那个。于是乎，我玩过了几乎所有的操作系统，改了不少设备的驱动。现在想想，如果不是 Nick 的肺被气炸了，在 VIA 待得久一点，VT6656 也许已经脱离 Staging tree 了。一句话，没有 Nick，我的两年不会有这么快的成长。</p><p>其实一直到最后我都坚信，VIA 是有可能东山再起的。它属于不鸣则已，鸣必惊人的公司。虽然没有了芯片组的辉煌，从 CPU 到显卡到无线到手机，在 IC设计里产品线是最全的，积累了相当多的资源。</p><p>雪红姐姐就更不必说，深得王永庆的真传。虽然只是在去年尾牙的时候见过一面，第一就是感叹她居然看上去比实际年龄小 20岁；第二就是那强大的气场，不禁感叹不知道多少的胸怀和资产才能凝聚起这么大的气场。然而，这气场，显然远离了威盛、吹到了 HTC。威盛在雪红姐姐眼里，也许只是一个需要生命维护仪维系生命的病人；或者是廉价拿地的棋子。威盛的市场策略，就是尽量避开与 intel 的正面对抗，寻找 Intel 没有注意到的地方谋发展。所以在 Intel 与 AMD 拼频率的时候，努力研究低功耗嵌入平台；在 Intel 垄断品牌 PC 厂商的时候发展山寨、白牌。而一旦 Intel 开始发力，比如发布Atom、力推上网本，威盛立即变得力不从心，迅速退败。究其根源，正式缺乏市场竞争意识。</p><p>一个充满竞争意识的公司，各种的讨论都要落实到一点：超过竞争对手，比他们更快更好。在威盛不是这样，这里也有竞争，但是部门头头脑中的最大的竞争对手不是Intel，而是别的部门。比如 PC-1 和精英一起推低端主板专打 VEPD 的 PD，想想就觉得搞笑。</p><p>输给别的公司没关系，绝对不能输给别的部门的思维在威盛相当盛行，相互拆台的事件时有发生。某次销售将客户的需求报给 RD 的 PM，PM能开出一个另所有人乍舌、销售都不好意思和客户提的价格，单子自然飞掉，当时我就想，还不如交给我做私活呢。执行力，每个公司都喜欢说，但只有很少公司能真正做好。</p><p>在 MTK 里，一旦目标确定，只要有利和对手竞争，任何人都很难阻碍项目的推行；一旦目标确定，可以迅速集中合肥、深圳、新竹等地的力量，去完成一个项目。在一些邮件里面，稍稍能够感受到一种挡我者死的气势。这，也许就是如日中天和一个日落西山的差别。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[丰满的历史]]></title>
      <url>http://fengchao.github.io/2010/08/01/Vivid-history/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>历史，都是成功者篡改过的。所以正史总是枯燥的，成功者为了各种目的选择性的过滤了许多内容。如果一个人只是看课本，自然会对历史产生先天的反感，以为历史就是那一串串的年代日期，悲哀啊！。封面中国汇集了1923~1946年美国时代周刊对中国的报道，从时事新闻的视角还原历史。看了一遍感触良多，摘几个片段：</p><h2 id="联省自治"><a href="#联省自治" class="headerlink" title="联省自治"></a>联省自治</h2><p>阎锡山坐拥山西面对北洋各派系的争斗保持中立，“一不入党派，二不问外省事，三不为个人权利用兵。”重视水利，实行国民义务教育，把山西经营成独立王国。 在呼吁地方自治的声音中，有一个年轻人的言论格外响亮，他就是毛润之。他甚至起了一个“湖南共和国”的名称。毛润之认为，实行全国总建设一时还完全无望，最好的办法是索性分裂去谋各省的分建设。</p><h2 id="张学良的不抵抗"><a href="#张学良的不抵抗" class="headerlink" title="张学良的不抵抗"></a>张学良的不抵抗</h2><p>抵抗必败是张学良的忧虑与惧怕；保存实力是张学良必然要考虑的现实。在这里还有一个更重要更直接的因素，就是两年前的1929年，为争夺中东铁路的控制权，张学良与苏联之间爆发的大战，在这场冲突中，张学良惨败。 年轻的张学良更有资格被称为具有现代意识的、热情的爱国主义者。1928年宣布东北易帜，1929 年又决定从苏联手里获得中东铁路控制权。</p><p>战争爆发，绥芬河几乎被苏联的大炮夷为平地，8000 名士兵丧生。乐观自信的少帅，在惨败之后一下子跌落进沮丧的深渊。这场战争必然是被所谓的主流历史所过滤的，因为当时的共产党在共产国际的指挥下，扮演了一个不光彩的角色。</p><h2 id="李德的阵地战"><a href="#李德的阵地战" class="headerlink" title="李德的阵地战"></a>李德的阵地战</h2><p>反围剿的时候，李德为什么坚持外线作战，打阵地站？ 因为他深信苏联会提供大规模的援助，并抱有进行一场大规模正规战争的准备。</p><h2 id="汪精卫"><a href="#汪精卫" class="headerlink" title="汪精卫"></a>汪精卫</h2><p>近代史给人物盖棺定论，最难定的莫过于汪精卫。 刺杀载沣的时候，“慷慨歌燕市，从容作楚囚。引刀成一快，不负少年头”。浩然正气令多少人仰望。</p><p>1932年，他曾经说过：“”哪怕日本能派来百万大军，也会发现不可能征服中国!中日之间不可能之间谈判。蒋介石被迫下野的时候，一改蒋的不抵抗政策，以积极抵抗著称。日本积极抗战的十九路军，正是亲汪精卫的粤系主力。汪曾下令其他部队支持十九路军，但是蒋介石私下指示嫡系部队不支持十九路军，最终导致十九路军孤掌难鸣。汪希望张学良在北方起兵牵制，但张学良根本没有起兵的意思。不知到投靠日本的汪精卫，是不是受到这写人的刺激，才对中国人的抗战失去了信心。</p><p>他，有许多机会成为人人爱戴的民族英雄。但是一步走错，被永远的钉在了汉奸的耻辱柱上。刺者成了被刺者，革命者成了大汉奸，历史的无情变化，以令人震撼的方式在汪精卫身上呈现者。</p><h2 id="历史教科书事件"><a href="#历史教科书事件" class="headerlink" title="历史教科书事件"></a>历史教科书事件</h2><p>这是发生在中国的事件，日本要求中国删除历史教科书里面的大批内容。在被删除的章节中，可以读到这样的文字：<br>“不但国联不可靠，世界上一切国家都不可靠，都是为自己的利益着想，对于我国没有爱护的理由。 东三省问题已经成为第二次世界大战的导火线。第二次世界大战是收复东三省的最好机会。</p><p>觉悟的青年，快下决心锻炼你们的能力和精神，做收复东三省的准备。</p><p>”东三省…… 强邻窥窃数十载，九一八，肆吞并，彼强我若唤奈何？卧薪尝胆功夫永。我们今日小学生，他日中国主人翁；主人翁，下学生，莫忘国土东三省。”</p><h2 id="史迪威"><a href="#史迪威" class="headerlink" title="史迪威"></a>史迪威</h2><p>当时美国进攻日本有两个方向，一个是海路，一个是陆路。陆路方向由史迪威统领中国和南亚的军队。蒋介石在美国参战后获得了大批的援助，却不愿意立即进攻，他要保存实力进攻共产党。史迪威自然不高兴，曾经想和共产党合作，取消对共产党地区的包围和限制，甚至武装共产党的精锐力量赴缅甸作战。</p><p>最终，他的努力失败了，被调回国。随着他离开的，还有美国的陆上进攻计划。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AB 性格]]></title>
      <url>http://fengchao.github.io/2010/07/09/Blood-type-AB/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>最近很少过来写东西，还有一个相当重要的原因就是看到了一个心理学的理论，那就是：“人会在潜意识里面把说出来的期望，当成已经实现的事实。在实现理想的道路上，就会在潜意识里面放松追求。有目标，并深藏于心，才会更有前进的紧迫感。” 基于此，我从潜意识里面就开始停止谈论未来。</p><p>同时，我不会在写最近的事情。因为许多时候，只有记忆经过沉淀之后，才能静下心来，做出理性的判断；许多时候，只有真正说了再见，才会将一个人安放在 生命中的合适位置。未来总是不确定的，只有回望过去的时候，才是最安宁的。</p><p>好久就发现，性格随着年份做大幅度的波动，如果把人生作为横轴，性格做为纵轴，曲线的波幅还真是剧烈。暂时把原因归结为血型，不知道有多少 AB 血型的人有同样的感觉。回望过去，大概是这样的：</p><ol><li>小时候肯定是 A 血型，嘴几乎合不住，用亳州话来说就是“不时闲的咋呼”；</li><li>后来上了小学开始被圈到防盗门里面看书，开始急得要命，圈长了也就习惯了，估计转 B 血性格了；</li><li>上初中之后又开始往 A 血型转，当时班里面有不少人都玩得很疯，所以一下就话多起来，回想起来，算是人生最幸福的时光了；</li><li>高中时候就不一样了，高考的无形压力是一个原因，还有别的一些事情，总之到处弥漫着一种压抑；</li><li>大学之后，就基本趋于 B 血型，其间有过少许反弹，但是总体向下。反正离曾经活波的高峰那是远远不及。难道这就是成熟的代价，或者说越来越像一个真正的程序员……</li></ol><p>有时候，也觉得这种沉闷的性格正在成为前进的阻碍，认识人，积累人脉的速度太慢了。在 VIA 待了两年，真正算的上好朋友的，也就屈指可数。也许是时候做点什么了，我应该大声呼喊：“ Yes ”。算了，先睡觉吧，明天早上再喊。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一言难尽的小结]]></title>
      <url>http://fengchao.github.io/2010/07/07/Short-Summary/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>好久没来了，翻了下发现上篇还是写 Dvorak 的，汗一个。</p><p>四个月过去了，现在已经不会用普通的 Qwert 键盘打字了。Linux 下还好了，只要设置一下就可以切换回来。 XP 下由于键盘映射的架构不好，所以要使用输入法，就必须修改注册表重新登录，所以外人碰我电脑基本立即晕菜。</p><p>过去的四个月，一个月因为键盘切换打字慢，所以懒得码字；一个月拼命面试；一个月的离职期，上头丢了个不大不小的项目过来，正常四周的工作两周做完，被剥削了最后一点剩余价值；然后就跑到合肥的联发科报道，一堆子事情，试用期没有过就开始看到 CR 在逐步的堆积。另外在 KDE 翻译上的时间也不少， KDE SE 4.5 快发布了，如果有人使用的时候发现简体中文翻译的质量有所提高，请记得其中有我的血汗。</p><p>时光飞逝，沧海桑田。四个月之前，绝对想不到变化会有这么大。有时候也在想，离开上海跑到大蜀山脚下天天加班，到底值不值，这条路，到底对不对。至少有几点理由是没法被推翻的：在上海的职场往上爬，不是我想要的；上海的房子在我的心里远超过其价值，不是我想买的；在 MTK 的进步是 4X 倍速的，正如 Nick 所说：“ 你有的学，就看有没有命活着出来…”；在这里，我更容易实现人生的突破。</p><p>为了走得更远，是该回顾整理一下。大脑和程序一样，重构完了，才容易增加新的功能。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自洽]]></title>
      <url>http://fengchao.github.io/2010/03/17/Self-Consistency/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>好就都没有更新了，在这个信息爆炸的社会，越来越多的时间用来获取信息，越来越少的时间用来消化信息。新闻、论坛、博客、IRC，每天光是把鲜果里面感兴趣的内容看完就要花不少时间。有时就在想，是不是该删掉点订阅了。按道理说，输入越多，应该输出越多。但是有好几次，写了个开头又不想写了。人缺少方向感，博客就会真的混沌了。</p><p>看过不少文章讲述自由软件/开源软件的历史，不少文章评价 Richard Stallman。大部分的评价，要么是赞扬一个人如何引领改变世界的革命，要么是批评他的强烈意识形态的处事态度。只有一个词震撼了我,那就是”自洽(self-consistency)“。他发现了一个问题(软件限制自由)，找到了一个解(自由软件、GPL)，然后用整个人生实现这个解。GPL 从发布到现在只有20年的时间，世界已经沧海变桑田。</p><p>能为人生找到这种自洽性，是一件幸运的事，而且能够抵制途中的各种诱惑，更是难上加难。从最早开始写博客，就希望用两个主线贯穿其中：</p><ol><li>人工智能必然会超过人类</li><li>共产主义一定能够实现</li></ol><p>回过头来再看，还好没有偏离太远。但是有些事情还是没有讲清楚。比如这个共产主义，其实就是很难统一的一个概念。从马克思最正统的解释，这是一种生产方式；而事实上经过冷战的洗脑战，绝大部分西方人和相当一部分中国人，都把共产主义当成政权的组织形势。一边说面包牛肉随便吃，一边用《1984》进行集权主义的刻画。实际上，都错了。</p><p>说来说去，相信人工智能的人很少，相信共产主义的人，更少。同时相信的人，比如我，面对芸芸众生，真的开始思考这些问题，就会觉得很孤独。感叹这个星球上，到底能有多少人真的可以产生共鸣。</p><p>然后我就开始放弃思考，面对现实，融入众生。朝九晚八，挤公交、攒房子。很久以前都在想，也许有一天，我会放弃所有的理想，从俯视大地的高空坠落，安安稳稳终其一生。只是不甘心，也许对于我来说，安稳的日子得来其实太容易，所以不满足。</p><p>希望博客能够自洽，希望人生能够自洽。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[工科的实用主义]]></title>
      <url>http://fengchao.github.io/2010/02/04/Engineering-thinkinng/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>最近，围绕 utrace 能不能进入 Linux kernel 主开发树展开了一场论战。Linus Torvalds、Ingo Molnar、Andrew Morton、Alan Cox、Tytso 等悉数加入。Linus 一直强调的观点就是：如果 utrace 只提供了一个非常灵活，可以做无数“未知”事情的接口，而不能提供杀手级应用，则不会被接受进内核。</p><p>原因不是因为我们需要杀手级应用实例，而是因为只有有了这样的应用程序，接口才能在实际使用中得到逐步完善。内核发展的历史中已经经历过惨痛的教训，因为只提供接口而缺少应用，导致整个接口发展的停滞不前。开源软件的实用主义风格展现得淋漓尽致。</p><p>通常我们只说学以致用，实际上，太多的时候，只有用了，才能真正学会。大一天天学微分积分，直到最后在物理课上天天用积分算电场磁场，才算真正懂了；学自控的时候张口 PID，说句实话知道最后在计算机控制里面实际写了 PID 控制程序才算真正懂得 PID 是干什么用的。</p><p>写到这里突然想，所谓的工科生，不就是通过这么无数的实用主义实例早就出来的么。讲求逻辑、追求客观和理性，冷静到令人发指。工科了这么多年，早已对无端的幻想嗤之以鼻，习惯用几何、对称和分形解释美学。曾经的科幻迷，连《三体》都看不下去了，因为大脑已经不能跨越物理科学与科幻的鸿沟。也许，只有哥本哈根解释和平行宇宙类的硬科幻，才能提起我的兴趣。</p><p>这样的工科生，缺乏浪漫是必须的。不要说什么红绿灯很好看，不就是发光二极管么。我还要说，想当年，我用汇编、C 在 80896、PIC、PLC 上都写过交通灯实验，必须的。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微软的选择]]></title>
      <url>http://fengchao.github.io/2010/01/25/Microsoft-choice/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>最近一段时间，越来越多的微软高管开始在公开场合诋毁 Linux。这表明微软越来越重视 Linux 带来的现实威胁。微软在操作系统领域的垄断，严重阻碍了其进展。而未来激烈的竞争，尤其是移动操作系统平台上的竞争，肯定会极大促进这方面的发展。</p><p>有些时候，微软诋毁的理由过于幼稚。比如说微软娱乐与设备部门的 Robbie Bach 预言说 Linux 在移动设备上一定会失败，因为用户有太多的选择。目前，微软的这位高管认为，目前市面上已经有多达 17 种 Linux 系统用在移动设备上。而选择对用户不利，所以 Linux 会失败。这个论断很雷人。</p><p>回顾一下历史，微软为什么会成功。不是因为微软的产品单一，而是因为越来越多的软件厂商选择在 Windows 上开发软件，所以用户在这个平台上有更多的选择。试想，如果在 Windows 上，只有一种画图软件，只有一种聊天工具，只有一种显卡，没有了选择，谁还会选择微软。</p><p>表面上看，GNU/Linux 是有许许多多的发行版。但是它们大部分都有一个共同的内核 Linux，共同的函数库、开发工具。最大的区别也就是默认软件的选择和软件包的管理方式。而几乎所有的软件都来自上游开发，发行版仅仅是进行软件的整合。所以更多的发行版，并不是更多的内核；其本质，是有更多的软件选择。在 Windows 下，桌面管理只有一种选择，而在 Linux 下，可以选 KDE、Gnome、Xfce…… 每个桌面环境又有一系列软件供选择。虽然目前来说，好多软件还有待提高，但是随着越来越多厂商的加入，外加开源开发这种开发模式，相信许多软件正在逐步超过 Windows 下的产品。</p><p>另外最关键的一点，微软的主流系统还不支持 ARM，而 Linux 下许多发行版对 ARM 的支持已经很完善。许多软件可以直接从桌面系统直接拿到 ARM 平台编译使用。微软选择不支持 ARM，ARM 就会选择抛弃微软。实在看不出，Windows Mobile 在昂贵的收费下还有多少竞争力。</p><p>物竞天择，适者生存。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[李锐谈中国政治体制改革]]></title>
      <url>http://fengchao.github.io/2010/01/24/Reform-by-Li-Rui/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>2月20日下午86岁的毛泽东前秘书李锐先生在北京家中接受了《21世纪环球报道》记者的独家专访，围绕党和国家领导体制改 革，谈一些自己的观点。</p><h3 id="曾经打算联名写建议书"><a href="#曾经打算联名写建议书" class="headerlink" title="曾经打算联名写建议书"></a>曾经打算联名写建议书</h3><p>《21世纪环球报道》：您去年十六大前给中央常委的信《关于政治体制改革的意见》，在今年第1期《炎黄春秋》上以《关于我国政治体制改革的建议》为题发表，具体情况怎样？</p><p>李锐：《炎黄春秋》发表时，将最后一段删节。我先讲讲这个意见书的过程。我们有些老同志，平时碰面时很关心当前形势和存在的问题。十五大我不是做过长篇书面发言吗？十六大要召开了，因此就想到再写个东西。曾经打算找几个中顾委委员、中科院院士，联名写建议书。后来考虑这个方式是不是好？各人有意见还是各人提吧。</p><h3 id="小平为何未能实践自己的讲话"><a href="#小平为何未能实践自己的讲话" class="headerlink" title="小平为何未能实践自己的讲话"></a>小平为何未能实践自己的讲话</h3><p>《21世纪环球报道》：您在建议中提到，鉴于毛泽东晚年错误导致文 革 浩 劫，邓小平于1980年作了《党和国家领导制度的改革》(见《邓小平文选》第二卷)的报告，认为过去总病根在权力过分集中，一把手说了算；并指出”我们所有的改 革最终能不能成功，还是决定于政治体制改革”。但讲话被人所阻，没能贯彻下去，这人是谁？</p><p>李锐：当年一位主管意识形态的政治局委员，信中我是写了名字的，即胡乔木。那时出了波兰团结工会的事情，他坚持”左”的立场，趁机做文章。</p><p>《21世纪环球报道》：小平讲话很明确，但您说他自己也未能认真实践，给历史留下了遗憾，为什么？</p><p>李锐：十五大的书面意见中，我曾建议总结改 革开放20年来的经验教训，提到七个问题。包括胡 耀邦辞职问题，我讲这么一件事情你就明白了。据说，第三代领导接班的时候，小平讲了这样三句话：毛在，毛说了算。我在，我说了算。你们什么时候说了算，我就放心了。改 革开放以来，特别是做出第二个”历史决议” (1981年6月通过的《关于建国以来党的若干历史问题的决议》；第一个历史决议是40年代在延安通过的《关于若干历史问题的决议》)，否定文化大革命以来，我认为在经济上小平是抓得很紧很正确的：”不要问姓社姓资”，”一个中心”，”三个有利于”，从理论到实践都很正确。试问：不搞市场经济，不进入 WTO，中国经济怎能出现当前的局面？小平在经济上坚决反对过去”左”的一套，看到苗头不对，才有1992年的南巡嘛，将经济滑坡向左转的局势挽救过来了。但是在政治体制上，领导体制上，他认为中国这么大，这么多人，七嘴八舌，没有一个权威是不行的。对资本主义政治体制，所谓三权分立，他是坚决反对的。”清除精神污染”匆匆停止后，又接受”左爷”建议，提出反对资 产 阶 级 自 由 化。他认为胡 耀 邦是资 产 阶 级 自 由化的总后台。中顾委没有解散的时候，十三大到十四大之间，有一年，薄一波还传达过小平关于权威主义的讲话。这来自新加坡李光耀。大概小平是赞成李光耀那一套的，认为没有权威不行。胡 耀 邦辞职，实质上是政治体制不改革上出了问题。1980年小平那篇掷地有声的文章，是由于当时李维汉跟他一次长谈，讲我们过去的问题还是封建专制主义。毛搞个人崇拜，专断独裁，根深蒂固，政治体制不改 革不行。实际上苏联垮台，大家知道也是斯 大林独裁所致。为什么那篇文章又置之高阁？归根结底，除了胡乔木等影响外，还是他自己摆脱不了旧的认识，旧的习惯。我十五大那篇书面发言，要总结改革开放二十年的经验教训，就包括总结小平的错误在内。犯错误难免，重要的是要总结教训，才能避免重犯错误。建议得到高层回应《21世纪环球报道》：你们认为《建议》在多大程度上能被新的中央领导所接受？</p><p>李锐：我的建议，好像接受得比较普遍，老中青三代普遍赞成。我提出的政治体制改革和必须民主化、法治化的问题，证明是一个普遍的大家都关心的问题。现在传出来，中央领导都赞成这种意见。这当然给大家一个希望。</p><h3 id="常委任期5年，十二大后已经解决"><a href="#常委任期5年，十二大后已经解决" class="headerlink" title="常委任期5年，十二大后已经解决"></a>常委任期5年，十二大后已经解决</h3><p>《21世纪环球报道》：您建议中央常委任期5年，连任一届。有实现的可能吗？</p><p>李锐：这实际上是废除领导干部的终身制。这个问题，十二大后已经基本解决。后来小平退出常委，已经身体力行了。胡 耀 邦早就讲过，他在十三大上要退下来。</p><p>《21世纪环球报道》：您还提出领导干部不能在党、政、人大、政协轮流转。</p><p>李锐：我认为这个不太好。这意味着领导干部并没有完全退嘛，实际上把人大、政协变成很次要的岗位，只有党的岗位是唯一的、最高的。</p><p>《21世纪环球报道》：您对现在各省、市委书记兼任人大主任怎么看？</p><p>李锐：兼任的利弊到底怎么样？我说不清楚。如果把人大当作立法机构，它区别于执政，那么一个地方党的书记兼任人大主任还是可以的。如果为了一把手说了算更方便，那就不好了。将来还是要用选举的办法来解决。现在，我们的干部还是任命制，由上而下的决定制，并不是真正的选举制。党内也好，人大也好，各级政权班子，应该实行真正的选举制，这可以从基层开始。</p><p>《21世纪环球报道》：您建议十七大以后，政治局委员、常委和总书记都在党代会上竞选产生，有可能吗？</p><p>李锐：这个很难讲，也许有这个可能。5年中大家都希望有所变化。如果真正按宪法办事，即逐步实施宪政，当然有希望。</p><p>《21世纪环球报道》：有报刊讨论人大和政协实行代表职业化制度，您认为其难度在什么地方？</p><p>李锐：现在的问题是人大代表和政协委员人数太多。人大是立法机关，代表应具备相应的政治素质和文化素质。当然，代表要代表各个阶层，工人、农民都得有。如果难以一下子改变，那么人大常委会常任制，实行职业化，应该好一点。</p><h3 id="政法委书记统管公检法不合理"><a href="#政法委书记统管公检法不合理" class="headerlink" title="政法委书记统管公检法不合理"></a>政法委书记统管公检法不合理</h3><p>《21世纪环球报道》：关于司法独立，目前议论比较多，党委直接干预公检法的事很多。您怎么看？</p><p>李锐：政法委是党内机关。党的政法委书记统管国家公、检、法执法机关，同依法治国的方针相抵触，是不合理的，等于党直接干预司法。十四大还是十五大时讨论过这个问题。问题在我们没有真正把党政分开。我们还是党大于法，人治大于法治。所以讲来讲去，根本的问题还是在党。这个不改善，一切无从谈起。毛 泽东说过：”党外无党，帝王思想；党内无派，千奇百怪。”他似乎接触过执政党和一党执政好不好的问题。《21世纪环球报道》：您在建议中提出国家政治生活民主 化的六个措施，其中提出搞《政党法》和《参政法》。您是怎么考虑的？</p><p>李锐：就讲一个问题。现在搞这么多干部，都是吃国家财政饭。一个政党在国家、社会和全体人民中，处于一个什么位置，负什么责任，怎样操作，包括其经费来源，等等，都要搞清楚。谈到执政，我们国家现在是两张皮，党政不分、难分。上上下下还是”一把手”说了算。权大于法，”权力导致腐败，绝对权力导致绝对腐败”。所以我的意见书开篇即说：”问题仍在政治体制改革步伐过慢，民主滞后，法治难张，腐败之风日益盛行。”</p><h3 id="毛泽东七大讲话未公开的内容"><a href="#毛泽东七大讲话未公开的内容" class="headerlink" title="毛泽东七大讲话未公开的内容"></a>毛泽东七大讲话未公开的内容</h3><p>《21世纪环球报道》：您提出要破除民主党派只任副职的陈规，可能吗？</p><p>李锐：民主党派任副职，实际上作用有限，甚至只是个摆设。任正职就不同了，有个责任问题。在开国之初还有民主党派任正职。但后来就没有了，特别是反右以后，到”文革”就更不用讲了。毛 泽东在七大的讲话，现在已经出了书。他的口头报告，我当年听到的传达，讲有这样的话，开国以后，掌握政权以后，我们的斗争对象就是民主人士了。我的印象非常深。他的关于人民内部矛盾的口头讲话，跟后来的文字稿，也截然是两回事。</p><p>《21世纪环球报道》：这么说，反右并不开始于1957年，实际上酝酿于延安时期？</p><p>李锐：在延安时期，从对人对党员的思想控制(做驯服工具)，到树立毛的个人绝对权威，是通过整风运动完成的。毛的心态是：领导这个党(这个国家)，非我莫属，都要听我的，即以他的意志划界线。1949年以后的历次政治运动直到”文革”，可以说是延安整风的继续和发展。最近，答罗稷南问，”鲁迅反右时处境如何”的答复揭露出来后，大家对毛的作风性格等，就更清楚了：他决不放过一个”异己分子”。(注：罗稷南当年与赵丹、黄宗英等知名人士接受毛主席小型宴请。宴会中，他问主席，如果鲁迅活着，在反右运动中会怎样，主席回答，要么他不说话，要么关在监狱里。黄宗英在会议记录中对此有专文记载。)这个问题，我 1992年写了《毛泽东晚年”左”的错误思想初探》一文，9万多字，说得比较清楚。当时《桥》杂志整期刊登，后来收到《李锐反”左”文选》一书里。</p><h3 id="中国最大的危险是人治"><a href="#中国最大的危险是人治" class="headerlink" title="中国最大的危险是人治"></a>中国最大的危险是人治</h3><p>《21世纪环球报道》：还是在十五大的书面发言里，您当时认为中国面临七个危险：封建专制主义余毒依旧存在；党的威信下降，腐败蔓延，自己难以监督自己；如何防止新的资产阶级作为左右社会的力量出现；国外威胁；香港与台湾问题；自然生态环境问题；中国人多而素质不高的问题。现在，这七个危险是否依旧？</p><p>李锐：最大的危险是人治。只谈一件事情，现在全国错案、冤案很多，尤其是经济案件。有一个省的一件经济案，牵扯到香港的投资。上一届的几位省领导，将案件材料寄我，让我转交中央有关领导处理。从1998年开始，直到现在，转上去十几次信件，由于牵涉到现在的省领导，至今解决不了，错捕的人也放不了。我十六大的上书，提出民 主化、科学化、法治化，真正依法治国，是有自己几十年的切身体会而言的。党内没有民主，国家也就难有民主。所以不能搞党高于一切，”一把手”高于一切。我为什么在十六大建议中引邓小平的话呢？他1941年撰文说：”应反对‘以党治国’的观念。”那时共产党没有得天下嘛，小平讲得比较合理。此文是《邓小平文选》第一卷的第一篇文章。</p><p>《21世纪环球报道》：您提议的总结改 革开放20年的经验教训，做出”第三个历史决议”，估计何时能搞呢？</p><p>李锐：那要看以后形势的发展了。当然，教训都接受了，政治体制改革逐步实现了，不做出这个决议也没有关系。</p><h3 id="宪法是防止权力滥用的"><a href="#宪法是防止权力滥用的" class="headerlink" title="宪法是防止权力滥用的"></a>宪法是防止权力滥用的</h3><p>《21世纪环球报道》：您这些建议的突破点是什么？</p><p>李锐：胡锦涛总书记上任后，第一次公开讲话是谈宪法，纪念新宪法颁布20周年。他在讲话中说：”要抓紧研究和健全宪法监督机制，进一步明确宪法监督程序，使一切违反宪法的行为都能及时得到纠正。”宪法首先有一个修改问题，如私有财产权的保护还没有正式明确列入宪法。宪法的实质是监督政府，就是赋予公民监督政府权。西方几百年是这样走过来的。在我们革命过程的习惯上，执政几十年，权力在党的手上。宪法是防止权力滥用的。我们党权高高在上，个人说了算，这实际上是权力的异化。我们号称来自群众中间的党，不能变成统治群众的党。所以我提出制定《政党法》和《执政法》，成立宪法法院，就是要从法律上解决这个问题。政党怎么执政，要有法律。政党本身要守法。十三大报告提出党政分开，十五大报告提出依法治国，都是雷声大雨点小。问题在实干，要说到做到。</p><h3 id="对毛泽东继续造神，对党史继续造假"><a href="#对毛泽东继续造神，对党史继续造假" class="headerlink" title="对毛泽东继续造神，对党史继续造假"></a>对毛泽东继续造神，对党史继续造假</h3><p>《21世纪环球报道》：您在1980年10月参与讨论第二个”历史决议”时提出，无产阶级政党执政后，如何监督党的领袖，防止搞独断专行，国际国内都没解决好。您现在怎样看这个问题？</p><p>李锐：1989年后，出现过”毛泽东热”，至今并未衰竭。如有关宣传毛 泽东个人的各种著作，现在不下几百上千种。现在基本上在继续造神；在党史上也还在继续造假，把许多真实情况隐瞒，继续擦胭脂抹粉。例如，有关”文革”的研究就是禁区。许多有关毛和党史及反 右派、大 跃 进直到”文 革”的书籍，只能在境外出版。在我们这个有几千年封建专 制传统的国家，毛 泽东晚年错误的做法，搞个 人 崇 拜，专 制独裁，是不容易彻底清除的。在西方，”个人崇拜” (PERSONALCULT)同”邪教”是一个同义词。”文革”那一套，难道不就是邪教吗？早请示晚汇报，跳忠字舞，摇小红书，真是邪透了。我的看法，马、恩、列、斯、毛、邓，从理论到实践，他们哪些是对，哪些错的，哪些要发展，都必须搞清楚。毛泽东的阴影现在仍然笼罩着我们。我们必须把毛 泽东搞清楚。这样才心中有数，以后就不会再重复错误。总而言之，一个党也好，一个国家也好，必须讲自由民主，讲科学，必须法治，不能人治。党不能搞”一把手”说了算，把个人抬得高高的。要讲信仰，只能信仰科学，信仰真理，不能信仰哪个个人及其学说。信仰属于宗教。马克思的名言是”怀疑一切”。科学与真理的发展是无止境的。</p><p>《21世纪环球报道》：继续反思、总结毛泽东晚年的错误，会不会导致像苏 联全面否定斯 大 林那样的问题？</p><p>李锐：不会，毛泽东的正确东西不会丢。中国的农民不会起来。中国的知 识 分子比较听话，比较照顾大局。现在国际国内环境同过去大大不同了。现在的领导同过去毛的时代也相对不同了。</p><h3 id="中央领导谈宪法是个信号"><a href="#中央领导谈宪法是个信号" class="headerlink" title="中央领导谈宪法是个信号"></a>中央领导谈宪法是个信号</h3><p>《21世纪环球报道》：政治体制改革迟缓，会不会导致洋务运动的后果？</p><p>李锐：也不能说政治体制完全没有改革。比如现在我就可以这样自由讲话。人大、政协还有不同的声音。估计各级领导到中央也不是铁板一块，也有不同的声音。有不同的声音才能有进步。过去毛泽东一个人说了算，刘少奇、周恩来都难有发言权。刘少奇在1962年七千人大会上有不同的声音，就导致了那样悲惨的结局。这种历史当然不会重演了。因为时代不同了，现在各级领导干部都是”干部四化”以后上来的，尽管素质、水平参差不齐，但都是改革开放新环境中成长起来的。目前最大的任务是经济发展。现在私有经济的产值已经占全国一多半了。不过，根本问题是要解决党大于法，人治大于法治。不搞民主 化、法治化，政治体制不改革，人治的问题不变，经济上也会有问题。腐败是不得了的，每年以千为基数的县以上的干部犯罪，省部级干部犯罪，已经上百了。这真不得了。问题就是领导的权力太大，党和国家没有很好的监督机制，尤其舆论一律，没有舆论监督。现在提出政治文明，值得关注。政治文明首先要遵守宪法，要有言论自由。中央领导谈宪法，是个信号。《炎黄春秋》没有挨批评，反受到称赞，希望这也是一个信号，言论有了点自由的信号。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[清理偏见]]></title>
      <url>http://fengchao.github.io/2010/01/19/Prejudice/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>“许多人在重组自己的偏见时，还以为自己是在思考。”</p><p>当我看到这句话的时候，才知道上篇博客到底想说什么：原来脑子中的许多偏见，正在遭受毁灭性的打击：</p><ul><li><p>手机发短信打电话就够了，不是手机丢了我还在那个圈圈里面转悠呢；</p></li><li><p>KDE 花哨不实用，慢， XFCE 多好用；<br>原来一直有一个问题没搞明白，为什么那么多人用 KDE。有那么多人用，必然有它的好处。但是这个好处，我在 Red Hat 里面没看出来，后来装 Kubuntu 也没觉出好。唯一的感觉就是慢，就见一个图标在那里蹦。实际上，是机器太破了，所以只能用 XFCE。</p><p>自从买了新电脑，下定决心在 Gentoo 里装 KDE，终于感受到了 KDE 的优点。内存大了，也不慢了。好多程序用了也觉得比 Gnome 下的方便。额外的收获是 Planet KDE 里面文章质量相当高，鲜果可以忙活一阵了。有空也准备研究下 QT。</p></li><li><p>追涨杀跌；<br>股市没什么规则可言的，不然电脑都能当股神了。但是几个月下来，总觉得哪里出了问题。可能是在入市之前受西方的炒股策略影响较大。一般思路就是不碰暴涨的 股票，因为如果市场是有效的，那么系统性的价格偏差肯定会被迅速补回并导致超调。但是中国的股市不一样，本来市场的价值发现功能就比较低，又连带涨跌停限 制，所以经常出现强者恒强，弱者恒若的现象。所以不应该害怕持股，也不用像躲瘟疫一样躲热门。</p></li></ul><p>岁数也不小了，在人生的路上，逐步积累了一些偏见，有些偏见甚至变成了偏执。对 AB 血的人，应该更加明显吧……</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[产品创造需求]]></title>
      <url>http://fengchao.github.io/2010/01/05/Products-and-demands/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>传统的营销，通常强调满足客户的需求。客户需要什么，就提供什么。但是最近的几次购买行为发现，有些时候，需求是会变的。</p><p>比如说手机，在老 V3 丢之前，手机在我眼中就三个功能：电话、短信和手表。我都不玩游戏，更想不明白为什么那么多人用那么小的屏幕上网。买了个新手机之后，情况立即改变，每天早上做黑车，先打开证券看要闻。出去找不到路，翻开地图搜搜。现在开始后悔应该买个更好点的了。所以人的需求是变的，是产品带来功能，功能引起需求。</p><p>笔记本也是差不多吧，没有的时候总是想，简单的台式机就行了。但是真的携带起来，还是会有许多便利。</p><p>有了汽油，才会有对车的需求；有了电，才会有对电器产品的需求。从这个角度来说，历史，不是由需求推动的，而是由创新的功能推动的。这个逻辑很诡异。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[加入本本一族]]></title>
      <url>http://fengchao.github.io/2010/01/02/First-Notebook/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>元旦第一天，跑到徐家汇买电脑，最近事情比较多，根本是无准备之仗，所以一连逛了好几个小时，最后买了 HP DV-2。</p><p>候选者其实三个：Intel 平台的 HP DM-1、AMD 平台的 HP DV-2 和 VIA 平台的联想 S12。没有选 S12，因为害怕以后驱动跟不上 Kernel 和 XServer，用不了 Gentoo。选 DV-2 而不是 DM-1，主要是多了个独立显卡，屏幕也大了一点。所以准备从 AMD 平台转移到 Intel 的愿望并没有实现。反正对 ATI 的显卡驱动还算熟悉，而 AMD 也正在逐步公开各种硬件资料，所以开源驱动不用太担心。</p><p>本本原来预装了 Win7，用了用感觉确实不错，不像当年的 Vista，用了 5 分钟之后就再也不想碰。从现在开始，要花不少的时间逐步将其转移到 Gentoo。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[摘鲜果]]></title>
      <url>http://fengchao.github.io/2009/12/30/Xianguo-RSS/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>常用空间的人大概已经注意到了，在空间主页订阅 RSS 的下面，又增加了一个订阅到鲜果。抓虾、鲜果，很早以前都用过，但是因为没有 Google Reader 好用，注册了帐号就没管过。现在又去看了下，发现好用很多。快捷键也基本完全照抄了 Google Reader，订阅导入也非常方便，经过几天的测试，终于决定告别 Google Reader，转用鲜果了。</p><p>这是个信息的社会，人们担心的已经不是找不到消息，而是消息太多，太杂而根本没有办法整理关注。所以面对信息爆炸的地球，我们只能选择性的关注那么一小块。在所谓的 Web1.0 时代，关注的方法就是在收藏夹里面收藏关注的网站，然后隔一段时间就回去瞅瞅，看看有没有更新。这种方式，对于我这种健忘之人，是完全行不通的。通常是收藏了一个好网站之后，就再也没有回去过，再回首，站点已经关闭或者被墙掉。而有了 RSS，就再也没有这个烦恼了。</p><p>(Ctrl + V)<br>RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是目前使用最广泛的 XML 应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其他站点调用。如果从RSS阅读者的角度来看，完全不必考虑它到底是什么意思，只要简单地理解为一种方便的信息获取工具就可以了。RSS获取信息的模式与加入邮件列表（如电子杂志和新闻邮件）获取信息有一定的相似之处，也就是可以不必登录各个提供信息的网站而通过客户端浏览方式（称为“RSS阅读器”）或者在线RSS阅读方式这些内容。<br>(End Ctrl + V)</p><p>从某种意义上说， RSS 才是 Web2.0 的唯一特征。它改变了网络信息的获取方式，有过去的查看模式，变为推送模式。只要订阅了相应的 RSS，新的内容就会自动被推送到决定关注这些内容的所有用户手中。也许许多人对这个词比较陌生，但是提到他们的应用，肯定不会陌生。</p><ol><li>QQ，MSN 上会用一个炫炫的小图标显示对应朋友的空间更新，用的就是 RSS。实际上对我这种从来不用微软 MSN 的人来说，从一开始就是通过 RSS 订阅好友的更新。</li><li>开心网上的好友动态是 RSS 信息的聚合。</li><li>百度里面好友文章更新、动态， RSS</li></ol><p>自从发现了RSS， 它迅速成为我获取网页消息的唯一来源。对于没有提供 RSS，而特别想看的内容，就用 Firefox 的扩展 Update Scanner。从最早的英语学习，到后来的《经济学人》、货币战争，到后来的大量 Linux 站点，到现在的新浪财经。Google Reader 记录了曾经辉煌的阅读量。</p><p>忘记了没有 RSS 的世界是什么样子，也许是安静而祥和的吧。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2009-投资盘点]]></title>
      <url>http://fengchao.github.io/2009/12/30/2009-Stock-summary/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>我是 2008 年 3 月离开的学校。当时手里有点闲钱，又没到公司报道，于是就关注起了股市。</p><p>第一次看盘，印象很不好，大概是天天跌， %3 、%3 的跌。以至于后来看第一财经的股评员，感觉他们脸都是绿的，声音都是颤抖的。那是也没经验，看到市场恐慌，同时看到一句话：”别人贪婪我恐惧，别人恐惧我贪婪“。于是把身上的钱都转到招行的帐户，买了基金。时间很好，没过两天，印花税下调，大盘几乎涨停。这次成功的抄底，给了我自信，更给了我自负和一丝狂妄。这种自负，害我不浅。</p><p>后来工作了，就没有管了。开始的钱也不多，每月定投一点基金。大盘在冲高之后继续下跌，一直跌到 1600。后来开心网盛行，模拟完了会，第一次买了中国平安，后来是山东黄金。基本上每次都是逆势大涨。这一模拟成功经历，加重了我的自负，最终把我推进套牢深渊。</p><p>今年上半年，命犯桃花，光顾着培养程序员，所以虽然知道行情大涨，只是提高了每月的定投量。从 1000 到 2000 到 4000。直到有一天，明显觉得大盘要到顶了。于是迅速减仓。直到 2009 年 8 月 5 日，清空所有基金。从 3000 点走了一个来回，30% 的受益还是不错的。充分证明了基金定投是一个省心的投资方式。看看帐户里的盈利，心理美滋滋的，阳光灿烂，一切都很美好。</p><p>由于先前的成功带来的自负，我开始飘飘然，在知道大盘到顶的时候，并没有落袋为安。而是妄想着杀入股市，动荡的市场中寻找机会。于是在清空基金的当天，办理了招行的管存，正式告别基民，成为股民。杯具开始了，套牢、解套、再套牢的生活，开始了。</p><p>第一次买股，印象很不好。冲着药品目录修改而选择了美罗药业。买了之后就被套，大盘天天跌，3%、3% 的跌。看平安跌不少了，以为到底了，就买了平安。还是 3%、3% 的跌。以至于后来照镜子，感觉脸都是绿的，声音都颤抖了。终于，二股双双跌到 15% 原定止损位。开始是没经验，也是被连跌吓傻了，而机构看空到 2200 的声音也是此起彼伏。其实是一个恐惧的时候。而我，也是恐惧的一份子。于是忍痛割肉。割肉完了，平安还是跌了不少，而美罗药业就开始涨停，连续涨停。第一支股票彻底击碎了我积攒起来的自负。幸亏没有自卑。</p><p>在一波小反弹中买了不少股票，康缘药业、光明乳业、招商地产。开始时候还赚了点，但是大盘上攻 3000 无力，开始反手下跌，暴跌。于是又悉数套牢。然后有一天，市场明显恐惧了，我认为抄底的时候到了，于是全仓杀入，重仓了招商地产。虽然是在 -3% 时候买入，但是恐慌显然蔓延了。于是收盘时候，录得惟一一次跌停。全仓杀入，被跌停套牢。基本上已经被完全击垮，对自己的投资能力产生了深刻的怀疑。和朋友一起跑到酒吧挥霍了一把，和账面上的绿色数字相比，那酒的价格可以忽略不计。</p><p>幸亏第二天股市反手暴涨，否则，我真有可能告别股市。两天时间，暴涨暴跌，这，就是 A 股。康缘药业赚了点小钱，抛了，抛早了。光明没赚到钱就抛了，抛早了。招商地产抛早了，招商银行抛早了。泸州老窖抛早了。每每，守候了一两个星期的股票，涨了点我就卖了。而卖完就暴涨。跌的时候被套，涨的时候拿不住，这就是 A 股股民。</p><p>转换过风格，追过新大陆、美尔雅、海虹控股这种概念股。说实话买到心里不踏实。看它跌了，我就没底，觉得可能这辈子都不会再涨回来。所以我买股票，喜欢追求确定性。买招商地产，因为它 28 增发。买招商银行，因为配股。买康缘药业，因为医改。买泸州老窖，因为酒涨价。买光明乳业，因为进口奶粉涨价。买远洋，因为出口复苏。有了这种确定性，即使开始被套，也不会太担心，因为知道一定会涨上来。</p><p>最近，一直重仓银行，因为估值太低了。尽管利空很多，但是再融资，短期利空，长期是利好。而且这么多东西都在涨价，加息就是确定性机会。而靠利差吃饭的中国银行，加息就是利好。</p><p>已经忘记了没有股票的生活是什么样子，大概是安静而祥和的吧。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[洁癖]]></title>
      <url>http://fengchao.github.io/2009/12/21/Strive-for-Clean/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>处女座到人给人最大到感受大概就是洁癖。扭头看看看自己到窝，却完全没有处女座到风范。其实，对于许多处女座来说，这种洁癖是精神上的。对于我来说，代码就是精神的一部分。</p><p>自从接手小卡的代码之后，就开始了清扫过程。从最开始的注释，到变量名，到函数，到结构成员，到整个调用流程都进行了修改。随着版本号到增长，渐渐得已经没有哪块代码没有被修理过。虽然仍然有许多地方要改，而且剩下了许多难啃到硬骨头。至少在我眼里，代码已经干净了许多。</p><p>改了那么多，是因为我的水平比小卡高很多么？否也。罗马不是一天建成的，代码也不是一天写成的。软件的功能，是一块一块摞上去的。软件的功能，是一步一步提出来的。上有老板的期限，下有测试的Bug。天天加班敢进度，谁还有心思关心代码质量？ 基本上新增的功能都会采取尽量不影响原有功能到前提下增加。这种方式往往使代码越走越乱，几乎所有到软件都会经历这一过程。</p><p>时间、功能和代码质量三者无法同时存在。开源软件一般宁可牺牲时间，也一定保证代码质量。而公司里的软件，往往牺牲代码质量而保证工程进度。因为老板只能看到工作有没有完成，而很少关心代码质量。殊不知，当前到代码质量，将会大大影响未来到进度。当前的工作靠补丁的方式完成，未来再增加功能会更加困难。直到有一天，即使增加一个很小的功能，也会需要很多时间。即使修改很小的一部分，也会影响整个程序到运行 —— 程序混沌了。</p><p>所以程序需要不断的重构，而且这种重构必须由不同的人来完成。原因：人会审美疲劳。也许刚开始看着代码很丑，不断想方设法去修改。渐渐得，已经从潜意识里面知道那些怪异变量名的作用，理清了混乱到调用方式。特别是自己的代码已经成为混乱一部分的时候。这，正是结对编程，交叉审阅的意义所在。并不是编程水平不够，而是因为人的心理有缺陷。</p><p>拿我的窝来说，所有的东西，都是我放的，等想收拾的时候就想，这东西不放这还能放哪？ 所以屋子再乱，我总能够找到指甲剪，直到有一天，小倩把它从板凳放到桌子上。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《守望者》]]></title>
      <url>http://fengchao.github.io/2009/12/06/Watchmen/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>人们对《守望者》的评价，通常会走两种极端：要么觉得特别好，要么觉得特别烂。</p><p>这是一部漫画改编的电影，而原著属于非常非常硬的故事。基于冷战时期的历史，又进行了大量的改编：美国赢得越战、尼克松杀死记者获得连任并成为独裁者。不太了解原著的人，很难仅仅通过影片就明白故事的来龙去脉。对于许多人来说，看到的仅仅是血腥、暴力与色情。影片讲述一批英雄的故事。但是和一般的英雄电影不同，没有讲一个好人历尽艰险，战胜了某某大坏蛋。正如名字蕴涵的意味，几乎每个人物都带有或多或少的悲情。悲剧能让人思考更多的东西，但是许多人去电影院看电影，不是为了在那里绞尽脑汁得思考。</p><p>所以不同的观众给出截然相反的评价，就不足为奇了。看过原著的人，大都会给出很高的评价。很少有一部改编电影可以这么忠于原著，忠实到不惜牺牲电影的可观赏性（对于没有原著背景的观众）。而为了图个乐的观众，却被迫引入对以暴制暴的评判，对牺牲一部分(1500万人)的生命，而换取整个人类和平进行选择的困境。这是一种挣扎，这种挣扎深刻得体现在人物的身上，贯穿影片的始末。有多少人会喜欢看一部把角色的挣扎用很唯美又残酷的方式表现出来的电影呢？</p><p>这个故事之所以这么沉重，就在于生活在冷战中的作者，希望寻找一个沉重问题的可行解：核军备竞赛中的世界，怎样避免瞬间灭亡。电影中给出了一个解，那就是制造一个全人类共同的敌人，毁灭世界上最繁华的都市，1500万人瞬间灰飞烟灭。面对共同的威胁，人类终于放弃核武器竞赛，终于团结起来。这一解决问题的方式，让人那么不理解，以至于罗夏最终用死亡进行无声的抗议。幸亏真实的历史比较幸运，苏联以一种戏剧化的方式解体。而冷战本身，就像幼稚的小孩演绎的一场闹剧。</p><p>冷战虽然结束了，但是人类却没有根本上原理核威胁。从朝鲜到伊朗，都在给未来增加不确定性。看似稳定的系统其实非常不稳定，一个细小的突发事件，就有可能引发不可停止的连锁反应。除了核威胁，世界上还有许多看似无解的难题：能源危机、气候变化、致命病毒…… 所有这些问题，都需要全世界的努力。就像哥本哈根一样，也许过不了多久，我们就会发现，那些反对减排的人，那些只顾见前利益而毫不考虑未来的人，就像跳梁小丑一样，正在演绎着一场闹剧。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2009-年终盘点]]></title>
      <url>http://fengchao.github.io/2009/12/03/2009-Job-summary/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>去年元旦的时候，接手了 FreeBSD 网卡驱动问题。年尾的时候，基本结掉了 DOS 下的 BIOS 烧录程序。至此马马虎虎熟悉了所有现行主流的操作系统。</p><p>我是以 Linux 背景程序员被召入公司的，开始的时候倒也都是做 Linux 显卡驱动之类的测试。后来，作为技术支持部门，本着客户碰到什么系统，就研究什么系统的宗旨。开始在各个操作系统上游荡。</p><p>某几天，看过几天集群，后来发现客户报错了部门。</p><p>用 VB 写过 Windows 下的看门狗程序，貌似卖了点钱，反正没我份。</p><p>WinXP 下的嵌入式开发库及演示程序，这是我第一次写真正称得上复杂的程序，时间紧、任务重，全组人几乎都上来了。架构其实是我定的，基本和看门狗的差不多。从应用程序到 DLL 到底层的 sys. 原定的是不同的功能分为不同的 sys 实现，后来上头定调全部合成一个。说实话，架构很不好，因为所有板子的支持都在一起，所以到处是 switch 代码。对于追求完美的我来说，一直耿耿于怀。最后终于学到回调函数的好处，在后来的 LCD Tool 和 VFlash 程序中，几乎看不到 switch 了。这个项目在即将完工的时候被别的部门抢走，当时就想，这么一个破程序，还有人抢。而后话就是，若干个月之后，拿到了成品代码。这个时候，架构发生了改变，那个巨大而丑陋的 sys, 根据功能和板子被分为了不同的 sys …</p><p>后来做过许多 Linux 下的测试，显示驱动，视频加速之类的。总体来说，技术含量不高，虽然有时候也瞅瞅驱动的代码。但是那些代码的风格实在是不合我胃口，后来就不了了之。好在我是个热爱开源的好公民，只要是开源的东西，来者不拒，何况是拿工资的。</p><p>后来就是 FreeBSD 了。实际上开始的时候是研究 FreeNAS 的，就是所谓的专门负责BT、电驴下载的下载机。那个时候还没有严厉打击 BT 下载，现在估计这种机器的销售一落千丈。简单的功能熟悉之后，深入了解了以下硬件加密驱动的使用。然后就是发现 FreeBSD 7.0 的千兆网卡问题。前前后后大概花了 2 个多月时间，最后是发现了出问题的寄存器，我还没有来得及联系维护者，他们的解法已经出来了。所以从公司的角度来说，我基本上是做了无用功。从我的角度来说，基本摸透了网络协议的整个代码堆栈，阅读了不少内核代码。同时，在不断跟随 Current 的过程中，发现 Port 的好处。于是删掉了家里的 Ubuntu ，改用 Gentoo 了。</p><p>再往后，Back Port 了Linux ATA 驱动，没记错的话应该是把 2.6.27 的驱动改到 2.6.16 2.6.18 上面。Linux 内核里面有几块代码乱而复杂，TTY 、声音和 IDE/ATA。 TTY 是最久远而尘封的代码，依赖它的程序太多，以至于 Alan Cox 这种亮出名字震倒一片的超级大牛都没法全身而退。声音代码里面不同的架构层出不穷，最近升级过系统的，很多都会碰到声音没了的问题。 IDE 代码乱在同时存在两种不同的架构可以支持它们。而具体使用哪个部分，又发行版自行决定。而自行决定的结果，就是完全的混乱，相同的内核版本，在不同的发行版上被打上不同的补丁，有的用 IDE，有的用 ATA。而我的任务，就是把当前发布的 ATA 架构驱动改回老内核的 IDE 上面去。反正是唯一一次大规模修改内核代码。而这种 Back Port 的方式倒是很像智力题，在两块相似却不同的代码进行关联，并将需要的部分移动到另一块。</p><p>然后就是 LCD Tool，一个修改 LCD Timing 和 Clock 等属性的简单工具。我用 Python TK 写界面，Randy 用 C 写的底层库。骨子里还是很非常喜欢 Python 的，因为它的清晰和整洁。实际的界面就比较难看了，我是一个没有什么艺术细胞的人，追求实用而不是美观。总体还是不错的，由于吸取了以前的教训，架构上面好很多，增加板子的支持也就非常容易。但是实际还是缺一个东西，就是远程控制的支持。</p><p>再后来看了阵无线，实际只是学习了。稍微了解了一下 Linux Staging 树里面的 VT6656 和 VT6655 代码。本来想深入进去找机会该代码的，后来一直被别的事情给占掉。目前 Pending。</p><p>然后就是小卡走了，所以接手了 VFlash，DOS 环境。对许多人开说总得来说，DOS 是早该消亡的古董。但是如果 BIOS 烧坏了，即使有 Boot Block，大概也只能进 DOS，所以主板厂商还都会提供 DOS 下的烧录程序。对代码的演进还是比较得意的。可以说发挥了我全部的编程水平。台北找了个人接手，因为他们有我们这里没有的板子。</p><p>（完）<br>收藏于 2009-12-3</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[世界还是原来的世界]]></title>
      <url>http://fengchao.github.io/2009/11/23/No-Change/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>金融危机确立已经一年多了，和开始的恐慌不同，世界一下子乐观起来：三十年代的大萧条没有发生。</p><p>人的弱点就是好了伤疤忘了疼。随着股市回升，房地产回升，华尔街的高管再次心安理得得索要高额年薪；加强金融监管已经渐渐被人遗忘，对冲基金又开始四处出击；在“强势美元符合美国利益”这个空洞口号的掩护之下，美元不断的贬值，黄金扶摇直上；美国储蓄率低导致的不平衡，罪名却又被无数经济“砖家”扣在人民币的头上，大量热钱开始再次涌入中国，准备再赌人民币的升值。一切都和两年前那么的相似。</p><p>世界并没有好好利用这个机会，对已经问题重重的经济体系进行彻底改革。危机的原因是高杠杆导致的泡沫，消除危机的方式却是烂印钞票去填补这个泡沫，于是产生了更大的泡沫。美元成了套利交易货币，世界货币成了套利交易的水龙头，这是一个多么恐怖的事情。泛滥的美元正在疯狂涌入发展中国家市场，金砖四国中，除了中国之外，币值都出现了暴涨，巴西的币值在今年已经升值了 35%。而中国在美国、欧洲的联合压力之下，到底能撑多久，还是个未知数。这么多的钱，流到哪里，哪里就会有泡沫。股市、楼市开始逐步脱离实体经济的基本面而疯狂起来。通胀已经是无可逃避的未来，而要想管理通胀预期，只能管理美联储的印钞机。</p><p>而最恐怖的事情并不是通货膨胀，而是通胀之后的通货紧缩。当美联储为了控制通胀而加息的时候，资金的流向必然发生逆转，这些在泡沫的产生中大赚一笔的热钱开始撤退的时候，泡沫必然破灭。在这一前景之下，美联储将会处于一个两难的境地：不加息，通胀不可抑制；加息，美国作为世界上最大的债务人，必然大受其害。</p><p>这个问题有解么？ 至少现在看不出来，还是用存在来证明合理吧。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我已不是我]]></title>
      <url>http://fengchao.github.io/2009/11/20/I-am-not-me/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>身份证重号了，跑到新华派出所去改。除了还有拍照、办理临时身份证一坨事情要办。去年落户的时候都够烦的，我问工作人员：“上次不是照过了。“ 后面的回答震了我一下：”号码一改，原来你就不存在了，等于一个新的人。“</p><p>不是第一次去新华派出所了，和上次相比，变了一个人只是稍微有一点点夸张。</p><p>回去的时候路过学校，已经没有什么心情享受学校的风景了，拿着个手机软件盯着股市看。远离学校之后，变得越来越浮躁。静下心来，看看书，想想事情的时间越来越少了。跑到慧谷的三楼，发现昂立书店居然没了。感慨了一下，回学校的理由又少了一个。</p><p>最近的时间是越来越少了，好多邮件都没时间看。技术上的进步仿佛遇到了瓶颈，一种投入很多时间也会石沉大海的感觉。技术这条路，我肯定走不了一辈子，但是哪里会是终点呢？睡觉的时间也是越来越少，不知不觉就 12 点了。睡觉睡到自然醒果然是一个奢侈的事情。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Olny srmat poelpe can raed tihs]]></title>
      <url>http://fengchao.github.io/2009/10/09/Olny-srmat-poelpe-can-raed-tihs-1/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>“I cdnuolt blveiee taht I cluod aulaclty uesdnatnrd waht I was rdanieg. The phaonmneal pweor of the hmuan mnid, aoccdrnig to a rscheearch at Cmabrigde Uinervtisy, it deosn’t mttaer in waht oredr the ltteers in a wrod are, the olny iprmoatnt tihng is taht the frist and lsat ltteer be in the rghit pclae. The rset can be a taotl mses and you can sitll raed it wouthit a porbelm. Tihs is bcuseae the huamn mnid deos not raed ervey lteter by istlef, but the wrod as a wlohe. Amzanig huh? yaeh and I awlyas tghuhot slpeling was ipmorantt! if you can raed tihs psas it on!!</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Olny srmat poelpe can raed tihs]]></title>
      <url>http://fengchao.github.io/2009/10/09/Olny-srmat-poelpe-can-raed-tihs/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>“I cdnuolt blveiee taht I cluod aulaclty uesdnatnrd waht I was rdanieg. The phaonmneal pweor of the hmuan mnid, aoccdrnig to a rscheearch at Cmabrigde Uinervtisy, it deosn’t mttaer in waht oredr the ltteers in a wrod are, the olny iprmoatnt tihng is taht the frist and lsat ltteer be in the rghit pclae. The rset can be a taotl mses and you can sitll raed it wouthit a porbelm. Tihs is bcuseae the huamn mnid deos not raed ervey lteter by istlef, but the wrod as a wlohe. Amzanig huh? yaeh and I awlyas tghuhot slpeling was ipmorantt! if you can raed tihs psas it on!!</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[拷问软件专利]]></title>
      <url>http://fengchao.github.io/2009/10/09/No-Software-patent/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>这个世界有两种东西：有意义的；无意义的。人们去追求的、想方设法去获取、去创造的通常是有意义的 —— 至少当时是如此。而且获得之后，有事没事也会不断的拷问：这个东西真的有意义么？今天要拷问的，就是软件专利。</p><p>“专利是指一项发明创造,即发明、实用新型或外观设计向国务院专利行政部门提出专利申请，经依法审查合格后，向专利申请人授予的在规定的时间内对该项发明创造享有的专有权”。</p><p>专利可以说是人类历史上最伟大的发明之一。社会由个人构成，有些时候，人群缺乏方向，一团散沙，社会停滞不前；一旦有了方向，哪怕起初看起来那么的微小，由无数的人实行，力量累积起来，绝对的横扫千军、摧枯拉朽。专利制度就是提供了这一推力，给出了一个方向，极大的激发了人们的创新热情。当发明人具有了这种得到保证的专有权，就可以放心大胆的把自己的发明公之于众，不用藏着掖着，不用传男不传女，传内不传外。从某种意义上说，中国的科技水平落后于西方，源于“士农工商“等级的划分，但是与专利制度的缺乏也有着直接的关系。现代专利制度形成与 17 世纪初，恰好在工业革命之前，这种时间上的先后，即使构不成绝对因果，也绝不是一个巧合。</p><p>但是东西再好，也有其界限，比如数学公式、物理定律就是无法获取专利的。假如数学公式能够获得专利，那么只有交了钱或者获得许可的人才能使用这个公式，才能使用高级的逻辑推理，这本身就是很荒谬的一件事情。更重要的是，新的数学进步，总是要建立在已有定律定理的基础之上，有了专利、没有许可的数学家就无法完善、发展的已有成就。所以专利制度将会阻碍数学、物理的发展。所以类似数学、物理公式这种抽象的概念、方法是无法获得专利保护的。</p><p>要问专利制度是否能够扩展到软件，就要问：”软件专利能否促进软件领域的创新“。答案恐怕是肯定的。软件专利不但没能促进创新，反而对阻碍了软件的进步。软件像数学公式定理一样，是逻辑想法的抽象表述。通过思想的交流而促进创新远早于软件而存在，”抽象概念“”自然规律“”和“算法”不应该获取专利是普遍准则。软件不正是“数据结构+算法”么。软件的进步，也是建立在先前软件的基础之上。自由软件、开源软件的成功实例表明：分享软件源代码、分享软件所有权是成功的，通过让所有的人都能够基于现有成果写出新代码，极大的促进了软件的发展。</p><p>所以说，软件专利没有存在的意义，它应该走向灭亡。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[炒股小结]]></title>
      <url>http://fengchao.github.io/2009/10/09/Unpredictable-stock-market/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>大概在上一次股市疯狂的时候，有一个诺贝尔经济学获得者到交大演讲，名字已经忘了，观点还算鲜明：经济行为是人的行为，经济活动中的人会对经济本身产生影响。具体到股市：没有什么理论可以正确的预测它。</p><p>论证方法是反证法：假如这样一个预测理论存在，人们就会用这一理论指导自己的买卖实践。如果这一理论预测 1000 点是最低点，那么所有人都想提前那么一点点埋伏下来，于是在跌到 1001 的时候抄底买入，结果就是跌不到1001，于是大家 1002 买入，照这样反推的结论就是：除非这个理论处于保密状态，否测，即使当时预测准确，一旦大多数人开始使用它，于是理论失效。</p><p>理是这个理，但是只有只身杀入股市，才能领悟这一真理的价值。入市至今，最大的感慨莫过于：股市就喜欢跟人开玩笑。 3400 点的时候，人人都喊至少4000 ，好多人都想：等涨到4000，我就落袋为安。结果大盘挣扎一下之后，掉头向下，毫无抵抗跌破3000，2900，2800 然后大家开始看空，预测要跌破 2200 的大有人在。大盘今天跌4%，无数个股跌停，明天又突然上涨4%，无一个股下跌。大幅的震荡之中，看多看空都不好使了，横尸遍野，无限悲观中，长阳拉起；喜气洋洋，乐观向上时，奋力跳水。如此反复，搞得我早已经见惯不惯。十一之前，舆论一片空，当时就想，股市也许又要开玩笑了吧。</p><p>入市时间不长，经历却也不少了。</p><p>割肉：有卖完之后连拉3个涨停的美罗药业，回头再看K图，几乎是在最低点割肉。原因很简单：机械的遵守止损法则。第一次买股票，股是好股，就是买入太早。连续下跌之后很快浮亏超过15%。那个时候其实是有钱补仓的，但是原来看的好多观点，都是耻笑这种补仓拉低亏损比例的行为。于是很坚决的在止损点割肉，于是交出了股海的第一笔学费。学费还是没有白交的，随后的操作里面，几乎都是通过补仓赚钱。以至于在想，难道选股太超前了，是不是需要人为增加时滞。</p><p>踏浪：中国远洋几乎是一个跌到底的股票，但是不缺乏振荡。算下来，已经四进四出了。每次的钱倒是不多，500股的样子。虽然每次赚钱都不算多，一次刮点，算下来基本补齐了美罗药业的学费。好歹也算是碰到了一个涨停。从来都没有后悔买少，船小好调头，心态是不一样的。心态好了，才容易踩准节奏。这一点在上海建工身上得到了很好的验证。</p><p>贪心：第一次买上海建工，成本15块。有一次大盘很弱的样子，建工很猛，小赚也是赚。当时其实已经点进卖出了，价格都设好了，犹豫了一下，没有卖。当时是贪心了，因为想的是如果再涨1%，也能挣不少钱。1%没涨到，套牢了好久。幸亏后来补了补，没有和美罗药业一样割肉。捞了个涨停卖出，小赚一笔。</p><p>解套：招商地产是我的伤心地，基本上买了就套牢，挨过跌停，深度套牢等着解套。解套再买，再套牢。其实对这个股票基本不熟，只看到28块增发而已。今天大涨，准备解套就从此远离此地。</p><p>股市是测不准的，但是练练级，涨涨经验应该会好些吧:-)。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[无题]]></title>
      <url>http://fengchao.github.io/2009/09/27/No-title/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>忽然发现，空间开始长草了。以前的时候什么都写，到如今：技术文章另立门户；流水账转到了谷歌日历。自从抛了基金杀入股市，就再也没有写过什么经济。</p><p>因为自己也很清楚，身陷其中，观点就不客观了。以前天天到水源上鼓吹黄金，鼓动人买贺岁金条，甚至在开心网的模拟炒股里面还在山东黄金上很赚一笔。但是一旦钱成了自己的，在这一波金价暴涨中，却成了无可奈何的看客。有时候不禁怀疑自己，看多黄金的底气到底有多足。</p><p>也许，这就是人性的一大弱点吧。太多的时候，只有走了很远，转身回望的时候，才发现哪里对了，哪里错了。拼命抓住一些东西的同时，错过了另外的东西，真的选对了么？ 我不知道，所以敲键盘的时候，总是心存畏惧。总是想写正确的事情，不希望幡然悔悟的时候，再拐过头来篡改历史。</p><p>曾经跑到酒吧喝得烂醉如泥，身份证银行卡全丢在小黑车上。第二天早上再一次吐酸水的时候，我知道，这种放纵不是我想要的。也许，只有这么放纵过，体会过，才会知道。我的变化是如此明显，以至于小喜子在某次聚会之后郑重的警告过我。渐渐的认识到对未来的生活，自己到底想要什么。和学生时的我相比，这也许就是最大的进步。</p><p>股市休市的时候，时间真得多了许多，所以才有闲心码这么堆字吧。到底该不该退出来，真是一个问题啊。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《嫌疑人Ｘ的献身》]]></title>
      <url>http://fengchao.github.io/2009/09/18/Suspect-X/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>内容简介：百年一遇的数学天才石神，每天唯一的乐趣便是去一家便当店买午餐，只为看一眼便当店做事的邻居靖子。靖子带着独生女美里逃离粗暴的前夫，两人相依为命地生活在大都市的一角。某天靖子前夫找上门来，两人争执不下之际，靖子失手杀死了对方。此时，石神出现在茫然失措的母女面前，提出由他来料理善后。石神设计了一个匪夷所思的局，令以草薙为首的调查阵营始终找不到突破的可能性，只能在外围敲敲打打，根本无法触碰案件的核心。</p><p>最开始看这本书，仅仅是为了泡妞的时候有点谈资。开始看这本书，感觉平淡无奇。一直到最后，发现石神为了迷惑调查，居然杀了另外一个人，从一开始就把自己至于死地，没有任何退路。那种感觉，就像在平地走着走着，突然看到一个高耸入云的高山。这根本不是一个推理小说，在推理的伪装之下，讲述了一种爱，一开始就绝望的爱。</p><p>石神活在自己的世界里，是孤独的偏执的天才。沉醉在数学里面，追求绝对的逻辑与理性。在被现实打败，失去人生意义的时候，靖子给了他活下去的理由。所以与其说他在拯救母子二人，不如说他在保卫自己的意义。基于这一点，他做到一切都是合理的。但是仅杀死无辜的人这件事，完全越过了底线。杀死无辜的人，要比靖子杀死不断纠缠她的前夫严重得多。爱纵然伟大，但绝不能在爱的名义下，为所欲为。不管爱有多深，都有着不可逾越的底线。爱一旦超越了底线，就显露出病态与可怕。</p><p>从一开始，这种爱就注定没有结局。理性的石神似乎早就明白了这一点，虽然故事的进展平淡而缓慢，但是字里行间，却不断的透露出无奈。石神的设计中包含了许多许多细节，这些细节尽显完美，却指向了一个凄惨的结局。在这个结局里面靖子可能很幸福，但是石神自己却早已不存在了。石神一开始就算错了一点，任何一个正常的人，只要知道了这种牺牲，就不可能独享幸福。</p><p>靖子差点成为那个不正常的幸福女人。石神的计划还没结束，警方还在调查，她就开始与另外的男人约会。说白了，她就是一个只知道获取，只知道享受奢华的女人。一想到可以与一个有钱男人结婚，就两眼放光，沉浸在美好生活的幻想之中。在她的心里，根本没有考虑过将石神涉入自己的杀人事件，将会对这个本来与自己无关的人产生什么影响。在杀了人之后，仿佛自己什么责任都没有。石神为啥要冒死帮她，她根本不去想，或者说，从潜意识里面，她不愿意想，不愿意用什么报恩。从这点上说，这个女人根本不值得拯救。更不值得用另外一个无辜的人去拯救。</p><p>世界上没有无用的齿轮，也只有齿轮自己才能决定自己的用途。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[转]别让自己的心太累]]></title>
      <url>http://fengchao.github.io/2009/09/06/Do-not-be-too-streeful/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>好久没转过贴了，今天是个例外，有些话真的触动了心。</p><p>如果你不给自己烦恼，别人也永远不可能给你烦恼。因为你自己的内心，你放不下。</p><p>生活中有太多的无奈，有太多的不如意每当有不顺心的事时我们就会抱怨自己是多么的不幸自己是多么的可怜，有时间在一边抱怨不如踏下心来好好想想自己都干了些什么呢。心的负荷沉重。有多少往事不堪回首？有多少记忆没留伤痕？人生不是一杯酒，醉了的，不是好汉，没醉的，不是英雄。所以你我只能半醉半醒，何时能当上那超凡脱俗的大仙？</p><p>人之所以痛苦，在于追求错误的东西。每一种创伤，都是一种成熟。</p><p>心的负荷沉重。寻寻觅觅，何时让生命本色回归自然？何时在精神泥潭突围？何时能锁定新的人生座标？何时让满是皱纹的心灵舒展？也许，亲情友情恋情都得伴随心累的历程？也许，所谓的傲骨与傲气，都得付出心累的代价？也许人的灵魂在某个层面上看，真的是无可救药?也许，什么也许也不要去想，方可减轻那生命难以承受之重。</p><p>当你快乐时你要想这快乐不是永恒的。<br>当你痛苦时你要想这痛苦也不是永恒的。</p><p>岁月蹉跎，时光荏苒，历史的长河流沙滚石，洗濯出几许清静呢，试问又有谁能跳出红尘逍遥自在呢，人活着便注定奔波与劳碌，我们所能做的就是别让心太累。人真正长大以后才会感觉到心灵的负荷，精神的压力，最奢望的莫过于快乐的童年时代，真的希望自己永远也长不大。南来北往的人群中，很多表面上的潇洒与倜傥真能代表他们的内心世界吗，其实很多的答案都是否定的。或许有一个故事在大家心中深深铭刻，伴着成长给你我很多感悟与启迪，我们能做的就是别让自己的心太累。</p><p>你可以拥有爱，但不要执着，因为分离是必然的。你什么时候放下，什么时候就没有烦恼。</p><p>每个人都有过去，这些过去就形成了记忆堆积在心里的角落。一天一天，心里装的越来越多，心儿也越来越重。为何不尝试把过去哪些不开心的事情全部舍弃掉,人活在世上有无数个太多。有太多的分分秒秒、太多的瞬间，也有太多的选择、太多的无奈但这无数个太多的背后，你只能让心去承受沉淀；漫长的人生也是瞬间人生，让心孤独地去感悟吧，也许当心伤痕累累、流尽最后一滴心泪的时候，人生就不再有漫长，也就没有了瞬间！</p><p>情执是苦恼的原因，放下情执，你才能得到自在。来是偶然的，走是必然的。所以你必须，随缘不变，不变随缘。</p><p>生命是一个不停飘移的过程，你我所走过的每一个地方，每一个人，也许都将成为驿站，成为过客，一向喜欢追忆，喜欢回顾，喜欢不忘记。如今却发现，深刻在心里那些东西早已在他们的时间里化成遗忘不要让心太累，不要追想太多已不属于自己的人和事。对于曾经的驿站，只能剪辑却不能驻足，对于曾经的过客，只能感激不能强留。生命的脚步只有不停向前，才可能在生命没逝的时候找到自己的心灵归属。</p><p>世界原本就不是属于你，因此你用不着抛弃，要抛弃的是一切的执着。万物皆为我所用，但非我所属。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[日二省乎己]]></title>
      <url>http://fengchao.github.io/2009/08/22/Thinking-on-Bike/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>本来想去爬黄山，翻了攻略发现要请三天假，一犹豫没去成。满腔的郁闷只好在足球场发泄，满场跑，跑得正爽的时候，啪唧一下被铲倒。石膏一打就是6周，病假也请了不止三天。郁闷 ^2.胳膊坏了产生另外一个问题，那就是不能骑自行车上班了。这个问题也许比石膏本身更为严重，因为从那一时刻起，大脑几乎停止了思考。</p><p>大概从初三开始，骑车就成了思考问题的最佳时刻。高中住过半年校，心情越来越差，也许最主要的原因就是没了车骑。所以本科和研究生报道后的第一件事，就是买辆自行车。值得庆幸的是交大足够大，宿舍和电院离得足够远。</p><p>所以自从胳膊打上了石膏，一切就停止了前进。整个人就像进入了一个死循环，始终找不到问题的解；就像出了故障的二号线，车子一直停在那里，再也不是不停的前进；就像被拴了绳子的狗，只能在一个小扇形里面乱蹦，叫得再响也没人搭理。也许答案很简单，只是我不愿意接受这个答案。</p><p>阳台的玻璃门上贴了个时钟，从四月开始，就再也没有跳动过。显然，系统的调度算法出了问题。人的生命就像冰棒，每时每刻都在慢慢的化掉。对冰棒来说，原地踏步太奢侈了。</p><p>每天早骑车上下班，就可以思考问题了。日二省乎己，还算凑合。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[讨厌的观察者]]></title>
      <url>http://fengchao.github.io/2009/08/01/Observer/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>热力学第二定律说：在孤立系统中，熵总是增加的。许多人打心里面讨厌这个客观真理，因为它预示着总有一天，我们的世界会变成一片寂静。</p><p>为了否定第二定律，麦克斯韦设想有一个精灵，可以知道每个分子的运动速度。假定一个容器分为两部分，A和B，在分界上有一个小孔，这个精灵打开或关闭那个小孔，使得只有快分子从A跑向B，而慢分子从B跑向A。这样，它就在不消耗功的情况下，B的温度提高，A的温度降低，于是系统的熵减少了。麦克斯韦妖是不存在的，错误有两个：1. 开关小孔本身就需要能量 2. 探测分子的速度也是需要能量。 第一点很容易理解，而第二点，则在量子力学成熟之后，不停的拷问每个物理学家的哲学观。</p><p>在宏观的世界中，纯粹的观察者不会对被观察的事物产生影响。所以做实验追求数据的真实，记录历史讲求客观。但是在微观的世界中，一切都变了。要想探测一个粒子的状态，就必须对其施加影响，而这个影响本身，就改变了粒子本身。于是，测不准原理又成了一个无数人讨厌的真理。</p><p>量子力学的讨厌是天生的，越了解它的人，就越讨厌它。爱因斯坦很聪明，他深刻的理解量子力学的意义，所以虽然光量子概念成为量子力学的重要突破，但他本人却非常讨厌它，并致力于亲手消灭这个靠掷色子决定世界的学说。于是爱因斯坦与波尔之间爆发了一场论战，其争论的焦点涉及到我们对这个世界的最基本认识。所以与其说是物理学争论，不如说是一场哲学和世界观的争论。</p><p>1935年，在《量子力学对物理真实的描述可以认为是完备的吗？》一文中，详细描述了由于量子纠缠而引发的矛盾。文章由 Albert Einstein，Nathan Rosen 及 Boris Podolsky 共同完成，因此纠缠量子的奇异特性又被称为 ERP 佯谬。量子纠缠是一种量子力学现象，具有量子纠缠现象的成员系统们，不管距离多元，总是保持关联性，当其中一个被操作而状态发生变化，另一个也会即刻发生相应的状态变化。量子纠缠的结果就是虽然两个粒子相隔一万光年，只要对一个粒子施加操作，另外一个粒子就会立即感受这一操作。也就是说，这个世界是存在非定域性。</p><p>这个非定域性与侠义相对论是相矛盾的，因为按照相对论的观点，世界上不存在比光还要快的速度。一个事物的影响，最快只能以光速向外传播。这样在四维世界中，就形成了一个以光速为扩展速度的光锥，在这个光锥之外的事物，无法感受到光锥起点物体的任何信息。根据这一矛盾，爱因斯坦得出结论：如果世界上不存在真正的物理非定域性，并且量子力学对实验结果的预测正确无误，那么量子力学必定漏掉了真实世界的某些方面没有考虑。也就是说，量子力学对世界的描述是不完备的。</p><p>面对犀利的进攻，波尔并没有讨论量子纠缠，而是从哲学方面进行反驳。一方面波尔也认为世界上不存在真正的非定域性，另一反面，对什么是完备的给出了自己的看法: 只有观察者看到的世界，才是真实的世界；不确定性原理限制了我们对微观事物认识的极限，而这个极限也就是具有物理意义的一切。这些观点经过发展，成为哥本哈根解释。包括：</p><p>首先，不确定性原理限制了我们对微观事物认识的极限，而这个极限也就是具有物理意义的一切。其次，因为存在着观测者对于被观测物的不可避免的扰动，现在主体和客体世界必须被理解成一个不可分割的整体。没有一个孤立地存在于客观世界的“事物”（being），事实上一个纯粹的客观世界是没有的，任何事物都只有结合一个特定的观测手段，才谈得上具体意义。对象所表现出的形态，很大程度上取决于我们的观察方法。对同一个对象来说，这些表现形态可能是互相排斥的，但必须被同时用于这个对象的描述中，也就是互补原理。最后，因为我们的观测给事物带来各种原则上不可预测的扰动，量子世界的本质是“随机性”。</p><p>爱因斯坦并不相信这点，他认为如果量子力学是一个完备的理论，我们就能够从量子力学方程中解读出这个世界的“真实图景”，即每时每刻真正存在于我们面前的所有一切。爱因斯坦一直追求把宏观和微观统一起来。而现实的情况却是量子力学与相对论之间不可调和的矛盾。薛定谔的猫把这一矛盾清晰的表达出来。</p><p>薛定谔在1935年发表了一篇论文，题为《量子力学的现状》，在论文的第５节，薛定谔描述了那个常被视为恶梦的猫实验：哥本哈根派说，没有测量之前，一个粒子的状态模糊不清，处于各种可能性的混合叠加。比如一个放射性原子，它何时衰变是完全概率性的。只要没有观察，它便处于衰变／不衰变的叠加状态中，只有确实地测量了，它才会随机的选择一种状态而出现。那么让我们把这个原子放在一个不透明的箱子中让它保持这种叠加状态。现在薛定谔想象了一种结构巧妙的精密装置，每当原子衰变而放出一个中子，它就激发一连串连锁反应，最终结果是打破箱子里的一个毒气瓶，而同时在箱子里的还有一只可怜的猫。事情很明显：如果原子衰变了，那么毒气瓶就被打破，猫就被毒死。要是原子没有衰变，那么猫就好好地活着。</p><p>自然的推论：当它们都被锁在箱子里时，因为我们没有观察，所以那个原子处在衰变／不衰变的叠加状态。因为原子的状态不确定，所以猫的状态也不确定，只有当我们打开箱子察看，事情才最终定论：要么猫躺在箱子里死掉了，要么它活蹦乱跳地“喵呜”直叫。问题是，当我们没有打开箱子之前，这只猫处在什么状态？似乎唯一的可能就是，它和我们的原子一样处在叠加态，这只猫当时陷于一种死／活的混合。</p><p>没有人喜欢这种又死又活的状态，所以新的解释出现了，这就是平行世界解释。根据这个解释，在观察者开箱观察的瞬间，我们的宇宙分裂了，在一个宇宙中，猫是活的，在另外一个宇宙中，猫是死的。不光如此，这个解释还表明：世界的分裂无时不在，无处不再。任何观察者做出一个观察的时候，世界都分裂了一次。这一解释奇特而且不可证明，但是在许多人眼中，却是唯一合理的解释。所以是哥本哈根还是平行宇宙，依然是一个热门的议题。</p><p>综上，观察者实际上一点都不客观，随着物理学的进展，它的作用越来越大，不但影响被观察事物，导致了测不准；而且从某种意义上说，观察者界定了什么才是真实的世界；或许，观察者真的是宇宙的分裂者，每进行一次观察，做出一个选择，世界就分裂了一次。真是一个令人讨厌的东西。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[坚硬的忧伤]]></title>
      <url>http://fengchao.github.io/2009/07/22/Metal-Sadness/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>胳膊坏掉了，所以看《钢之炼金术师》很有感觉。</p><p>《钢之炼金术师》是那种明明知道剧情，看着依然很有感触的动画。故事以悲剧开始，而且随着剧情的展开，悲剧逐步从两个人，扩大到了整个世界。我喜欢的风格，一直压抑着，整个虚构的世界都笼罩在忧伤之中。在这个悲剧的世界中，两个悲剧的人在坚定的前进。他们一个只有钢铁空壳，一个手脚都被机械手替换。因为钢的身体，所以被称为钢之炼金术师。然而比身体更坚硬的，是他们不屈的精神。执着寻找答案，永不言放弃，即使真相的深处还隐藏着另外一个真相，真相越来越邪恶，越来越黑暗。是他们，让忧伤带上了坚硬。</p><p>胳膊坏掉了，只写这么短，修好了再补吧。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 内核中的链表]]></title>
      <url>http://fengchao.github.io/2009/06/15/Link-list-in-linux-kernel/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常链表数据结构至少应包含两个域：数据域和指针域，数据域用于存储数据，指针域用于建立与下一个节点的联系。按照指针域的组织以及各个节点之间的联系形式，链表又可以分为单链表、双链表、循环链表等多种类型。在数据结构课本中，链表的经典定义方式通常是这样的（以单链表为例）：</p><pre><code>struct list_node {
    struct list_node *next;
    ElemType    data;
  };
</code></pre><p>这样的数据类型结构清楚，但是因为 next 的类型各不相同，不同的链表类型都必须有不同的操作方式，无法用统一的函数对它们进行处理。所以内核里面使用一个统一的链表将相应的数据结构穿起来。对不同的链表来说，引线都是一样的，差别就在引线上的连接的数据结构不同。如下图所示：</p><p>数据结构的定义就是：</p><pre><code>struct list_head {
    struct list_head *next, *prev;
};

struct list_node {
    struct list_head list;
    ElemType    data;
};
</code></pre><p>这样，对链表的处理最终都会转化为对 list_head 的处理，内核提供了一整套统一的宏和函数来进行(代码位于 include/linux/list.h)。</p><h2 id="宏和函数："><a href="#宏和函数：" class="headerlink" title="宏和函数："></a>宏和函数：</h2><p>（1） 初始化宏</p><pre><code>#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }
#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)
</code></pre><p>LIST_HEAD 定义了一个 name 并进行初始化， name 的 next 和 prev 都指向它自己。如下图所示：</p><p>（2） 插入</p><pre><code>/* 内部函数，插入任意位置，前提是 prev 和 next 已知 */
static inline void __list_add(struct list_head *new,
                          struct list_head *prev,
                          struct list_head *next)
{
    next-&gt;prev = new;
    new-&gt;next = next;
    new-&gt;prev = prev;
    prev-&gt;next = new;
}
</code></pre><p>下面量个函数为对 __list_add 的包裹，封装出头部、尾部插入</p><pre><code>static inline void list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head-&gt;next);
}

static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
    __list_add(new, head-&gt;prev, head);
}
</code></pre><p>（3）删除</p><pre><code>static inline void __list_del(struct list_head * prev, struct list_head * next)
{
    next-&gt;prev = prev;
    prev-&gt;next = next;
}

static inline void list_del(struct list_head *entry)
{
    __list_del(entry-&gt;prev, entry-&gt;next);
    entry-&gt;next = LIST_POISON1;            // 对此位置的引用将报错
    entry-&gt;prev = LIST_POISON2;           // 同上
}
</code></pre><h2 id="3-数据访问："><a href="#3-数据访问：" class="headerlink" title="3. 数据访问："></a>3. 数据访问：</h2><p>以上仅介绍了对链表的操作，也就是能够在一个绳子上移动，而要通过绳子访问链表上的其它数据，就需要一些技巧了。在这里使用了容器的概念，把绳子上穿的数据结构当成容器，连着它 list 成为容器中的一个把手，通过 container_of 这个宏就能根据把手找到对应的容器。</p><pre><code>/**
* list_entry - get the struct for this entry
* @ptr:        the &amp;struct list_head pointer.
* @type:       the type of the struct this is embedded in.
* @member:     the name of the list_struct within the struct.
*/
#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)
</code></pre><p>其中，</p><pre><code>#define container_of(ptr, type, member) ({                  \
    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
    (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre><p>这里首先将 ptr 中的地址转化为 member 类型的地址，然后转化为 char 指针并减去 offset。 其中， offset 的意义如下图所示，只需要将 list_head 所在位置减去 offset 的值，就可以得到整个数据结构的起始地址。将这个地址强制转化为 type 类型指针，就得到了指向这个结构体的指针。<br>内核中 offset 有两种获得方式：</p><pre><code>#undef offsetof
#ifdef __compiler_offsetof 
#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
#endif
#endif /* __KERNEL__ */
</code></pre><p>第一个种方式由编译器负责产生 offset 的值。第二种方式通过直接用 0 指针的方式获得。这里的技巧是：<br>当编译器看到 ptr-&gt;member 时，会自动将 ptr 中的地址与 member 的偏移量相加，也就是得到 ptr + offsetof(member)。 而当我们将 0 强制转化为 TYPE 指针的时候，得到下式。注意在地址 0 的位置上并没有定义 TYPE 的数据结构，而仅仅是利用编译器的处理方式获得偏移量的位置。</p><pre><code>ptr-&gt;member 
= ptr + offsetof(member) 
= 0 + offsetof(member)
= offsetof(member)
</code></pre><h2 id="4-遍历链表"><a href="#4-遍历链表" class="headerlink" title="4. 遍历链表"></a>4. 遍历链表</h2><p>用这个宏就可以根据链表头地址访问到链表中每一个结构体的位置，对链表中数据结构的操作，就通过 pos 进行。</p><pre><code>/**
* list_for_each_entry -       iterate over list of given type
* @pos:        the type * to use as a loop cursor.
* @head:       the head for your list.
* @member:     the name of the list_struct within the struct.
*/
#define list_for_each_entry(pos, head, member)                      \
    for (pos = list_entry((head)-&gt;next, typeof(*pos), member);      \
         prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);        \
         pos = list_entry(pos-&gt;member.next, typeof(*pos), member))
</code></pre><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用 EPIA-PX 的水下自主机器人]]></title>
      <url>http://fengchao.github.io/2009/05/26/EPIA-PX-Robot/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p><img src="/images/underground-robot.jpg" alt="stock" title="Robots"></p><p>水下自主机器人，长1.1 米，重 7 千克，控制使用 Pico-ITX 型主板 VIA EPIA-PX，主要参数为：<br>￼<img src="/images/via-exia-px.jpg" alt="stock" title="EPIA-PX"></p><ul><li>1 GHz EPIA PX 10000 mainboard</li><li>1 GB RAM</li><li>4GB CF Card</li><li>2 x Logitech Quickcam Pro 4000</li><li>4 x Internal vector thrusters*</li><li>1 x 100W Brushless Motor</li><li>5 x 30A MAG8 electric speed controllers</li><li>1 x Belkin Wireless USB Adapter</li><li>1 x Inertial Measurement Unit*</li><li>12 x 2400mAHr LiPol Batteries</li><li>1 x M3-ATX picoPSU 125W</li></ul><p>水下运动完全由机上控制器操作。传感器包括惯性检测、压力传感器和2个摄像头。所有底层硬件都是由 PX 上的 Java 软件驱动。通信可以通过防水网线或者机上的 802.11g 无线 USB 模块完成。</p><p>上位机采用 Ubuntu 8.04 ，包括一个 GUI 控制界面。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[流水帐＠20090517]]></title>
      <url>http://fengchao.github.io/2009/05/18/20090517/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>窗帘加了遮光布，效果好多了，但是我还是很早就醒来。躺在床上撑到七点，开始刷牙洗脸。东川线-&gt;640,空腹跑到浦南医院去做狂犬疫苗的复查。急诊室的小护士冷冰冰的回答：我们这里没检查，只有疾病控制中心才有。</p><p>不查就不查，为了不让大早起跑了半天成为沉没成本，只好疯狂加仓：临时决定回徐汇校区看下。找了家 KFC 填饱肚子，要了碗咸咸的牛肉粥。粥太难喝了，看来我只能接受甜粥；旁边有个超短裙的美女，忍不住多看了两眼。不知道上边谁来了，搞得交警紧张的要命，口哨吹个不停，直到一小队面包开过才回复了正常。</p><p>徐川线，绕弯上桥，一直到徐家汇下车。走天平路，过天平宾馆，想起华为的面试。貌似那时是第一次穿西装，第一次群殴，回想起来，相当幼稚。华为啊华为，不招我是你的损失啊，居然看不出我是个潜力股。</p><p>我，应该是个念旧的人吧。初中的时候没事偶尔会回趟夏侯小学，跑到顶楼呼吸下空气。上大学的时候每次回家必会学校。等到工作了，有机会还是想回学校看看。毕业一周年的时候，跑到闵行走了一圈，腿都断了。不变的校门，不变的寝室，不变的实验室，变化的只是我自己。</p><p>用一件事情回忆，小学，就是没事打着玩；初中，就是每天晚自习前泡一个小时游戏厅；高中，踢球和站在阳台看别人踢球；大学变成了所有泡过的自习室；研究生变成了图书馆翻过的好书和被囚禁了一年多的实验室。我，什么时候开始变得爱学习？</p><p>“上海交通大学徐家汇校区”不一样，这里，既不是我学习的地方，也不是生活的地方。简单的中转站，却记录了太多的理想与现实，几乎每个地方都有故事。第一次来的时候，几个人在图书馆那边校门等着，心情是多么小心翼翼。每次路过校医院前面，都会想起体检的时候排的长队。那次为了尿检，我拼命的喝水。去图书馆参观过校史，记得有个美女不停地暗示我什么，我傻傻的无动于衷。如果当时情商不是那么低，我早就在另外的平行宇宙中快乐的生活着了吧。面试完坐在勇攀高峰前面的时候，曾经看着浩然高科，憧憬着光辉灿烂的未来。而现实一点都不光辉，不灿烂。浩然高科倒是留下了一个经典而残酷的笑话：</p><p>导师：你在哪？<br>学生：我在浩然高科。<br>导师：那你明天来答辩吧。</p><p>今天特地无聊地跑到浩然的最高层看了以下，果然所有的窗户都被铁丝拧紧了。</p><p>出了校门，习惯性的跑到昂立书店，刷了卡，拿了书。真的不知道从什么时候开始，变得看到书就走不动路，不买心理难受。看来买书也是可以上瘾的。</p><p>然后就坐大桥六线，回想起第一次随便找辆车就上的情形，居然能到张江。到地已经一点了，随便吃了点东西，感慨这么过了一天，时间戳居然没有发生丝毫的混乱。也许是因为太熟悉，也许是因为太困。</p><p>到家倒床就睡，好一会没睡着，脑子里面一团浆糊，想着谁在来帮我捣乱点。后来就迷迷糊糊睡着了，醒来的时候，外面下着雨。好久都没睡这么爽过了，闻着空气中雨的气味，听着窗外雨的声音，我总能睡得很好。我是喜欢雨的，原因似乎是因为曾经暗恋了一个女孩六年，她的名字中带了个“雨”字。</p><p>醒了之后开始消化积压的第一财经，吃了晚饭，聊了QQ，跑了步。按理应该到了睡觉的时候，只是小姜突然口渴了，找不到饮料翻出了几瓶啤酒。借酒消愁不是我的风格，不过好不容易过了禁酒期，决定象征性的陪小姜喝酒。开了花生，切了牛肉，姗姗也加了进来。喝了半天，聊了半天，反正该明白的也糊涂了，没明白的更混乱。其他记不得了，反正姗姗现身说法，证明处女座的人总是心太软。好像QQ上LZ也这么说，好像 Ivytear 也这么说，我以前似乎是一个冷漠的人吧，至少从外表上看。</p><p>今天的事不放到明天，今天的话不留到明天，今天的酒保证醒了才睡觉。写道这里，我的酒也醒的差不多了。好多事情，总是过了很久，才敢说出来，因为不知道会用那种心境去描述一件事情。直到有一天，感到完全释然，做到心净如水。应该花点时间回忆下学校的往事了，现实的压力大了，那些心境真的会忘掉的。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自己的眼睛看真实的世界]]></title>
      <url>http://fengchao.github.io/2009/05/18/Economics/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>以前在水源和人吵架的时候，碰到 IMF 的话题，我经常搜肠刮肚，找出最恶毒的语言咒骂它。后来就想到底什么时候开始仇视 IMF 的。今天这个问题终于有了答案：我是看着斯蒂格利茨的经济学成长起来的：）</p><p>大概是泡在图书馆三楼证泛函的时候，脑子实在是绕得难受，就随便找了一本看。一看就看上了瘾，看完之后发现是一套值得收藏的书，于是上下两册，成了我买的唯一一套经济学教材。又这本书领进门，其实挺幸运。这本书具体讲了什么观点倒是无所谓，最重要的是从阅读的过程中，学会了用自己的头脑认真分析事实，而不是理解某些人的观点。因为经济学和物理化学不一样，好多东西根本缺乏事实检验，没有什么观点可以称为真理。只有具有独立思考的能力，才能够避免被某个所谓的学说洗脑。</p><p>所以当无数人被黄金无用论洗脑的时候，我依然坚信“货币天然是金银”。所以当看到南美亚洲到后来的美国，IMF 开出了两服截然相反的药方的时候，实在是压不住心中的怒火：做人不能太无赖啊。当年发生亚洲金融危机的时候，IMF 高举“华盛顿共识”的大旗。本来经济就在下行，IMF 却以贷款为要挟，要求削减政府开支、企业私有化、贸易自由化。这一系列猛药毒药对经济的打击程度绝对是空前的，可以不客气的说：印尼发生的暴力骚乱，IMF 就是外部最主要的推动力量，是刽子手的帮凶。</p><p>开始的时候我在 FT 骂 IMF，还经常有些人替这个美国人的机构辩护。找到各种理由论证这些措施的合理性。但是在看看当美国发生经济危机的时候， IMF 的一帮人又开出了什么药方： 急速膨胀的财政赤字、银行国有化、贸易保护主义迅速抬头。这才算是真正的药方，而这个药方，并不是他们从亚洲的教训中学来的。哪个好，那个坏，他们早就明白得一清二楚。毒药就是为了把经济搞垮，这样才能低价收购被害国的资产。而其他国家是可以吸取教训的，教训就是只要 IMF 给他国开药方，一定要反着想问题，想想我反着做，是不是就好了。</p><p>索马里海盗，那是毫不隐瞒自己的强盗身份；不像 IMF，一边到处杀人，搞得国家动荡，一边把自己描绘成经济的救世主，婊子一个。当然，我能看到这些，应该是也看了斯蒂格利茨的其他言论，只不过当时不了解这个人罢了。</p><p>用自己的大脑去思考，就会发现经济学里面存在着太多的谎言，故意欺骗。用自己的眼睛，看真实的世界，总有一天会发现：真实的世界，很残酷。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[几种开源软件名字的读音]]></title>
      <url>http://fengchao.github.io/2009/05/18/Sound-of-opensource-projects/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>2006-09-30 08:57　 来源:<a href="http://www.linuxplanet.com/linuxplanet/tutorials/6277/1/" target="_blank" rel="external">http://www.linuxplanet.com/linuxplanet/tutorials/6277/1/</a> 编辑:infohunter　　 开源软件的名字都比较“奇怪”，其读音也令人费解，看了网上一外国友人的文章，感觉挺有意思，下面简单给出几种“难度”较高的名字的正确读音与大家分享：</p><p>GNU/Linux： 可能很多人都不知道GNU的发音，因而直接读成G-N-U，实际上根据GNU官方网站的说法， GNU应该发成guh-Noo，类似于‘伽努’的发音。至于Linux，发音就千奇百怪了，主要的差别在于字母u的读音上。这个u呢，有发成‘衣’的，有 发成‘优’的，发成‘乌’，有发成‘er’的，还有发成‘a’的，我听到的发‘衣’和‘乌’的比较多，其他的基本没听到过。那么这个Linux到底怎么 读，还是来听听Torvalds自己的读音：</p><p>这里是mp3: <a href="http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3" target="_blank" rel="external">http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3</a></p><p>他说：Hello, I am Linus Torvalds, I pronounce Linux as Linux.</p><p>我听了好几遍，应该是发成类似‘er’的音（就是bonus这个词里的u的发音），所以Linux应该读成‘李呢克斯’</p><p>SUSE: Novell的发行版，以“易使用，难发音”著名。这个也是比较混乱的那种，怎么读的都有，来个权威的吧：来自Novell的发音 —— Soo-suh（苏塞？？苏瑟？？苏撒？？反正不是苏西）</p><p>Ubuntu: 最流行的发行版，我估计没几个中国人会念这个词。来自Ubuntu父公司的Marlize Coetzee说：“Ubuntu，来自非洲祖鲁族(Zulu)和克萨族(Xhosa)人的单词，读成oo-boon-too(乌奔突)”</p><p>Debian： 好像很多人（包括我）都读成“地被恩”，但事实并非如此，这个看起来很有异国情调的词语实际的来源很简单，就是两个人名的连接 —— Deb 和 Ian，所以，正确的读法是DEB-ee-un</p><p>Azureus: 如何读这个著名的BT客户端软件的名字一直都是人们争论的焦点，Azureus官方声明此单词没有官方读音，但是他们建议读成uh-Zoo-ree-us</p><p>Liferea: 这个著名的RSS阅读器的名字来自如下缩写：LInux FEed REAder。该项目的领导者Lars Lindner说：“我，一个德国人，这样读这个名字的’lee-fer-rejah’（注：本人学过一点德语，所以发音肯定是‘丽菲雷亚’，很美的名字 啊）。但是我想很多英语国家的人会发另外一种很不同的音，因此该单词没有官方读音”</p><p>QT: 这个非常有意思，很多人都读成字母Q-T，但是奇趣公司给的官方读音是Cute，怪不得QT做出来的界面如此可爱呢.<br>——————————————————————————————————<br>悲哀在于,所有硬件都主动去追求WINDOWS</p><p>遗憾的是, Linux 却要主动去追求所有硬件</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[灰原哀]]></title>
      <url>http://fengchao.github.io/2009/05/10/Gray-I-2/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>很早就喜欢灰原哀，但是无法给出喜欢的理由，以至于曾经把这种喜欢归结为她的短发。昨天经过 ivytear 一分析，才发现原来是由于灰原那绝对的理性。也许我只是想在动漫的世界中，寻找另外一个自己。</p><p><img src="/images/GrayI/GrayI-1.JPG" alt="Gray"></p><p>灰原哀是日本漫画和动画《名侦探柯南》中的虚构人物，真名为宫野志保。原为黑衣人组织内的一名科学家，代号雪莉。因唯一的亲人，姐姐宫野明美（假名广田雅美）在十亿日圆抢劫案中被组织成员GIN杀害，所以她中止了药物的研究以示抗议；在被关押等候组织处置过程中，她吞下偷藏的APTX4869自尽，却幸运地被缩小得以逃脱。</p><p>逃出组织的宫野志保为寻找相同遭遇的这就是灰原哀，一个永远都只能注定成为配角的人物，一个爱的伤感，爱的寂寞，爱的让人心痛的女孩。工藤新一而晕倒在他家门口(动画版第128集)，被阿笠博士救起并收留。阿笠博士采用名字来源于菲利斯·詹姆斯的推理小说中的女侦探Cordelia Gray的“Gray（灰色）”和Sara Paretsky作品中的女侦探V.I. Warshawski的“I”，为她取化名“灰原爱”，但她自己坚持用同音的“哀”来代替“爱”，从此她化名灰原哀并就读于柯南所在的帝丹小学一年B班。</p><p>灰原哀是柯南中非常关键的一个人物，她是导致新一身体缩小的APTX4869的研制者，从某种程度上来说是造成新一与小兰略带悲情的爱情故事的始作俑者。就凭这一点她就应该被无数新一的FANS所唾弃。然而，那种理性中带着感性的独特气质与挥之不去的淡淡的哀愁令无数观众为之倾倒。在大多数时间里，她是个理智到冷漠的科学家，会说出诸如“人是不可以逆转时间的……如果特意去扭转它的话，人类就会受到惩罚”这样有着深刻哲理的话。看到哀，会想起沙加了。完美的理性，绝对的冷静，似乎任何事情，都无法在其心里泛起波澜。不管发生什么事情，都仔细的思考一切，然后蹦出几句冷酷但是绝对理性的答案。似乎除了沙加，哀就是最接近神的人了。但是碰到爱，理性就再也不起作用了。</p><p>哀的确爱上了柯南，但是两人又恰恰属于那种智商高情商低的人。柯南在爱情方面除了小兰之外几乎就是迟钝与白痴的代名词，而哀的性格以及所处的境遇也决定了她永远不可能亲口承认自己的感情。灰原一直压抑对新一的感情。只是在恰当时机，偶尔委婉流露内心的感觉。在2000年的《瞳孔中的暗杀者》小兰失忆后，新一希 望小兰迅速恢复,而灰原说：“失忆不更好。那她永远无法发现你的真实身份。我们就可以永远——永远这样了。”明知新一心里除了小兰放不下别人的灰原，独自 忍受单恋的痛苦。早已知道结局，仍漫步爱情的道路。灰原的名字似乎影射她感情的伤痛结局——“小哀”。</p><p>这就是灰原哀，一个爱的伤感，爱的寂寞，爱的让人心痛的女孩。她的痛苦，永远不会告诉别人，只会在没人的深夜独自对着电话向已经去世的姐姐倾诉自己的孤独。</p><p><img src="/images/GrayI/GrayI-2.JPG" alt="Gray"></p><p><img src="/images/GrayI/GrayI-3.JPG" alt="Gray"></p><p><img src="/images/GrayI/GrayI-4.JPG" alt="Gray"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[弗里德曼的信徒]]></title>
      <url>http://fengchao.github.io/2009/05/03/Milton-Friedman/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>在去年猪肉价格暴涨的时候，在水源和别人吵架，我说“通货膨胀本身并不会引起经济危机，通货膨胀之后紧随的通货紧缩，才会引起经济危机”。立即被人给了扣上了“弗里德曼的信徒”这顶帽子。本来我打心眼里是不喜欢这个观点的，但是历次经济危机的统计事实告诉我们，这是个普遍真理。</p><p>从这个角度来说，世界经济最坏的时刻，远没有到来。在危机的时刻表上，下一站将会是美元泛滥的通货膨胀，然后是各央行为了应付通胀而猛提利率而直接导致的通货紧缩。那一刻，真正的倒闭狂潮才会到来；那一刻，才是哀鸿遍野。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ada Lovelace]]></title>
      <url>http://fengchao.github.io/2009/03/28/Ada/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>就像护士通常是女人一样，程序员通常是男的。为数不多的女程序员当中，又有相当一部分集中于测试、技术支持部门。Linux 内核的提交人员当中，几乎看不到一个女性的名字。是偏见，还是天性，不得而知。但是有一点是肯定的：第一个计算机程序，出自 Ada 只手，她是一个女人。</p><p>1815年生于伦敦，她是英国著名诗人拜伦(L.Byron)的女儿。因父母婚姻破裂，出生5星期后就一直跟随母亲生活。母亲安娜·密尔班克（A.Millbanke）是位业余数学爱好者，阿达没有继承父亲诗一般的浪漫热情，却继承了母亲的数学才能。</p><p>阿达19岁嫁给了威廉·洛甫雷斯伯爵，因此，史书也称她为洛甫雷斯伯爵夫人（Lady Lovelace）。由于巴贝奇晚年因喉疾几乎不能说话，介绍分析机的文字主要由阿达替他完成。阿达的生命是短暂的，她对计算机的预见超前了整整一个世 纪。阿达早逝，年仅36岁，与她父亲拜伦相似。根据她的遗愿，她被葬于诺丁汉郡其父亲身边。</p><p>阿达设计了巴贝奇分析机上解伯努利方程的一个程序，并证明当时的19世纪计算机狂人巴贝奇的分 析器可以用于许多问题的求解。她甚至还建立了循环和子程序的概念。由于她在程序设计上的开创性工作，Ada Lovelace被称为世界上第一位程序员。当时的阿达甚至不顾自己已是三个孩子的母亲，坚定地投身于分析机研究，成为巴贝奇的合作伙伴。在1843年发 表的一篇论文里，阿达认为机器今后有可能被用来创作复杂的音乐、制图和在科学研究中运用，这在当时确是十分大胆的预见。以现在的观点看，阿达首先为计算拟 定了“算法”，然后写作了一份“程序设计流程图”。这份珍贵的规划，被人们视为“第一件计算机程序”。</p><p>美国国防部花了10年的时间，把所需软件的全部功能混合在一种计算机语言中，希望它能成为军方数千种电脑的标准。1981年，这种语言被正式命名为ADA（阿达）语言，以纪念这位“世界上第一位软件工程师”。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[欧洲研制生物神经网络芯片]]></title>
      <url>http://fengchao.github.io/2009/03/27/Neuro-network-chip/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:23:01 GMT+0800 (CST) --><p><img src="/images/NeuroNetworkChip.jpg" alt="Neuro network chip"></p><p>欧洲一跨国研究组研制了一个像人脑一样运行的芯片。它由200,000 多个神经元及连接它们的 5 千万个突触组成。尽管这个数目和大脑相比依然微不足道，但是设计的时候已经考虑了多芯共同工作的情况，加上神经网络固有的并行计算优点，未来可能组成大型网络阵列来进行计算。</p><p>大脑就是神经网络，灵魂就是神经网络间突触的电流。无神论的我坚信这一点，而通过模拟神经网络来理解大脑的运行方式，是未来计算机发展最有前途的方向。目前的芯片依然包括硅原件，未来研发全生物的芯片是完全有可能的。这也为人脑和计算机的融合扫平了障碍，潘多拉的盒子已经渐渐打开。</p><p>原文参见: <a href="http://www.technologyreview.com/computing/22339/?a=f" target="_blank" rel="external">http://www.technologyreview.com/computing/22339/?a=f</a></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sun 开源了 Java]]></title>
      <url>http://fengchao.github.io/2006/11/16/Sun-Opens-Java/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><img src="/images/java_logo.jpg" alt="Java" title="Title"></p><p>13.November.2006—Sun believes deeply in creating communities and sharing innovations and technologies to foster more participation. Today in a historic move, Sun is opening the door to greater innovation by open sourcing key Java implementations—Java Platform Standard Edition (Java SE), Java Platform Micro Edition (Java ME), and Java Platform Enterprise Edition (Java EE)—under the GNU General Public License version 2 (GPLv2), the same license as GNU/Linux.</p><p>Sun is now the biggest contributor to the open-source community. Already Sun has released open-source implementations of its Solaris Operating System, NetBeans, Project Looking Glass, Project JXTA, Jini, OpenOffice, OpenSPARC, and Java EE technologies and is continuing on its path to open all of its middleware. By adding a second GPLv2 license to Java EE, which was previously available under the CDDL license through Project Glassfish, Sun is now open sourcing all core Java technologies under the same license.</p><p>Through this move, Sun is helping to:</p><p>Fuel innovation and build broader developer communities by enabling interested Java developers, as well as developers in the GNU/Linux community, to contribute more easily to the evolution of Java technology<br>Drive faster evolution of the Java platform and adoption by new developers and in new markets while ensuring platform quality and flexibility<br>Allow the 5 million Java developers worldwide to leverage platform enhancements and speed time to market for new applications<br>Enlisting the World to Innovate<br>For the past 11 years, Java technology has enabled developers to Write Once, Run Anywhere. Sun’s commitment to compatibility and choice has made Java the most widely deployed application platform. Java technology is currently used on more than 4 billion devices worldwide, and the Java ME platform ships on more than eight of every 10 mobile handsets.</p><p>Sun believes Java technology has reached the right level of maturity, adoption, and innovation—with widespread use across enterprises and devices—to move into the next stage of its evolution. In the largest single contribution under the GNU GPL, Sun is releasing all of its key Java implementations under this widely respected free-software license:</p><p>Open-Source Java SE: Today Sun is releasing the source code for the Java HotSpot virtual machine, the Java programming language compiler (javac), and JavaHelp online help software. Release of a fully buildable Java SE Development Kit (JDK) based nearly entirely on open-source code is expected in the first half of 2007.<br>Open-Source Java ME: Sun is first releasing the source code for Sun’s Java ME Feature Phone implementation based on Connected Limited Device Configuration (CLDC), which currently enables rich mobile data services in more than 1.5 billion handsets, and the source code for the Java ME testing and compatibility kit (TCK) framework. Later this year, Sun will release additional source code for the Advanced Operating System Phone implementation for based on the Connected Device Configuration (CDC) specification and the framework for the Java Device Test Suite.<br>New Developer Communities: Tapping its experience in building dynamic and transparent open-source communities, Sun is launching the OpenJDK Community and the Mobile &amp; Embedded Community to support developer participation in evolving the open-source JDK and open-source Java ME implementations respectively.<br>Developers wanting to get started right away can take advantage of the best tool for open-source Java application development: the NetBeans Integrated Development Environment (IDE). The NetBeans IDE provides complete support for the entire Java platform, from Java ME to Java SE to Java EE. To further speed time to market, Sun is also providing pre-built NetBeans projects at netbeans.org for the Java language components being open sourced and is making the Sun Studio development environment available at developers.sun.com/sunstudio for the native Java language components.</p><p>Open-Source Opportunities<br>By open sourcing its Java implementations, Sun will open new market opportunities, fuel innovation, and drive broader adoption of this Web 2.0 platform while minimizing fragmentation in the mobile community by delivering a consistent application platform across devices.</p><p>Developers and ISVs can build differentiated Java technology-based applications and value-added Web. 2.0 services more quickly through access to the latest Java source code.<br>Developers can improve platform quality and functionality by contributing feature enhancements, bug fixes, and testing results to the open-source Java initiatives.<br>Customers can lower costs and protect technology investments by taking full advantage of open-source business models that allow for free substitution of alternative operating systems, architectures, middleware, and devices on industry-standard hardware.<br>Governments and educational institutions can reap the benefits of open-source Java technologies while ensuring security, privacy, and datacenter control.<br>GNU/Linux distributors can add no-cost Java implementations to their distributions, while customers with stringent open-source requirements can deploy a free, reliable Java software stack on most GNU/Linux distributions.<br>Sun is taking careful and deliberate action as it open sources its Java technology implementations to help ensure that Java remains a central unifying standard for the Internet. Whether developers and customers choose to use Sun’s commercial Java platforms or new open-source implementations, Java technology will continue to deliver the compatibility, stability, and quality required to turn Web 2.0 advancements into competitive advantage.</p><p>Go to sun.com/opensource/java for more information.</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[又是宿命——圣枪修女经典评论]]></title>
      <url>http://fengchao.github.io/2006/10/08/Chrno-Crusade/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:18 GMT+0800 (CST) --><p>圣枪修女经典评论（转）</p><p>这个是改版前CM里面某为高人的作平.推荐给看完圣枪修女的人看.推荐的理由不是因为他能写.而且的确写的不错.想重新认识此片的大人不妨来试试</p><p>圣枪修女其实是一部非常好的作品只是炒作不够!大家支持吧！它不是只看一遍就能明白的作品！！看完全片后再看开头感觉就不一样了！！！！！看不懂是你水平有限！！看不懂的人没资格评论它的主题和剧情等等！！当了解了他们的背景身世等诸多事实以后，就应该发现萝塞特绝对不是那种纯粹的搞笑角色，他（她）们其实是很可怜的！！！</p><p><img src="/images/Chrno/Chrno2.jpg" alt="Chrno"></p><p>“神赐给我们智慧，神赐给我们灵魂。”说这句话时罗塞特就已经对神屈服了。</p><p>“但决定的人是我。”不管这是不是神对他们的玩弄罗塞特也不在乎，因为她要救克罗诺！她不是为神才这么做的！！！555~~~神只是安排好了一切——当罗塞特需要醒来时就刻上最后的圣痕，让她醒来。 而艾恩真的是恶魔吗？他更像一个天使吧。但他不想这样，所以他自己掰下了尖角，并说那是为了自由。</p><p>他们所有人都为自由失去了很多，因为他们都被神玩弄怕了。</p><p>艾恩，没有力量超越生死，是神让他复活的。因为一切都是神早已设计好的！神的目的是拯救这个堕落的世界（罗塞特说）。？而所有人只是祭品而已！包括艾恩！这就是所谓的因果率（动画中有提到）吧。！如：神为了让克罗诺能杀死艾恩，早已为克罗诺事先安排好了一个马克达莲娜，这样就可以保证克罗诺在关键时刻不会逃避！而只是一个时代有一个时代的圣女，不一定能达到神的目的，所以神让艾恩复活，“帮忙”推动时代的发展。</p><p>所以我说艾恩更象一个天使。 但作‘祭品’注定要牺牲幸福，他们为了逃避宿命才追求自由，反而又进了神的另一个圈套！ 不知我说的您能否接受。</p><p>“在神所决定的命运前，任何人无能为力。”5555~~</p><p>一、艾恩那句自我介绍；</p><p>I am Alpha and Omega, the beginning and the ending, the first and the end,saith the Lord, which is, and which was, and which is to come, the Almighty.</p><p>这是《圣经~新约》中的最后一章《约翰启示录》中上帝形容自己的话。这句话，凡是玩过《异度装甲》的玩家一定不会陌生吧，顺道一提《异度传说》的那句话是尼采老大说的，意思是：“力的意志，将出现在善与恶的彼岸”。</p><p>将上帝的自我介绍用在自己头上，这应该算是比较刁的了吧…………可是按我说，旧约里上帝向摩西介绍的才真正又简洁又有威严：“I am that I am.”翻译过来：“俺是自有而永有的。”帅的多。</p><p>此外《约翰启示录》本身也包含着诸多的东东，比如末日审判预言之类，这些在圣枪修女中也有一定的体现（主要是指艾恩第一次登场之时的场景），一般动漫作品要扯圣经必扯《约翰启示录》。所以建议大家下来自修……<br>二、法帝玛的预言</p><p>应该说是圣枪修女的主要迷团之一，详细介绍一下（以下转贴）</p><p>1917年5月至10月，在葡萄牙花地玛镇，圣母玛莉亚出现在3个小孩子面前，达6次之多。</p><p>最初天使现身，接著在天使带领下，圣母玛莉亚出现了。圣母给孩子面包和葡萄酒。在基督教中，面包代表基督的肉体，酒则代表基督的血。获得面包和酒，在基督教中象徵最崇高的祝褔。就在某一天，玛莉亚对孩子说：「从现在开始，请把我的话全部记下，好好地封印保存起来。在得到我的通知前绝不可以去除掉这个封印。</p><p>孩子们从玛莉亚口中听到後记载下来的，就是「花地玛的预言」。</p><p>「花地玛的预言」在孩子们长大後，收到玛莉亚的通知而公开出来，但一开始并没有人理会。但在第一、第二预言被证实精准地和事实完全稳合时，才开始受到广大的注目。而被证实内容是分别预告第二次世界大战和苏联共产党的兴亡 。「花地玛的预言」遭到严格封印的第三预这的已获得证实。但可以读取「花地玛的预言」的只有教皇一人。因为这是预言书更何况是来自圣母玛莉亚的告示，因此罗马教廷一律以「不外洩的机密文书」收藏著，不予对外公开。</p><p>这个预言只可於一九六○年後才能公开，但到了一九六○年，当时的宗约翰十三世拒绝披露预言的秘密，其後的三位宗在看过预言内容後，亦作出同一决定，令事件倍添神秘色彩，至今只有四位宗和一位廷高层人士知道预言的内容。其中罗马教皇保罗六世在某一天受到神的启示，当他打开第三封预言时，因内容过於惊悚，竟然当场昏死过去。有传言第三预言的内容也开始流洩到外部去。保罗六世将他认为只有清教徒才知道的部份分割出来，以极机密岝式分送到全世界。</p><p>有传言是「二十世纪最後的一年到二十一世纪，神将对人类施以最大的试炼。…火和烟从天而降，大海的水如蒸气般涌现上来。因为这个灾难，地球上的大多数东西将被破坏，人类之中的九分之七也将遭灭绝！但是，活存下来的人并不意味著幸运。或许他们将会羡慕死者，因为他们所遭遇到的，是一种生不如死的空前苦痛……</p><p>在圣母於花地玛显灵八十三周年的纪念日，终於公开圣母当年向三名牧童透露的第三个预言，表示其内容是预示现任宗若望保禄二世於八一年遇刺的事件。</p><p>梵蒂冈国务卿索达诺在花地玛的纪念弥撒上宣告，第三个预言提及「一位主身穿白袍在枪声中倒卧於地，显然殒命。」梵蒂冈发言人纳瓦罗表示，很明显身穿白袍者正是宗若望保禄二世，而当年亲受圣母预言的其中一名牧童露西娅修女据报亦已证实，该位白衣主正是宗若望保禄二世，他在预言中於众位殉者的屍体旁边走过，痛苦地步向圣十架，身中枪伤倒在地上。</p><p>宗於八一年五月十三日，即花地玛圣母显灵纪念日当日，在梵蒂冈圣彼得广场遭一名土耳其恐怖分子行刺，宗相信是圣母显灵拨开子弹，他才得保性命。</p><p>不过一些人对第三个预言的内容表示失望，他们说原本还以为会预言一些惊天大事，因过往所预言的都是影向世界大同的事，但今次公开的，都是已发生了的事.</p><p>我认为艾恩更像一个天使。艾恩，没有力量超越生死，是神让他复活的。克罗诺化石期间雷明顿说过：“罪人俘获地上代言人的行为可能正是神的安排。” 因为一切都是神早已设计好的！神的目的是拯救这个堕落的世界（罗塞特说）。而只是一个时代有一个时代的圣女，不一定能达到神的目的，所以神让艾恩复活， “帮忙”推动时代的发展。所以我说艾恩更象一个天使。法帝玛的预言在圣枪修女中的重要性并不大，就是引出“御使”用的了。而您没发现吗？艾恩的行为是引起二战的一个重要因素————等于帮助神实现了法帝玛的预言。他自己掰下了尖角，并说那是为了自由。我不否定艾恩仇视神，</p><p>但神好像就是利用了艾恩的这一点。艾恩也说过：“没有灵魂的躯壳。”（前面就是他掰下了尖角的镜头）其实马克达莲娜，并不是一个完整的圣女。她连额头上的精魂都没有。她说过她只是一个没有灵魂的躯壳。是不是和艾恩有一点像呢？</p><p>其实马克达莲娜，并不是一个完整的圣女。因为她的主要使命只是死在克罗诺面前。所以她才不会害怕死亡。她连额头上的精魂都没有。她说过她只是一个没有灵魂的躯壳。她之所以有预知未来的能力，只是出于任务需要而已。而神的高明之处就是将一切设计好，可以说正是马克达莲娜的感情让她为克罗诺牺牲。到最后她什么都明白时，已经晚了。她说：“现在我什么都明白了。”</p><p>看似普通的情节，正是因为神高明的手腕，让她们把人类最精华的东西淋漓尽致的表现出来了。 其实，他们只要无情一些就可以逃避命运！圣枪修女真地把我好好的净化了一遍！！所以我认为圣枪修女不是宗教片。宗教片一般不会缺资金吧！</p><p>云雾散去，仿佛是在梦中又回到了从前。罗塞特还没有穿上修道骑士服的日子多么令人怀念，却又因为想起了那个必定的结局而为她伤心。穿着修女服的罗塞特看起来成长了不少，只有想起了那最后的一幕时才突然想起她还只是个小女孩。但上帝并没因此而放过罗塞特，他抢走尤修亚时就为罗塞特排好了一切：无用的圣枪，飞奔的指针，灰白的尖角，暗红的圣痕。上帝利用罗塞特的坚强和善良，给她希望，将她引向无尽的黑暗。黑暗中有迎接她的人——被称为恶魔的“天使”，艾恩。纵然有克罗诺在罗塞特身边，神却给了他们最残酷的羁绊。正是这种种残酷啊，使罗塞特即使在轻唤克罗诺“色狼”时，心中也充满了幽怨。因为神并没因为罗塞特的坚强和善良，给她以褒奖。反而让她更加痛苦和绝望。罗塞特没有罪，却为何要面对那么悲惨的命运？而身为一个妙龄女孩的罗塞特，四年多的时间里却只穿过6套衣服。可她却从来没有抱怨过。罗塞特默默地用她的人生背负起了尤修亚，默默地用她的生命背负起了克罗诺。</p><p>爱着罗塞特的克罗诺，其眼中深含了太多的无奈与抱歉！明明说了“我不想浪费你的生命”，却无法留住生命计时器的脚步的无奈和抱歉啊！在命运的沼泽中他们都无力自救。所以克罗诺没有对罗塞特说“我爱你”，而是用“我没打算比你活得更长”这句话充当了誓言。克罗诺明白他欠罗塞特的永远也偿还不完。在战斗中，他顾及的只有罗塞特的生命。在生活中，他对罗塞特更是百般的关心。当罗塞特因为一点点小事而“暴走”时，他总会温柔的劝阻她。而它真正希望的可能希望的可能正是让罗塞特总是那样,因为他想逃避,逃避看到罗塞特眼中的哀怨.罗赛特也深知,她没有时间去羞涩,于是她红着脸为克罗诺献上了她的吻.这一吻本应是温馨的,却也悲哀.这一吻本应是甜蜜的,却也痛苦.因为见证这爱情的正是罗赛特的生命.要是非得用实物的话,除了那块一直折磨着克罗诺的怀表也再没别的.</p><p>神啊,你太残酷了.罗赛特失去了什么时你没有给她补偿,她只是想要回来而已,你借此剥削走她快乐的人生和太多的生命.其实她所”奢望”的, 只是一个健康的尤修亚,再加上一个可爱的克罗诺吧.四年,即使有些许快乐,也班随着痛苦,而又有多少呢?一张照片足以容纳.其余的,太伤感了,所以用一句日语说吧—–”奈”.四年,神的确给了她一个结果.变高了,而且瘦了的尤修亚没变的是纯洁无垢的笑容,充满怜爱的眼神和那一声声饱含信任和依赖的” 姐姐”.当着一声声”姐姐”已然不是在呼唤她时,就成了艾恩早已调配好的猛毒.给罗赛特的内心以毁灭性的侵染.罗赛特不再迟疑之时枪却早已被长着尖角的尤修亚抢去.而又是这吧枪,一枪就干掉了克罗诺的左臂.痛的人是克罗诺,同时更是罗赛特.罗赛特啊,坚强的你内心早已被蛀蚀得满目疮痍.因为你失去的太多太多。”想想我四年来给你的痛苦.”恐怖的影响接连在她眼前闪现.顿时粉碎了她所有的机智和决心.她只知道将一切搞得面目全非的是那个混蛋—–艾恩. 信仰和复仇夹缝中成长的正义，给了她最后的力量。反而使她亲手为自己刻上了圣痕。“你已经是共犯了。”痛苦的嘶叫中尤修亚被掰下了尖角。“你已经是共犯了。”牺牲了自己的克罗诺，被迫“停止”了呼喊。 而这些又是谁的错？罗赛特？艾恩？神？神圣的痛苦也是痛苦，正义的杀戮也是杀戮。可是最终赎罪受过的却只有罗塞特一人！望着“不会走的怀表”，她明白，她已一无所有，但神定然不会停止对它的摧残。自由 ！只有这一种办法可以让她逃离命运的纠缠。“贬天为地，以地位天。”其实，艾恩也一直在恨，恨这神设下圈套，恨自己乖乖进了圈套。“真乖”他玷污着罗赛特的脸时，神也正对他作着同样的动作。</p><p>几乎忘记了一切的罗塞特，却还是将怀表挂在胸前，也许真正的她一直都在等待。“还给我我的生命，不能还给我吗？”这些艾恩指导出的话语，加上她眼中的幽怨，是艾恩对付克罗诺的利剑。但这时的克罗诺没有脆弱的条件，想起罗塞特还在受苦，他只能拾起尖角,最后一战。要死的是那个无赖，艾恩。</p><p>好在罗塞特最后没有射出子弹。“你终于从艾恩心灵的魔咒中解脱出来了，而代价就是这最后的圣痕么？”命运的车轮依旧在旋转。神指着重伤的克罗诺，向罗塞特发问：”违逆”还是”归顺”？ “就算这是神为了拯救这个堕落的世界所发出的指令，但决定的人是我。神赐给了我们智慧，神赐给了我们灵魂。”“现在我什么都明白了。”罗塞特和马克达莲娜都选择了”归顺”。因为神早早就选好了人质——-克罗诺，她们心甘情愿牺牲一切去拯救的人。罗塞特默默的打开了封印——–这生命的闸门！神十分开心。克罗诺虽然赢了，但罗塞特的生命依然只剩半年。</p><p><img src="/images/Chrno/Chrno1.jpg" alt="Chrno"></p><p>“那些不幸的孩子,神会对他们微笑吧.”</p><p>那个静谧的下午,阳光都成了苦涩的太妃糖.这种气氛让我彻底懂得了一个词：断魂.望着马上就要下山的太阳,罗赛特满足地微笑.两行清泪从眼眶中流出.我想这时的罗赛特已经只是一个小女孩.一切都结束了.看着消褪得圣痕,我不禁感叹.神阿,半年的时间真的太短!我不曾怀疑过罗赛特的眼泪是人类最圣洁的甘泉.这是她唯一一次为自己落泪,她知道除了那个无情的神,谁都无力回天.她从来都毫不吝惜地牺牲和奉献——这就是她柔弱的身躯何以撑起那么沉重的命运!我不知那时的气氛是幸福还是温馨,我不知那时他们是悲伤还是悔恨.如果可以,我宁愿用我十年的生命去换他们可以多活半年.也许在我将死之时我才能明白他们这时的情感.”我还不想死”看这在自己怀中的罗赛特,克罗诺也无力给她安慰.毕竟他们正在生离死别.明明爱人就在眼前,却无法留住对方.他和她一样——不甘心!</p><p>神啊,请救救他们.没有回音,世界都安静了下来,只有那夕阳渐渐落下,仿佛是故意为了让众生聆听那怀表自顾自行走的噪音.坚强勇敢的罗赛特,却没有,也许从来都没有,没有勇气注视那生命结束得一瞬.从这一刻起，刻骨的悲伤开始放肆地弥漫。从这一刻起，我开始憎恨，憎恨那些冷眼旁观的诸神！ 愿尤修亚有一天可以抵达他梦中的“魂之大河”，到时请让他们再次相见……</p><p>写在后面的话：</p><p>也许我不久之后就会将那种悲伤淡忘。但也无奈。因为人只是被称为人类的动物。我们不能使自己保持某种感情。所以我们必须选择—— 要么欺骗自己的感情，带着虚伪的痛苦活下去；要么承认人类的这种可悲，带着对自己的鄙视活下去。而我选择了后者。细细一想，我只是一个神都不屑于安排命运的凡人，但我知道这并不是悲哀，也许还是幸运……</p><p><img src="/images/Chrno/Chrno3.jpg" alt="Chrno"></p><p><img src="/images/Chrno/Chrno4.jpg" alt="Chrno"></p><p><img src="/images/Chrno/Chrno5.jpg" alt="Chrno"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Stand Alone Complex 2]]></title>
      <url>http://fengchao.github.io/2006/06/20/Stand-Alone-Complex-2/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:28:19 GMT+0800 (CST) --><p>一篇经典的攻壳文，经典到不转载的话，我觉得对不起作者。 被一篇文章严重吸引 转贴至下转帖]孤立集合体的广大意识形态—另一个角度的攻壳机动队TV ecat2005-5-13, 03:29 AM如果认为士郎的攻壳和押井的攻壳是两个</p><p>作为一个TV版动画，其商业化的气氛相对于漫画和剧场版都是更加浓厚的，其中人物的造型不断的细微变化着，尤其是素子的不同角度的作品，那么神山健治的TV版就是第三种角度的攻壳。师出押井门下的神山秉承了押井集团一贯的 “探讨”作风，不同之处在于他更加倾向于在已经存在的确实理论内部进行讨论，而不像押井总是从人文哲理角度出发提出现在还不存在、将来也未必会有的问题，最后却把悬念当球踢给观众。有悖于前两种风格的TV版因为无论在思路上还是剧情上都相对独立，而被定性为“发生在平行空间的故事”，甚至还会被说成是“同人”。外形更是不断的向着既苗条又丰满的方向发展，辅以其干练的作风与高超的能力，于是产生了一大批叫嚷着“素子JJ”的家伙（我也这么叫过，所以，其实没什么不好啦，汗）。因此也许目前看来TV版在发烧友中的定位相对较低，但是却吸引了更多的眼球。也因为商业化更加彻底，TV版相对前作更为易懂（当然只是相对而已，若拿去与其余的东西相比它仍然是不好懂的）。与漫画的专业，剧场的深邃相比，TV版最另人印象深刻的莫过于其对悬念的整体把握。贯穿动画始终的主线要在最后才能清楚的捕捉到（就SAC而言），而在平时基本只是稍微露出点蛛丝马迹，那条主线看起来是若有若无的。</p><p>先来看被戏称为“从跳楼开始，以跳楼结束”的第一部TV版“Stand Alone Complex”，其剧情上的主线无非是通过“笑脸男人”高超的黑客技术与九课精湛的业务能力破获一桩权钱交易的犯罪行为。而隐藏在这桩案件背后的问题才是全剧所要表达的东西，这在SAC第26集中通过素子与笑脸男人的对话得到集中体现（采用了大量的文学、史学、心理学等等理论作为台词背后的依据，这便是攻壳的内涵之一了，感兴趣者不妨去研究）。</p><p>其实问题就隐藏在SAC这个标题当中。所谓Stand Alone Complex，其解释是多样的，如“不存在的原创品产出了原创的拷贝”、“由特立独行的人组成的某种团体”、“独立复合体”、“孤客情结”等等，是一个极为意识流的词组。把这些解释整合到一起的话，我个人理解为“由孤立个体形成的集合体所体现的巨大意识”。这种巨大的意识是在人的自觉之外的，它无时无刻不在发挥着暗中引导人群的作用，同时又随着各个孤立个体所发生的改变而改变。</p><p>比如说SAC中进行权钱交易的政府官员们，作为个体的官员进行权钱交易无非是为自身牟取利益，但是若这种牟取行为发生了扩散，则可以解释为“牟取利益”这种想法其实是普遍存在于认可权钱交易的官员们之上的巨大意识作用，也就是说因为这群人都有一个内在的共同点“对自身利益的追求”，一旦有人把 “钱”送上门来要求交换“权”的时候，他们的行动就会超乎想象的默契；再比如那些崇拜以及模仿笑脸男人的普通民众，他们的行为看似杂乱无章，但是作用在他们之上的意识体仍然是存在的，就是说他们都有内在的共同点“对政府的不满以及不信任”，笑脸男人不过是一个催化剂，一个引发他们对这种不满和不信任进行宣泄的导火索；还有TV中其余各个看似独立的故事，其行为的出发点仍然可以解释为“巨大意识”的作用，具体的分析就免了，感兴趣的可以自己去仔细研究一下。</p><p>在SAC 第9集“ネットの闇に棲む男 CHAT！ CHAT！ CHAT！”中以网络聊天的形式对笑脸男人事件的开端以及所获得的线索进行了总结，可以说是这部动画中最为难懂的一集。其实在讨论笑脸男人事件的同时，也暗示了“意识作用”的存在。剧中提及模仿笑脸男人现象时也有过类似“这究竟是什么原因”之类的一两句对话，甚至还怀疑所谓的笑脸男人不过是虚构（这里暗示得很明显了，虽然笑脸男人确实是存在，但是这样的怀疑正好符合了“意识作用才是主体”的主旨）。可惜只是稍微提了一下而已。。。当然过早的揭示了主题也就没有意思了，同样其构筑在悬念之上的信服力也会轻易失去。。。</p><p>最后笑脸男人与素子在图书馆中的对话也是一个重点部分。两人通过对一直以来所发生的种种现象的讨论，不约而同的把原因都总结到了“Stand Alone Complex”之上。不过这种种现象包含了一个绝对的前提：一个能够把这种意识作用最大化的合适触媒。</p><p>笑脸男人说自己对于此桩犯罪的接触始于在网络中接收到一份“由本来不存在的原创体发出的原创拷贝”，这话该怎么理解呢？所谓“不存在的原创体发出的原创拷贝”直接理解就是“无中生有”，但是道理很明显的摆在那里，没有前因何来后果？因此这句话应该理解为笑脸男人无意间接触到了由各方面情报所组成的复合体，这又回到了漫画中的情报论范畴。而所谓“情报复合体”，在TV版的设定下，或许可以理解为就是超出人类自觉的“巨大意识”的雏形（来自权钱交易的广大受害者的怨念，出钱者的怨念，出权者的怨念，等等）。来自各方面的情报综合到一起，就形成了一个没有固定来源的原创拷贝。因此与其说是“无中生有”，不如说是以人类现有的能力无法查清楚其所有的来源。。。</p><p>稍微剖析一下的话，笑脸男人的心态完全可以用一句笑脸图标上的英文来表达：“I thougth what I’d do was. I’d pretend to be one of those (blind) deaf-mutes, or should I?”，这其实反映了笑脸男人孤立于社会之外，但是又心有不甘的“孤立情结”。为了获取情报或者其余不可知的理由，笑脸男人把自己禁闭在一个巨大的图书馆内，一方面与现实世界几乎脱节，一方面又不得不保持与外部世界的联系（比如通过网络）。其实这也是Cyborg-Technology时代的一种通病。这种通病的存在使得由孤立体所组成的大众对情报的敏感程度上升到一定范围，由于笑脸男人的心态与普通大众的心态之间存在彼此类似的point，于是通过这些 point之间的相互联系与共鸣，建立出了“由不存在的原创体（笑脸男人外在的公众印象）发出的原创拷贝（模仿笑脸男人的行为）”的关系，从而实现了 “Stand Alone Complex”这种互动，进而继续放大到成为一个广泛的社会现象。</p><p>另外有人说SAC其实也是素子的生活形态。。。但不管怎么说，这是在科技发达到一定程度，信息高度共享的时代才会发生的事情。一个极其方便而且巨大到无处不在的网络才是其滋生的土壤。。。</p><p>关于SAC的麦田守望情结，我所能记忆住的也就是那个巨大的“笑脸麦田圈”。之前其实也看过某强悍至极点的相关研究文，但是因为太过复杂看过就忘记了。。。</p><p>然后来看又是以素子“跳楼大作战”开始的TV版动画第二部“S.A.C 2nd Gig”。在开始唧唧歪歪的说明我个人观点之前先怨念一个：与前作一样的一月两集的速度实在是让人好等，而其在翻译上的难度更加延迟了字幕版的推出速度（谁让我日语苦手呢）。但是冲着其精良的制作与精彩的内容，也只有继续这么怨念下去了。。。</p><p>在这里先放出Gig的OP“rise”中部分英语歌词，算是向大神菅野洋子致敬（关于她和她的音乐的介绍太多了，俺不多嘴），虽然这与帖子内容的关系不大，但请原谅我的任性吧。。。</p><p>Save your tears</p><p>for the day</p><p>when the pain is far behind</p><p>on your feet</p><p>come with me</p><p>we are soldiers stand or die</p><p>Save your fears</p><p>take your place</p><p>save them for the judgment day</p><p>fast and free</p><p>follow me</p><p>time to make the sacrifice<br>We rise or fall</p><p>写得超级带劲的词呢，哇哈哈。。。</p><p>回到正题。现在Gig仍在正在播出中，因此总体的指出其内涵对我来说有那么点勉强，而剧情也只是刚刚进入高潮，所以要说剧情的话实在也没什么好说的。总之这次用来讨论的故事是发生在流入日本的难民与个别主义者之间的冲突。内阁情报部的长官合田一人目前看起来似乎是推动冲突升级的罪魁祸首。</p><p>在第1集中侵占中国大使馆的某一个恐怖分子曾宣称“我们是个别的十一人，就算我们在这里被打倒，个别的自我也会继承我们的意志；所以对我们来说，死是没有意义的”。这句话明显有上部TV版“意识作用”的痕迹，但是也有不同。</p><p>作品中的所谓个别主义者，其实只是一些极端的民族主义分子以及对国家难民政策不满的家伙。他们对于国外流入的难民不但占用了大量的政府预算，同时还与日本国民竞争本来就不多的工作机会深恶痛绝，因此群起发动恐怖主义事件，或警告或要挟，希望以此达到在日本根除难民的目的。放大来说，对难民的敌视其实是广泛存在于日本国民之间的，因此“在人类自觉之外的巨大意识体”是成立的；但是与“Stand Alone Complex”不同的是，这种“巨大意识作用”开始进化，对于“触媒”的要求开始变得不那么明显，而且个别主义者相互之间的信念也开始趋于同步。简单的说，就是某一种广泛开展的运动不再需要一个明显的导火索，而转变为一种建立在对某种事物的共识之上的自觉运动；当然没有了导火索不代表没有别的东西，看起来作为幕后BOSS的合田一人其实就是推动个别主义运动加速公开化激进化的催化剂。所以相比前作的笑脸男人，合田的作用被隐蔽化以及小化了。以往那种“由个体带动群体”的模式被“由群体带动群体，某个体进行推波助澜”所取代。</p><p>合田发觉了国民对于难民的广泛敌视情绪以及个别主义的苗头，意识到社会在经历了笑脸男人事件之后具备了更高的敏感度，所以暗中推动了个别主义行动（动机是什么还只能靠猜），凭借前人所作的革命文集作为其个人意识的载体，不用自己出面就做到了在人群中散播“个别主义”的效果（通过将作为载体的文集注入潜伏性病毒而驱使读者按照其设定好的路线行动，而这些文集在我的理解中本身就宣扬了“革命是对现状不满的自救行为”这种观点）。而那篇其实是子虚乌有的未收录文集“个别的十一人”，一来作为潜伏性病毒的触发条件，二来也宣扬了以牺牲个人生命要挟政府的恶毒观念（第12集中那些个别主义者们就在镜头前挥刀互相斩下对方的头部）。如此一来要挟政府的目的达到，也起到了让更多人因为对个别主义的兴趣或者对个别主义者的同情而加入个别主义行列的效果（其实就是广告）。</p><p>而目前所能看到最新的有字幕版是第15集，虽然离26集完结的距离还很远，但其恰恰起到了如前作第9集一般的效果。所不同的是上次以一堆人进行网络聊天为形式而暗示主题，这次就换成塔奇克马之间的互相讨论。其中有几句话是极其重要的。比如“个别主义者虽然强调个体，但其实挺没个性”，这说明作为自以为与众不同的个别主义者，他们的行为反而因为同样的“意识作用”而殊途同归，相反一直进行着同步化的塔奇克马们，却因为其本身之上不存在生命体特有的 “巨大意识”（也就是说其没有明确的“自我”，无需考虑“我”怎样之类的问题），反而能在允许范围之内逐渐产生出差异性（这么说吧，趋向某种形式的完善的个体都会是类似的，而从零起步的个体产生差异性的概率极大）；再比如“人在个人和集团之外另有主体能决定集团意识”，这正是所谓的“巨大意识”，其产生于个体的意识，反过来又引导着个体的意识，两者同样引导着社会的运作；还比如“人类是具有最合理的主体和意识的最小单位”，则对由人构成的集团的行动的影响，无论在宏观层次来看（还是指的“巨大意识”），还是从微观层次来看（人本身的某种意识，以及规模更小但对个体意识能够产生影响的某些因素），其最终都是作用到“人”之上，因此都是等效存在的；而最重要的一句“脱离自身意识的无意识作为整体意识而形成”，正是我一直所说的“巨大意识”的最好注解。</p><p>当然这仍然是在科技和网络发达到一定程度之后才可能发生的情况。当人类可以做到随时随地使用整合式通讯装置接入信息极其丰富且高度共享的网络时，这种情况才会加速发生。若将这种由人类产生但是在人类自觉之外的广大意识形态认为是“神”，将这种意识对行为的引导作用认为是“神的指引”的话，是否就可以说其实所谓的“神”就是安装了电子脑的人类自己呢？用封神中的话来说，那便是历史的道标啊。。。</p><p>能说的就说到这里了，也不保证在后来的剧情中我所说的这套歪论会被全盘推翻，总之，我个人的理解就只能说到这里了。。。对了，差点忘记还有随 DVD附送的特典性质动画“塔奇克马的日常生活”，现在有两部，第一部26集，每集一分钟左右；至于第二部由于只看了一集，所以其余的也说不出什么了。总之是搞笑＋可爱，顺便有对TV内容的补完（不仔细看的话看不出来），整体而言是一部轻松的作品，因此也没什么好说的了。。。至于游戏，我还没玩过呢。。。</p><p>TV 版动画与前作的区别还在于对于九课其余成员的刻画更加丰满和到位，荒卷、巴特和特古萨这三个一直保持着高出镜率的人不提，石川、斋藤、帕兹等人也有一定的戏份，这样九课作为一个整体的感觉更加强了，其成员的个性以及团队的合作也更加突出。在漫画中这些成员的出场往往是“某某，把XX整理出来” 之类的一两句对话而已，到了剧场版中他们的戏份就更加少了，身为配角真是悲哀啊。不过这也能说明TV版在商业考量上更进一步，其可看性相对更高。。。</p><p>记得在Gig第11集放出之后，各大论坛立马哀鸿遍野（夸张了，总之引起很大反响就是了），因为素子的初恋情人出现了，而且也是全身义体化。。。那么，目前看起来同样是全身义体化的人只有那个刺杀首相的白头男。。。所以，莫非是他？而且Gig的OP中也有个素子和他独处的画面，莫非真的是他？我能理解广大一边喊叫着“素子JJ”一边几乎控制不住要暴走的Fans的心情，其实我也有点不爽。。。不过这又说明了Gig相比前作更加商业化了，居然史无前例的把情感纠葛要素提高到这个地步。。。口胡，这逆天的情感啊，明明只要有素子与巴特之间暧昧的同事关系供我们YY就足够了。。。但是从这一集中也可以看出全身义体化其实并不是“高级”的代名词，因为被全身义体化而随着年纪的增长需要不断的更换适合的义体，每次更换完之后还得从头经历一次由头至脚的适应过程。其繁琐与高成本导致了部分义体化成为真正的潮流。这样也回答了为什么在义体科技如此发达的年代还会有人老化的问题，一来是因为部分义体化，身体的自然部分总是会老化的，对应的义体也得换装；二来是因为GHOST，其控制着人的一切，因此GHOST老化了，躯体对应也就老化了。。。</p><p>最后说说这部作品的标题。S.A.C当然不用说了，前面已经解释了很多；2nd字面理解，要么是“第二阶段”，要么是“第二部作品”，我个人偏向于使用前面那个解释；最困难的就在于Gig是什么，因为官方没有给出解释，我在网上查了很久，结果查到的一个解释居然是game in game，瀑布汗。。。也有说是Ghost in Ghost的，这种说法应该说还算合理，假如理解成因为Ghost的互相渗透而实现了无需导火索的同步互动的话，不过总觉得还是含糊和片面了点；另外的答案还有Ghost inosculate Ghost（灵与灵的融合），此解释也比较合理，相比Ghost in Ghost的解释应该更为明确，正好可以作为SAC第二阶段的解释而存在；还有一个怎么看怎么扯谈的解释：Global Information Grid。。。最后无奈之下只好到Production I.G官方网站的论坛里面去求证，得到了一个这样的答案：</p><p>Well, it doesn’t have an official meaning like SAC does (Stand Alone Complex).</p><p>Dictionary.com defines it as:</p><p>A demerit given in the military.</p><p>A job, especially a booking for musicians.</p><p>A playful or wanton girl; a giglot.</p><p>这便是传说中的国际玩笑了吧。。。<br>PS： 不知道已经是多少次看关于STAND ALONE COMPLEX的作品以及相关评论了 只是每次总能看到更多的东西。</p><p>沉浸其中，几乎忘记了现实。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Stand Alone Complex]]></title>
      <url>http://fengchao.github.io/2006/06/19/Stand-Alone-Complex/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p><img src="/images/StandAlone/StandAlone1.jpg" alt="Stand Alone"></p><p>曾经以为我对机器人的认识已经很深刻，看了攻壳以后才发现原来自己很幼稚。也许我会一直幼稚下去。突然想起那次点名”做过的最幼稚的事是什么？”也许就是认为自己不再幼稚了吧。那一天。 如果用一句话来形容“攻壳机动队”这部动画片的话，也许就是许多网友所说的“看完这部动画，发现其他的动画都那么幼稚。”我看的动画不多，不敢妄加评论。不过，这是唯一一部我看完之后写观后感的动画，而且几乎每集都写。想把它完全说明白，几乎是不可能的。下面仅仅引用两篇Space文章来佐证它的深刻。如果你感兴趣，请看原动画+剧场版。</p><p>两部动画的第十五集都写得很深刻，如果你只想看两集的话，这两集的收获一定最大。</p><p>两部动画的最后一集都看了两遍，一共哭了四次。所以不想再看了，怕再哭。</p><p>由于主题需要，以后将主要讨论动画中涉及的机器人技术及人工智能。尽管它们仅仅是动画的一小部分</p><p><img src="/images/StandAlone/StandAlone3.jpg" alt="Stand Alone"></p><p><img src="/images/StandAlone/StandAlone2.jpg" alt="Stand Alone"></p><p><img src="/images/StandAlone/Ghost-in-the-Shell.jpg" alt="Stand Alone"></p><!-- rebuild by neat -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理性的局限]]></title>
      <url>http://fengchao.github.io/2006/06/07/limitation-of-rational/</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 20 2017 11:07:19 GMT+0800 (CST) --><p>数学是纯粹的、显然的、不存在实体的抽象。“在纯粹的数学中，我们不知道自己正在说什么，也不明白我们所说的什么才是正确的”。数学，代表了绝对的理性。</p><p>笛卡尔就是一个理性主义者，认为人类应该可以使用数学的方法――也就是理性――来进行哲学思考。他相信，理性比感官的感受更可靠，所以对每一件事情都要进行怀疑，而不能信任我们的感官。而当人在怀疑时，他必定在思考，由此他推出了著名的“我思故我在”(Cogito ergo sum)。人需要从理性的原点出发，不依靠任何已有的知识来思考。笛卡尔相信人可以不依靠现有的知识，仅凭理性就可求真：用数学和物理就可以认识物资世界；凭沉思(Meditation)就可以达到精神的理解。 他的墓碑上刻了这样一句话：“笛卡儿，欧洲文艺复兴以来，第一个为人类争取并保证理性权利的人。”</p><p>于是乎，后来的数学人大都把用数学统一世界作为自己的理想。这个理想在希尔伯特身上达到极致，在1900年，他提出了著名的希尔伯特问题，共23条，包含了当时数学上悬而未决的主要难题。他希望人们花时间弄清楚它们，困难虽大，但这些难题破解之时，它们的光辉将照耀以之为基础的更广阔领域。</p><p>其中第二个问题，要证明算术公理的相容性，第十个问题，是判定问题，问题是设计一个过程，根据它可以确定是不是任何问题通过有限步都能得以解决。这是希尔波特最重要的两个难题，它们击中了数学哲学的心脏，以最直接的方式检验它的能力。因为悖论和无限的问题，当时的数学已经出现了危机。他希望用元数学解决数学危机，并启动了希尔伯特计划，以保卫古典数学 ，避免悖论。</p><p>对于判定问题，丘奇和图灵同时对其发起进攻。他们用不同的方法都给出了否定的答案。其中图灵发明了“逻辑计算机”也就是图灵机来进行证明。图灵机成为现在数字计算机的原型，《论可计算数及其在判定问题中的应用》则成为阐明现代电脑原理的开山之作，被永远载入了计算机的发展史册，照耀着现代电脑的前进方向。而冯.诺依曼也亲手把“计算机之父”的桂冠转戴在这位英国科学家头上。</p><p>图灵也是人工智能的奠基人， 他相信机器可以模拟人的智力，也深知让人们接受这一想法的困难，今天仍然有许多人认为人的大脑是不可能用机器模仿的。而在图灵认为，这样的机器一定是存在的。在《计算机器与智能》这一划时代的论文中，图灵提出了人工智能的行为主义检验方式：图灵实验，成为当之无愧的人工智能之父。而图灵对判定问题给出的否定，似乎也说明：仅靠逻辑判断，机器是不能获得人的智能的。</p><p>对于希尔伯特第二问题，哥德尔同样给出了否定的答案。这一否定，给了希尔伯特计划最致命的打击。哥德尔定理成为20世纪逻辑学最漂亮的成就。在 1931 年的文章《论数学原理及有关系统中形式上不可判定的命题》中，哥德尔说明了在任何公理化的数学体系中，以系统公理为基础，都存在无法证明或者反驳的元数学命题。最终，数学是不完备的。这意味着存在无限个数学陈述，虽然它们有可能是真的，但是无法从给定的一套公理中推导出来。这就是纯粹理性的局限。</p><p>康德认为，人的大脑以某种方式进化，从而具备对自然数机器对应集合的处理能力。对这些概念进行简单的操作以及基本的逻辑，已经结构化的存在于大脑的神经网络之中。但是这不是大脑的唯一才能。任何人都不应该妄图以绝对的理性解释这个世界、指导自己的行动。因为理性的局限，总有一天，他会死得很惨。</p><p>“真理是纯粹的，但是从来不简单”。</p><!-- rebuild by neat -->]]></content>
    </entry>
    
  
  
</search>
